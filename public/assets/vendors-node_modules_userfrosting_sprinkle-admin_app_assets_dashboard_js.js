(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_userfrosting_sprinkle-admin_app_assets_dashboard_js"],{

/***/ "./node_modules/@userfrosting/sprinkle-admin/app/assets/dashboard.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@userfrosting/sprinkle-admin/app/assets/dashboard.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// ------ Import Base Theme ------
__webpack_require__(/*! ./userfrosting/js/handlebars-helpers.js */ "./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/js/handlebars-helpers.js");
__webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
__webpack_require__(/*! tablesorter */ "./node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js");
__webpack_require__(/*! tablesorter/dist/js/widgets/widget-columnSelector.min.js */ "./node_modules/tablesorter/dist/js/widgets/widget-columnSelector.min.js");
__webpack_require__(/*! tablesorter/dist/js/widgets/widget-reflow.min.js */ "./node_modules/tablesorter/dist/js/widgets/widget-reflow.min.js");
__webpack_require__(/*! tablesorter/dist/js/widgets/widget-pager.min.js */ "./node_modules/tablesorter/dist/js/widgets/widget-pager.min.js");
__webpack_require__(/*! @userfrosting/theme-adminlte/app/assets/userfrosting/js/query-string.js */ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/query-string.js");
__webpack_require__(/*! @userfrosting/theme-adminlte/app/assets/userfrosting/js/tablesorter/widget-sort2Hash.js */ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/tablesorter/widget-sort2Hash.js");
__webpack_require__(/*! @userfrosting/theme-adminlte/app/assets/userfrosting/js/uf-table */ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/uf-table.js");

__webpack_require__(/*! ./font-starcraft/css/font-starcraft.css */ "./node_modules/@userfrosting/sprinkle-admin/app/assets/font-starcraft/css/font-starcraft.css");
__webpack_require__(/*! tablesorter/dist/css/theme.bootstrap.min.css */ "./node_modules/tablesorter/dist/css/theme.bootstrap.min.css");
__webpack_require__(/*! tablesorter/dist/css/jquery.tablesorter.pager.min.css */ "./node_modules/tablesorter/dist/css/jquery.tablesorter.pager.min.css");
__webpack_require__(/*! @userfrosting/theme-adminlte/app/assets/userfrosting/css/tablesorter-reflow.css */ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/css/tablesorter-reflow.css");
__webpack_require__(/*! ./userfrosting/css/tablesorter-custom.css */ "./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/css/tablesorter-custom.css");


/***/ }),

/***/ "./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/js/handlebars-helpers.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/js/handlebars-helpers.js ***!
  \****************************************************************************************************/
/***/ (() => {

/**
 * This file contains extra helper functions for Handlebars.js.
 *
 * @see http://handlebarsjs.com/#helpers
 */

 /**
  * Improved comparison operator
  * See https://stackoverflow.com/a/16315366/2970321
  */
Handlebars.registerHelper('ifx', function (v1, operator, v2, options) {
    switch (operator) {
        case '==':
            return (v1 == v2) ? options.fn(this) : options.inverse(this);
        case '===':
            return (v1 === v2) ? options.fn(this) : options.inverse(this);
        case '!=':
            return (v1 != v2) ? options.fn(this) : options.inverse(this);
        case '!==':
            return (v1 !== v2) ? options.fn(this) : options.inverse(this);
        case '<':
            return (v1 < v2) ? options.fn(this) : options.inverse(this);
        case '<=':
            return (v1 <= v2) ? options.fn(this) : options.inverse(this);
        case '>':
            return (v1 > v2) ? options.fn(this) : options.inverse(this);
        case '>=':
            return (v1 >= v2) ? options.fn(this) : options.inverse(this);
        case '&&':
            return (v1 && v2) ? options.fn(this) : options.inverse(this);
        case '||':
            return (v1 || v2) ? options.fn(this) : options.inverse(this);
        default:
            return (v1 == v2) ? options.fn(this) : options.inverse(this);
    }
});

/**
 * Perform simple calculations.
 *
 * usage: {{calc x '+' 2}}
 */
Handlebars.registerHelper('calc', function (v1, operator, v2, options) {
    lvalue = parseFloat(v1);
    rvalue = parseFloat(v2);

    return {
        "+": lvalue + rvalue,
        "-": lvalue - rvalue,
        "*": lvalue * rvalue,
        "/": lvalue / rvalue,
        "%": lvalue % rvalue
    }[operator];
});

/**
 * format an ISO date using Moment.js
 *
 * moment syntax example: moment(Date("2011-07-18T15:50:52")).format("MMMM YYYY")
 * usage: {{dateFormat creation_date format="MMMM YYYY"}}
 * @requires momentjs http://momentjs.com/
 */
Handlebars.registerHelper('dateFormat', function(context, block) {
    if (window.moment) {
        var f = block.hash.format || "MMM Do, YYYY";
        return moment(context).format(f);
    } else {
        //  moment plugin not available. return data as is.
        console.log("The moment.js plugin is not loaded.  Please make sure you have included moment.js on this page.");
        return context;
    }
});

/**
 * Format a phone number.
 */
Handlebars.registerHelper("phoneUSFormat", function(phoneNumber) {
  if (typeof phoneNumber === 'undefined') {
    return '';
  }

  phoneNumber = phoneNumber.toString();
  return "(" + phoneNumber.substr(0,3) + ") " + phoneNumber.substr(3,3) + "-" + phoneNumber.substr(6,4);
});

/**
 * Format currency (USD).
 */
Handlebars.registerHelper("currencyUsdFormat", function(amount) {
    var parsedAmount = parseFloat(amount);
    if (parsedAmount < 0) {
        return "-$" + Math.abs(parsedAmount).toFixed(2);
    } else {
        return "$" + parsedAmount.toFixed(2);
    }
});

/**
 * Convert a string to a slug using speakingurl.js.
 *
 * @requires speakingurl https://pid.github.io/speakingurl/
 */
Handlebars.registerHelper('slug', function(text) {
    return getSlug(text);
});


/***/ }),

/***/ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/query-string.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/query-string.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**
 * @add jQuery.String
 */
$.String = $.extend($.String || {}, {
    /**
     * @function deparam
     *
     * Takes a string of name value pairs and returns a Object literal that represents those params.
     *
     * @param {String} params a string like <code>"foo=bar&person[age]=3"</code>
     * @return {Object} A JavaScript Object that represents the params:
     *
     *     {
     *       foo: "bar",
     *       person: {
     *         age: "3"
     *       }
     *     }
     */
    deparam: function(params){
        var digitTest = /^\d+$/,
            keyBreaker = /([^\[\]]+)|(\[\])/g,
            plus = /\+/g,
            paramTest = /([^?#]*)(#.*)?$/;

        if(! params || ! paramTest.test(params) ) {
            return {};
        }


        var data = {},
            pairs = params.split('&'),
            current;

        for(var i=0; i < pairs.length; i++){
            current = data;
            var pair = pairs[i].split('=');

            // if we find foo=1+1=2
            if(pair.length != 2) {
                pair = [pair[0], pair.slice(1).join("=")]
            }

    var key = decodeURIComponent(pair[0].replace(plus, " ")),
      value = decodeURIComponent(pair[1].replace(plus, " ")),
                parts = key.match(keyBreaker);

            for ( var j = 0; j < parts.length - 1; j++ ) {
                var part = parts[j];
                if (!current[part] ) {
                    // if what we are pointing to looks like an array
                    current[part] = digitTest.test(parts[j+1]) || parts[j+1] == "[]" ? [] : {}
                }
                current = current[part];
            }
            lastPart = parts[parts.length - 1];
            if(lastPart == "[]"){
                current.push(value)
            }else{
                current[lastPart] = value;
            }
        }
        return data;
    }
});


/***/ }),

/***/ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/tablesorter/widget-sort2Hash.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/tablesorter/widget-sort2Hash.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/*! Widget: sort2Hash (BETA) - updated 8/12/2017 (v2.28.15.uf) */
/* Requires tablesorter v2.8+ and jQuery 1.7+
 * by Rob Garrison
 *
 * Temporary patched version of widget to handle browser history issues (#712).
 */
;( function( $ ) {
	'use strict';
	var ts = $.tablesorter || {},
	s2h = ts.sort2Hash = {
		init : function( c, wo ) {
			var filter, temp, page, size,
				table = c.table,
				pager = c.pager,
				hasSaveSort = ts.hasWidget( table, 'saveSort' ),
				sort = s2h.decodeHash( c, wo, 'sort' );
			if ( ( sort && !hasSaveSort ) || ( sort && hasSaveSort && wo.sort2Hash_overrideSaveSort ) ) {
				s2h.convertString2Sort( c, wo, sort );
			}
			if ( ts.hasWidget( c.table, 'pager' ) ) {
				temp = parseInt( s2h.decodeHash( c, wo, 'page' ), 10 );
				page = pager.page = ( temp < 0 ? 0 : ( temp > pager.totalPages ? pager.totalPages - 1 : temp ) );
				size = pager.size = parseInt( s2h.decodeHash( c, wo, 'size' ), 10 );
			}
			if ( ts.hasWidget( table, 'filter' ) ) {
				filter = s2h.decodeHash( c, wo, 'filter' );
				if ( filter ) {
					filter = filter.split( wo.sort2Hash_separator );
					c.$table.one( 'tablesorter-ready', function() {
						setTimeout(function(){
							c.$table.one( 'filterEnd', function() {
								$(this).triggerHandler( 'pageAndSize', [ page, size ] );
							});
							// use the newest filter comparison code
							if ( ts.filter.equalFilters ) {
								temp = ts.filter.equalFilters( c, c.lastSearch, filter );
							} else {
								// quick n' dirty comparison... it will miss filter changes of
								// the same value in a different column, see #1363
								temp = ( c.lastSearch || [] ).join( '' ) !== ( filter || [] ).join( '' );
							}
							// don't set filters if they haven't changed
							if ( !temp ) {
								$.tablesorter.setFilters( table, filter, true );
							}
						}, 100 );
					});
				}
			}
			if ( !filter ) {
				c.$table.one( 'tablesorter-ready', function() {
					c.$table.triggerHandler( 'pageAndSize', [ page, size ] );
				});
			}

			c.$table.on( 'sortEnd.sort2hash filterEnd.sort2hash pagerComplete.sort2Hash', function() {
				if ( this.hasInitialized ) {
					s2h.setHash( this.config, this.config.widgetOptions );
				}
			});
		},

		getTableId : function( c, wo ) {
			// option > table id > table index on page
			return wo.sort2Hash_tableId ||
				c.table.id ||
				'table' + $( 'table' ).index( c.$table );
		},
		regexEscape : function( v ) {
			return v.replace( /([\.\^\$\*\+\-\?\(\)\[\]\{\}\\\|])/g, '\\$1');
		},
		// convert 'first%20name,asc,last%20name,desc' into [[0,0], [1,1]]
		convertString2Sort : function( c, wo, sortHash ) {
			var regex, column, direction, temp, index, $cell,
				arry = sortHash.split( wo.sort2Hash_separator ),
				indx = 0,
				len = arry.length,
				sort = [];
			while ( indx < len ) {
				// column index or text
				column = arry[ indx++ ];
				temp = parseInt( column, 10 );
				// ignore wo.sort2Hash_useHeaderText setting &
				// just see if column contains a number
				if ( isNaN( temp ) || temp > c.columns ) {
					regex = new RegExp( '(' + s2h.regexEscape( column ) + ')', 'i' );
					for ( index = 0; index < c.columns; index++ ) {
						$cell = c.$headerIndexed[ index ];
						if ( regex.test( $cell.attr( wo.sort2Hash_headerTextAttr ) ) ) {
							column = index;
							index = c.columns;
						}
					}
				}
				direction = arry[ indx++ ];
				// ignore unpaired values
				if ( typeof column !== 'undefined' && typeof direction !== 'undefined' ) {
					// convert text to 0, 1
					if ( isNaN( direction ) ) {
						// default to ascending sort
						direction = direction.indexOf( wo.sort2Hash_directionText[ 1 ] ) > -1 ? 1 : 0;
					}
					sort.push( [ column, direction ] );
				}
			}
			if ( sort.length ) {
				c.sortList = sort;
			}
		},

		// convert [[0,0],[1,1]] to 'first%20name,asc,last%20name,desc'
		convertSort2String : function( c, wo ) {
			var index, txt, column, direction,
				sort = [],
				arry = c.sortList || [],
				len = arry.length;
			for ( index = 0; index < len; index++ ) {
				column = arry[ index ][ 0 ];
				txt = $.trim( c.$headerIndexed[ column ].attr( wo.sort2Hash_headerTextAttr ) );
				sort.push( txt !== '' ? encodeURIComponent( txt ) : column );
				direction = wo.sort2Hash_directionText[ arry[ index ][ 1 ] ];
				sort.push( direction );
			}
			// join with separator
			return sort.join( wo.sort2Hash_separator );
		},

		convertFilter2String : function( c, wo ) {
			var index, txt, column, direction,
				sort = [],
				arry = c.sortList || [],
				len = arry.length;
			for ( index = 0; index < len; index++ ) {
				column = arry[ index ][ 0 ];
				txt = $.trim( c.$headerIndexed[ column ].attr( wo.sort2Hash_headerTextAttr ) );
				column = typeof txt !== 'undefined' ? encodeURIComponent( txt ) : column;
				sort.push( column );
				direction = wo.sort2Hash_directionText[ arry[ index ][ 1 ] ];
				sort.push( direction );
			}
			// join with separator
			return sort.join( wo.sort2Hash_separator );
		},

		// Get URL Parameters (getParam)
		// modified from http://www.netlobo.com/url_query_string_javascript.html
		getParam : function ( name, hash, returnRegex ) {
			if ( !hash ) { hash = window.location.hash; }
			var regex = new RegExp( '[\\?&]' + s2h.regexEscape( name ) + '=([^&#]*)' ),
				match = regex.exec( hash );
			if ( returnRegex ) { return regex; }
			return match === null ? '' : decodeURIComponent( match[ 1 ] );
		},

		// remove parameter from hash
		removeParam : function( name, hash ) {
			if ( !hash ) { hash = window.location.hash; }
			var index,
				regex = s2h.getParam( name, hash, true ),
				result = [],
				parts = hash.split( '&' ),
				len = parts.length;
			for ( index = 0; index < len; index++ ) {
				// regex expects a leading '&'...
				if ( !regex.test( '&' + parts[ index ] ) ) {
					result.push( parts[ index ] );
				}
			}
			return result.length ? result.join( '&' ) : '';
		},

		encodeHash : function( c, wo, component, value, rawValue ) {
			var result = false,
				tableId = s2h.getTableId( c, wo );
			if ( typeof wo.sort2Hash_encodeHash === 'function' ) {
				result = wo.sort2Hash_encodeHash( c, tableId, component, value, rawValue || value );
			}
			if ( result === false ) {
				result = '&' + component + '[' + tableId + ']=' + value;
			}
			return result;
		},

		decodeHash : function( c, wo, component ) {
			var result = false,
				tableId = s2h.getTableId( c, wo );
			if ( typeof wo.sort2Hash_decodeHash === 'function' ) {
				// return a string
				result = wo.sort2Hash_decodeHash( c, tableId, component );
			}
			if ( result === false ) {
				result = s2h.getParam( component + '[' + tableId + ']' );
			}
			return result || '';
		},

		cleanHash : function( c, wo, component, hash ) {
			var result = false,
				tableId = s2h.getTableId( c, wo );
			if ( typeof wo.sort2Hash_cleanHash === 'function' ) {
				// can return an array or string
				result = wo.sort2Hash_cleanHash( c, tableId, component, hash );
			}
			if ( result === false ) {
				// parameter example: 'sort[table0]=0,0'
				result = s2h.removeParam( component + '[' + tableId + ']', hash );
			}
			return result || '';
		},

		setHash : function( c, wo ) {
			var str = '',
				hash = window.location.hash,
				hasPager = ts.hasWidget( c.table, 'pager' ),
				hasFilter = ts.hasWidget( c.table, 'filter' ),
				sortList = s2h.convertSort2String( c, wo ),
				filters = ( hasFilter && c.lastSearch.join('') !== '' ? c.lastSearch : [] ),
				filtersStr = encodeURIComponent( filters.join( c.widgetOptions.sort2Hash_separator ) ),
				components = {
					'sort'   : sortList ? s2h.encodeHash( c, wo, 'sort', sortList, c.sortList ) : '',
					'page'   : hasPager ? s2h.encodeHash( c, wo, 'page', c.pager.page + 1 ) : '',
					'size'   : hasPager ? s2h.encodeHash( c, wo, 'size', c.pager.size ) : '',
					'filter' : filtersStr ? s2h.encodeHash( c, wo, 'filter', filtersStr, filters ) : ''
				};
			// remove old hash
			$.each( components, function( component, value ) {
				hash = s2h.cleanHash( c, wo, component, hash );
				str += value;
			});

            // Combine new hash with any existing hashes
            var hashChar = c.widgetOptions.sort2Hash_hash;
            var newHash = ( ( window.location.hash || '' ).replace( hashChar, '' ).length ? hash : wo.sort2Hash_hash ) + str;
            var baseUrl = window.location.href.split(hashChar)[0];
            // Ensure that there is a leading hash character
            var firstChar = newHash[0];
            if (firstChar != hashChar) {
                newHash = hashChar + newHash;
            }

            // Update URL in browser
            window.location.replace(baseUrl + newHash);
		}
	};

	ts.addWidget({
		id: 'sort2Hash',
		priority: 60, // after saveSort & pager
		options: {
			sort2Hash_hash              : '#',      // hash prefix
			sort2Hash_separator         : '-',      // don't '#' or '=' here
			sort2Hash_headerTextAttr    : 'data-header', // data attribute containing alternate header text
			sort2Hash_directionText     : [ 0, 1 ], // [ 'asc', 'desc' ],
			sort2Hash_overrideSaveSort  : false,    // if true, override saveSort widget if saved sort available

			// this option > table ID > table index on page
			sort2Hash_tableId           : null,
			// custom hash processing functions
			sort2Hash_encodeHash        : null,
			sort2Hash_decodeHash        : null,
			sort2Hash_cleanHash         : null
		},
		init: function(table, thisWidget, c, wo) {
			s2h.init( c, wo );
		},
		remove: function(table, c) {
			c.$table.off( '.sort2hash' );
		}
	});

})(jQuery);


/***/ }),

/***/ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/uf-table.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/js/uf-table.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**
 * uf-table plugin.  Sets up a Tablesorter table with sorting, pagination, and search, and fetches data from a JSON API.
 *
 * This plugin depends on query-string.js, which is used to convert a query string into a JSON object.
 *
 * jQuery plugin template adapted from https://gist.github.com/Air-Craft/1300890
 *
 * === USAGE ===
 *
 * Create a container element, and within it place your table, paging controls, and Handlebars templates for rendering the cells.
 *
 * - Your table should have a unique id, and your paging controls should be wrapped in an element with the `.js-uf-table-pager` class.
 * - Create a button with the `.js-uf-table-download` class, and it will be automatically bound to trigger an AJAX request for downloading the table (CSV, etc).
 *
    <div id="widget-users">
       <table id="table-users" class="tablesorter table table-bordered table-hover table-striped" data-sortlist="[[0, 0]]">
           <thead>
               <tr>
                   <th class="sorter-metatext" data-column-name="name" data-column-template="#user-table-column-info">User <i class="fa-solid fa-sort"></i></th>
                   <th class="sorter-metanum" data-column-name="last_activity" data-column-template="#user-table-column-last-activity">Last Activity <i class="fa-solid fa-sort"></i></th>
               </tr>
           </thead>
           <tbody>
           </tbody>
       </table>

       <script id="user-table-column-info" type="text/x-handlebars-template">
           <td data-text="{{row.last_name}}">
               <strong>
                   <a href="{{site.uri.public}}/users/u/{{row.user_name}}">{{row.first_name}} {{row.last_name}} ({{row.user_name}})</a>
               </strong>
               <div>
                   <i class="fa-solid fa-envelope"></i> <a href="mailto:{{row.email}}">{{row.email}}</a>
               </div>
           </td>
       </script>

       <script id="user-table-column-last-activity" type="text/x-handlebars-template">
           {{#if row.last_activity_at }}
           <td data-num="{{dateFormat row.last_activity_at format='x'}}">
               {{dateFormat row.last_activity_at format="dddd"}}<br>{{dateFormat row.last_activity_at format="MMM Do, YYYY h:mm a"}}
               <br>
               <i>{{row.last_activity.description}}</i>
           </td>
           {{ else }}
           <td data-num="0">
                   <i>Unknown</i>
           </td>
           {{/if }}
       </script>

       <div class="pager pager-lg tablesorter-pager js-uf-table-pager">
           <span class="pager-control first" title="First page"><i class="fa-solid fa-angle-double-left"></i></span>
           <span class="pager-control prev" title="Previous page"><i class="fa-solid fa-angle-left"></i></span>
           <span class="pagedisplay"></span>
           <span class="pager-control next" title="Next page"><i class="fa-solid fa-angle-right"></i></span>
           <span class="pager-control last" title= "Last page"><i class="fa-solid fa-angle-double-right"></i></span>
           <br><br>
           Jump to Page: <select class="gotoPage"></select> &bull; Show:
           <select class="pagesize">
               <option value="5">5</option>
               <option value="10">10</option>
           </select>
       </div>

       <button class="btn btn-sm btn-default js-uf-table-download">Download CSV</button>
   </div>
 *
 * Initialize ufTable on your container object:
 *
 * $("#widget-users").ufTable(options);
 *
 * `options` is an object containing any of the following parameters:
 * @param {string} dataUrl The absolute URL from which to fetch table data.
 * @param {mixed} addParams An object containing any additional key-value pairs that you want appended to the AJAX requests.
 * @param {mixed} tablesorter An object containing tablesorter's configuration options (https://mottie.github.io/tablesorter/docs/#Configuration)
 * @param {mixed} pager An object containing tablesorter's paging options (https://mottie.github.io/tablesorter/docs/#pager)
 *
 * == EVENTS ==
 *
 * ufTable triggers the following events:
 *
 * `pagerComplete.ufTable`: triggered when the tablesorter pager plugin has completed rendering of the table.
 *
 * == METHODS ==
 *
 * `getTableStateVars( table )`: fetches the current page size, page number, sort order, sort field, and column filters.
 * `refresh`: reload the table data
 *
 * UserFrosting https://www.userfrosting.com
 * @author Alexander Weissman <https://alexanderweissman.com>
 */
;(function($, window, document, undefined) {
    'use strict';

    // Define plugin name and defaults.
    var pluginName = 'ufTable',
        defaults = {
            DEBUG                : false,
            site                 : site, // global site variables
            dataUrl              : '',
            msgTarget            : $('#alerts-page'),
            addParams            : {},
            filterAllField       : '_all',
            useLoadingTransition : true,
            rowTemplate          : null,
            columnTemplates      : {},
            tablesorter     : {
                debug: false,
                theme     : 'bootstrap',
                widthFixed: true,
                // Set up pagination of data via an AJAX source
                // See http://jsfiddle.net/Mottie/uwZc2/
                // Also see https://mottie.github.io/tablesorter/docs/example-pager-ajax.html
                widgets: ['saveSort', 'sort2Hash', 'filter', 'pager', 'columnSelector', 'reflow2'],
                widgetOptions : {
                    columnSelector_layout : '<label><input type="checkbox"> <span>{name}</span></label>',
                    filter_cssFilter: 'form-control',
                    filter_saveFilters : true,
                    filter_serversideFiltering : true,
                    filter_selectSource : {
                        '.filter-select' : function() { return null; }
                    },

                    // apply disabled class name to the pager arrows when the rows at either extreme is visible
                    pager_updateArrows: true,

                    // starting page of the pager (zero based index)
                    pager_startPage: 0,

                    // Number of visible rows
                    pager_size: 10,

                    // Save pager page & size if the storage script is loaded (requires $.tablesorter.storage in jquery.tablesorter.widgets.js)
                    pager_savePages: true,

                    // if true, the table will remain the same height no matter how many records are displayed. The space is made up by an empty
                    // table row set to a height to compensate; default is false
                    pager_fixedHeight: false,

                    // remove rows from the table to speed up the sort of large tables.
                    // setting this to false, only hides the non-visible rows; needed if you plan to add/remove rows with the pager enabled.
                    pager_removeRows: false, // removing rows in larger tables speeds up the sort

                    // target the pager markup - see the HTML block below
                    pager_css: {
                        errorRow    : 'uf-table-error-row', // error information row
                        disabled    : 'disabled' // Note there is no period "." in front of this class name
                    },

                    // Must be initialized with a 'data' key
                    pager_ajaxObject: {
                        data: {},
                        dataType: 'json'
                    },

                    // hash prefix
                    sort2Hash_hash              : '#',
                    // don't '#' or '=' here
                    sort2Hash_separator         : '|',
                    // this option > table ID > table index on page
                    sort2Hash_tableId           : null,
                    // if true, show header cell text instead of a zero-based column index
                    sort2Hash_headerTextAttr    : 'data-column-name',
                    // direction text shown in the URL e.g. [ 'asc', 'desc' ]
                    sort2Hash_directionText     : [ 'asc', 'desc' ], // default values
                    // if true, override saveSort widget sort, if used & stored sort is available
                    sort2Hash_overrideSaveSort  : true, // default = false
                }
            }
        };

    // Constructor
    function Plugin (element, options) {
        this.element = element[0];
        this.$element = $(this.element);

        var lateDefaults = {
            download: {
                button: this.$element.find('.js-uf-table-download'),
                callback: $.proxy(this._onDownload, this)
            },
            info: {
                container: this.$element.find('.js-uf-table-info'),
                callback: $.proxy(this._renderInfoMessages, this)
            },
            overlay: {
                container: this.$element.find('.js-uf-table-overlay')
            },
            tableElement: this.$element.find('.tablesorter'),
            tablesorter: {
                widgetOptions: {
                    columnSelector_container : this.$element.find('.js-uf-table-cs-options'),
                    filter_external          : this.$element.find('.js-uf-table-search input'),

                    // Pager selectors
                    pager_selectors: {
                        container   : this.$element.find('.js-uf-table-pager'),
                        first       : '.first',       // go to first page arrow
                        prev        : '.prev',        // previous page arrow
                        next        : '.next',        // next page arrow
                        last        : '.last',        // go to last page arrow
                        gotoPage    : '.gotoPage',    // go to page selector - select dropdown that sets the current page
                        pageDisplay : '.pagedisplay', // location of where the "output" is displayed
                        pageSize    : '.pagesize'     // page size selector - select dropdown that sets the "size" option
                    },
                    // We need to use $.proxy to properly bind the context for callbacks that will be called by Tablesorter

                    // Generate the URL for the AJAX request, with the relevant parameters
                    pager_customAjaxUrl: $.proxy(this._generateUrl, this),

                    // Callback to process the response from the AJAX request
                    pager_ajaxProcessing: $.proxy(this._processAjax, this),

                    // Callback to display errors
                    pager_ajaxError: $.proxy(this._pagerAjaxError, this),

                    sort2Hash_encodeHash: $.proxy(this._encodeHash, this),

                    sort2Hash_decodeHash: $.proxy(this._decodeHash, this),

                    sort2Hash_cleanHash: $.proxy(this._cleanHash, this)
                }
            }
        };
        this.settings = $.extend(true, {}, defaults, lateDefaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this._debugAjax = (typeof this.settings.site !== 'undefined') && this.settings.site.debug.ajax;

        // Fall back to attributes from data-*, default values if not specified in options
        var pagerContainer = this.settings.tablesorter.widgetOptions.pager_selectors.container;
        var infoContainer = this.settings.info.container;
        var dataAttributeDefaults = {
            info: {
                messageEmptyRows: infoContainer.data('message-empty-rows') ?
                                  infoContainer.data('message-empty-rows') :
                                  "Sorry, we've got nothing here."
            },
            tablesorter: {
                widgetOptions: {
                    // possible variables: {size}, {page}, {totalPages}, {filteredPages}, {startRow}, {endRow}, {filteredRows} and {totalRows}
                    // also {page:input} & {startRow:input} will add a modifiable input in place of the value
                    pager_output: pagerContainer.data('output-template') ?
                                  pagerContainer.data('output-template') :
                                  '{startRow} to {endRow} of {filteredRows} ({totalRows})' // default if not set on data-* attribute
                }
            }
        };

        this.settings = $.extend(true, {}, dataAttributeDefaults, this.settings);

        // Check that tableElement exists
        var tableElement = this.settings.tableElement;
        if (!tableElement.length) {
            if (window.console && console.error) {
                console.error('ufTable could not be initialized: wrapper element does not exist, or does not contain a matched tableElement (see https://learn.userfrosting.com/client-side-code/components/tables )');
            }
            return;
        }

        // Copy over dataUrl to pager_ajaxUrl
        this.settings.tablesorter.widgetOptions.pager_ajaxUrl = this.settings.dataUrl;

        // Set up 'loading' overlays
        if (this.settings.useLoadingTransition) {
            var overlay = this.settings.overlay.container;
            tableElement.bind('sortStart filterStart pageMoved', function() {
                overlay.removeClass('hidden');
            }).bind('pagerComplete updateComplete', function() {
                overlay.addClass('hidden');
            });
        }

        // Set up tablesorter and pager
        this.ts = tableElement.tablesorter(this.settings.tablesorter);

        // Map default column template selectors based on data-column-template attribute in each column header
        var columns = this.ts[0].config.$headerIndexed;
        var columnTemplates = {};
        for (var col = 0; col < columns.length; col++) {
            var columnName = columns[col].data('column-name');
            if (!columnName && this.settings.DEBUG) {
                console.error('Column number ' + col + ' is missing a data-column-name attribute.');
            }
            columnTemplates[columnName] = columns[col].data('column-template');
        }

        // Merge in any column template selectors that were set in the ctor options
        columnTemplates = $.extend(true, columnTemplates, this.settings.columnTemplates);

        // Locate and compile templates for any string-identified column renderers
        // At the same time, build out a numerically indexed array of templates
        this.columnTemplatesIndexed = [];
        for (var col = 0; col < columns.length; col++) {
            var columnName = columns[col].data('column-name');
            if (!columnTemplates[columnName] && this.settings.DEBUG) {
                console.error("No template found for column '" + columnName + "'.");
            }
            var columnTemplate = columnTemplates[columnName];
            if (typeof columnTemplate === 'string') {
                this.columnTemplatesIndexed.push(Handlebars.compile($(columnTemplate).html()));
            } else {
                this.columnTemplatesIndexed.push(columnTemplate);
            }
        }

        // Locate and compile row template
        this.rowTemplate = Handlebars.compile('<tr>');
        // If rowTemplateSelector is set, then find the DOM element that it references, which contains the template
        if (this.settings.rowTemplate) {
            var rowTemplate = this.settings.rowTemplate;
            if (typeof rowTemplate === 'string') {
                this.rowTemplate = Handlebars.compile($(this.settings.rowTemplate).html());
            } else {
                this.rowTemplate = rowTemplate;
            }
        }

        // Link CSV download button
        this.settings.download.button.on('click', this.settings.download.callback);

        // Allow clicking on the labels in the table menu without closing the menu
        $(this.settings.tablesorter.widgetOptions.columnSelector_container).find('label').on('click', function(e) {
            e.stopPropagation();
        });

        // Propagate our own pagerComplete event
        this.ts.on('pagerComplete', $.proxy(function () {
            this.$element.trigger('pagerComplete.ufTable');
        }, this));

        // Show info messages when there are no rows/no results
        this.ts.on('filterEnd filterReset pagerComplete', this.settings.info.callback);

        // Detect changes to element attributes
        this.$element.attrchange({
            callback: function (event) {
                this.element = event.target;
            }.bind(this)
        });

        return this;
    }

    /**
     * Get state variables for this table, as required by the AJAX data source: sorts, filters, size, page
     */
    Plugin.prototype.getTableStateVars = function(table) {
        var base = this;

        // Get sort column and order
        var sortOrders = {
            '0': 'asc',
            '1': 'desc'
        };

        // Set sorts in URL.  Assumes each th has a data-column-name attribute that corresponds to the name in the API
        var sortList = table.config.sortList;
        var sorts = {};
        for (var i = 0; i < sortList.length; i++) {
            var columnIndex = sortList[i][0];
            var columnDirection = sortOrders[sortList[i][1]];   // Converts to 'asc' or 'desc'
            if (sortList[i]) {
                var columnName = table.config.$headerIndexed[columnIndex].data('column-name');
                sorts[columnName] = columnDirection;
            }
        }

        // Set filters in URL.  Assumes each th has a data-column-name attribute that corresponds to the name in the API
        var filterList = base.getSavedFilters(table);
        var filters = {};
        for (i = 0; i < filterList.length; i++) {
            if (filterList[i]) {
                var columnName = base.settings.filterAllField;

                if (table.config.$headerIndexed[i]) {
                    columnName = table.config.$headerIndexed[i].data('column-name');
                }

                filters[columnName] = filterList[i];
            }
        }

        var state = {
            size: table.config.pager.size,
            page: table.config.pager.page,
            sorts: sorts,
            filters: filters
        };

        return state;
    };

    /**
     * Get saved filters from the browser local storage. Those should always be up to date
     */
    Plugin.prototype.getSavedFilters = function(table) {

        // Fallback to `getFilters` or empty in case of failure
        var filterList = $.tablesorter.getFilters(table) || [];

        // Overwrite list with saved filter for filter-select not setup by ts
        var isArray, saved,
            wo = table.config.widgetOptions;
        if ( wo.filter_saveFilters && $.tablesorter.storage ) {
            saved = $.tablesorter.storage( table, 'tablesorter-filters' ) || [];
            isArray = $.isArray( saved );
            // make sure we're not just getting an empty array
            if ( !( isArray && saved.join( '' ) === '' || !isArray ) ) {
                filterList = $.tablesorter.filter.processFilters( saved );
            }
        }

        return filterList;
    };

    /**
     * Refresh the table
     */
    Plugin.prototype.refresh = function() {
        this.ts.trigger('pagerUpdate');
    };

    /**
     * Generate the AJAX url.
     * Used as the default callback for pager_customAjaxUrl
     * @private
     */
    Plugin.prototype._generateUrl = function(table, url) {
        var tableState = this.getTableStateVars(table);

        if (this.settings.DEBUG) {
            console.log(tableState);
        }

        $.extend(table.config.pager.ajaxObject.data, tableState);

        // Merge in any additional parameters
        $.extend(true, table.config.pager.ajaxObject.data, this.settings.addParams);

        return url;
    };

    /**
     * Process data returned from the AJAX request and rendering the table cells.
     * Used as the default callback for pager_ajaxProcessing
     * @private
     */
    Plugin.prototype._processAjax = function(data) {
        var ts = this.ts[0];
        var json = {},
            rows = '';

        if (data) {
            var size = data.rows.length;

            // Render table rows and cells via Handlebars
            for (var row = 0; row < size; row++) {
                var cellData = {
                    rownum: row,
                    row   : data.rows[row],       // It is safe to use the data from the API because Handlebars escapes HTML
                    site  : this.settings.site
                };

                rows += this.rowTemplate(cellData);

                for (var col = 0; col < this.columnTemplatesIndexed.length; col++) {
                    rows += this.columnTemplatesIndexed[col](cellData);
                }

                rows += '</tr>';
            }

            // Initialize any dropdown filters
            var columns = ts.config.$headerIndexed;
            this._ajaxInitFilterSelects(columns, data.listable);

            json.total = data.count;  // Get total rows without pagination
            json.filteredRows = data.count_filtered; // no filtering
            json.rows = $(rows);
            json.output = data.output;
        } else {
            json.total = 0;
            json.filteredRows = 0;
            json.rows = '';
        }

        return json;
    };

    /**
     * Initialize filter select menus using the ajax `listable` values
     * @private
     */
    Plugin.prototype._ajaxInitFilterSelects = function(columns, listable) {
        var ts = this.ts[0];
        var filters = this.getSavedFilters(ts);
        // Find columns with `.filter-select` and match them to column numbers based on their data-column-name
        for (var col = 0; col < columns.length; col++) {
            var column = columns[col];
            // If the column is designated for filter-select, get the listables from the data and recreate it
            if (column.hasClass('filter-select')) {
                var columnName = column.data('column-name');
                if (listable[columnName]) {
                    $.tablesorter.filter.buildSelect(ts, col, listable[columnName], true);
                    // If there is a filter actually set for this column, update the selected option.
                    if (filters[col]) {
                        var selectControl = $(ts).find(".tablesorter-filter[data-column='" + col + "']");
                        selectControl.val(filters[col]);
                    }
                }
            }
        }
    };

    /**
     * Implements handler for the "download CSV" button.
     * Default callback for download.callback
     * @private
     */
    Plugin.prototype._onDownload = function () {
        var tableState = this.getTableStateVars(this.ts[0]);
        tableState.format = 'csv';
        delete tableState.page;
        delete tableState.size;

        // Merge in any additional request parameters
        $.extend(true, tableState, this.settings.addParams);

        // Causes download to begin
        window.location = this.settings.dataUrl + '?' + $.param(tableState);
    };

    /**
     * Handle pager ajax errors.
     * @private
     */
    Plugin.prototype._pagerAjaxError = function(c, jqXHR, settings, exception) {
        this._ajaxError(jqXHR);

        // Let TS handle the in-table error message
        return '';
    };

    /**
     * Handle ajax error
     * @private
     */
    Plugin.prototype._ajaxError = function(jqXHR) {
        if (typeof jqXHR === 'object') {
            // Error messages
            if (this._debugAjax && jqXHR.responseText) {
                document.write(jqXHR.responseText);
                document.close();
            } else {
                if (this.settings.DEBUG) {
                    console.log('Error (' + jqXHR.status + '): ' + jqXHR.responseText );
                }
                // Display errors on failure
                // TODO: ufAlerts widget should have a 'destroy' method
                if (!this.settings.msgTarget.data('ufAlerts')) {
                    this.settings.msgTarget.ufAlerts();
                } else {
                    this.settings.msgTarget.ufAlerts('clear');
                }

                this.settings.msgTarget.ufAlerts('fetch').ufAlerts('render');
            }
        }
    };

    /**
     * Render info messages, such as when there are no results.
     * Default callback for info.callback
     * @private
     */
    Plugin.prototype._renderInfoMessages = function () {
        var table = this.ts[0];
        var infoMessages = this.settings.info.container;
        if (table.config.pager) {
            infoMessages.html('');
            var fr = table.config.pager.filteredRows;
            if (fr === 0) {
                infoMessages.html(this.settings.info.messageEmptyRows);
            }
        }
    };

    /**
     * Encode the current table state variables into a URL hash.
     * Default callback for sort2Hash_encodeHash
     * @private
     */
    Plugin.prototype._encodeHash = function(config, tableId, component, value, rawValue) {
        var wo = config.widgetOptions;
        if ( component === 'filter' ) {
            // rawValue is an array of filter values, numerically indexed
            var encodedFilters = '';
            var len = rawValue.length;
            for (var index = 0; index < len; index++) {
                if (rawValue[index]) {
                    var columnName = this.settings.filterAllField;
                    if (config.$headerIndexed[index]) {
                        columnName = $(config.$headerIndexed[index][0]).attr(wo.sort2Hash_headerTextAttr);
                    }
                    encodedFilters += '&filter[' + tableId + '][' + columnName + ']=' + encodeURIComponent(rawValue[index]);
                }
            }
            return encodedFilters;
        } else if ( component === 'sort' ) {
            // rawValue is an array of sort pairs [columnNum, sortDirection]
            var encodedFilters = '';
            var len = rawValue.length;
            for (var index = 0; index < len; index++) {
                var columnNum = rawValue[index][0];
                var sortDirection = rawValue[index][1];
                var columnName = $(config.$headerIndexed[columnNum][0]).attr(wo.sort2Hash_headerTextAttr);
                encodedFilters += '&sort[' + tableId + '][' + columnName + ']=' + wo.sort2Hash_directionText[sortDirection];
            }
            return encodedFilters;
        }
        return false;
    };

    /**
     * Decode the current table state variables from the URL hash.
     * Default callback for sort2Hash_decodeHash
     * @private
     */
    Plugin.prototype._decodeHash = function(config, tableId, component) {
        var wo = config.widgetOptions;
        var result;
        // Convert hash into JSON object
        var urlObject = $.String.deparam(window.location.hash);
        delete urlObject[wo.sort2Hash_hash];  // Remove hash character
        if (component === 'filter') {
            var decodedFilters = [];
            // Extract filter names and values for the specified table
            var pageFilters = urlObject.filter ? urlObject.filter : [];
            if (pageFilters[tableId]) {
                var tableFilters = pageFilters[tableId];
                // Build a numerically indexed array of filter values
                var len = config.$headerIndexed.length;
                for (var index = 0; index < len; index++) {
                    var columnName = $(config.$headerIndexed[index][0]).attr(wo.sort2Hash_headerTextAttr);
                    if (tableFilters[columnName] && tableFilters[columnName] != this.settings.filterAllField) {
                        decodedFilters.push(tableFilters[columnName]);
                    } else {
                        decodedFilters.push('');
                    }
                }
                // Convert array of filter values to a delimited string
                result = decodedFilters.join(wo.sort2Hash_separator);
                // make sure to use decodeURIComponent on the result
                return decodeURIComponent(result);
            } else {
                return '';
            }
        }
        return false;
    };

    /**
     * Clean up URL hash.
     * Default callback for sort2Hash_cleanHash
     * @private
     */
    Plugin.prototype._cleanHash = function(config, tableId, component, hash) {
        var wo = config.widgetOptions;
        // Convert hash to JSON object
        var urlObject = $.String.deparam(hash);
        delete urlObject[wo.sort2Hash_hash];  // Remove hash character
        // Remove specified component for specified table
        if (urlObject[component]) {
            if (urlObject[component][tableId]) {
                delete urlObject[component][tableId];
            }
            // Delete entire component if no other tables remaining
            if (jQuery.isEmptyObject(urlObject[component])) {
                delete urlObject[component];
            }
        }
        // Convert modified JSON object back into serialized representation
        var result = decodeURIComponent(jQuery.param(urlObject));
        return result.length ? result : '';
    };

    // Handles instantiation and access to non-private methods.
    $.fn[pluginName] = function(methodOrOptions) {
        // Grab plugin instance
        var instance = $(this).data(pluginName);
        // If undefined or object, initialize plugin.
        if (methodOrOptions === undefined || typeof methodOrOptions === 'object') {
            // Only initialize if not previously done.
            if (!instance) {
                $(this).data(pluginName, new Plugin(this, methodOrOptions));
            }
            return this;
        // Otherwise ensure first parameter is a valid string, and is the name of an actual function.
        } else if (typeof methodOrOptions === 'string' && typeof instance[methodOrOptions] === 'function') {
            // Ensure not a private function
            if (methodOrOptions.indexOf('_') !== 0) {
                return instance[methodOrOptions]( Array.prototype.slice.call(arguments, 1));
            }
            else {
                console.warn( 'Method ' +  methodOrOptions + ' is private!' );
            }
        } else {
            console.warn( 'Method ' +  methodOrOptions + ' does not exist.' );
        }
    };
})(jQuery, window, document);


/***/ }),

/***/ "./node_modules/@userfrosting/sprinkle-admin/app/assets/font-starcraft/css/font-starcraft.css":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@userfrosting/sprinkle-admin/app/assets/font-starcraft/css/font-starcraft.css ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/css/tablesorter-custom.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@userfrosting/sprinkle-admin/app/assets/userfrosting/css/tablesorter-custom.css ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/css/tablesorter-reflow.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@userfrosting/theme-adminlte/app/assets/userfrosting/css/tablesorter-reflow.css ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/tablesorter/dist/css/jquery.tablesorter.pager.min.css":
/*!****************************************************************************!*\
  !*** ./node_modules/tablesorter/dist/css/jquery.tablesorter.pager.min.css ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/tablesorter/dist/css/theme.bootstrap.min.css":
/*!*******************************************************************!*\
  !*** ./node_modules/tablesorter/dist/css/theme.bootstrap.min.css ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tablesorter (FORK) - updated 2020-03-03 (v2.31.3)*/
/* Includes widgets ( storage,uitheme,columns,filter,stickyHeaders,resizable,saveSort ) */
(function(factory){if (true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));} else {}}(function(jQuery) {
/*! TableSorter (FORK) v2.31.3 *//*
* Client-side table sorting with ease!
* @requires jQuery v1.2.6+
*
* Copyright (c) 2007 Christian Bach
* fork maintained by Rob Garrison
*
* Examples and original docs at: http://tablesorter.com
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
* @type jQuery
* @name tablesorter (FORK)
* @cat Plugins/Tablesorter
* @author Christian Bach - christian.bach@polyester.se
* @contributor Rob Garrison - https://github.com/Mottie/tablesorter
* @docs (fork) - https://mottie.github.io/tablesorter/docs/
*/
/*jshint browser:true, jquery:true, unused:false, expr: true */
;( function( $ ) {
	'use strict';
	var ts = $.tablesorter = {

		version : '2.31.3',

		parsers : [],
		widgets : [],
		defaults : {

			// *** appearance
			theme            : 'default',  // adds tablesorter-{theme} to the table for styling
			widthFixed       : false,      // adds colgroup to fix widths of columns
			showProcessing   : false,      // show an indeterminate timer icon in the header when the table is sorted or filtered.

			headerTemplate   : '{content}',// header layout template (HTML ok); {content} = innerHTML, {icon} = <i/> // class from cssIcon
			onRenderTemplate : null,       // function( index, template ) { return template; }, // template is a string
			onRenderHeader   : null,       // function( index ) {}, // nothing to return

			// *** functionality
			cancelSelection  : true,       // prevent text selection in the header
			tabIndex         : true,       // add tabindex to header for keyboard accessibility
			dateFormat       : 'mmddyyyy', // other options: 'ddmmyyy' or 'yyyymmdd'
			sortMultiSortKey : 'shiftKey', // key used to select additional columns
			sortResetKey     : 'ctrlKey',  // key used to remove sorting on a column
			usNumberFormat   : true,       // false for German '1.234.567,89' or French '1 234 567,89'
			delayInit        : false,      // if false, the parsed table contents will not update until the first sort
			serverSideSorting: false,      // if true, server-side sorting should be performed because client-side sorting will be disabled, but the ui and events will still be used.
			resort           : true,       // default setting to trigger a resort after an 'update', 'addRows', 'updateCell', etc has completed

			// *** sort options
			headers          : {},         // set sorter, string, empty, locked order, sortInitialOrder, filter, etc.
			ignoreCase       : true,       // ignore case while sorting
			sortForce        : null,       // column(s) first sorted; always applied
			sortList         : [],         // Initial sort order; applied initially; updated when manually sorted
			sortAppend       : null,       // column(s) sorted last; always applied
			sortStable       : false,      // when sorting two rows with exactly the same content, the original sort order is maintained

			sortInitialOrder : 'asc',      // sort direction on first click
			sortLocaleCompare: false,      // replace equivalent character (accented characters)
			sortReset        : false,      // third click on the header will reset column to default - unsorted
			sortRestart      : false,      // restart sort to 'sortInitialOrder' when clicking on previously unsorted columns

			emptyTo          : 'bottom',   // sort empty cell to bottom, top, none, zero, emptyMax, emptyMin
			stringTo         : 'max',      // sort strings in numerical column as max, min, top, bottom, zero
			duplicateSpan    : true,       // colspan cells in the tbody will have duplicated content in the cache for each spanned column
			textExtraction   : 'basic',    // text extraction method/function - function( node, table, cellIndex ) {}
			textAttribute    : 'data-text',// data-attribute that contains alternate cell text (used in default textExtraction function)
			textSorter       : null,       // choose overall or specific column sorter function( a, b, direction, table, columnIndex ) [alt: ts.sortText]
			numberSorter     : null,       // choose overall numeric sorter function( a, b, direction, maxColumnValue )

			// *** widget options
			initWidgets      : true,       // apply widgets on tablesorter initialization
			widgetClass      : 'widget-{name}', // table class name template to match to include a widget
			widgets          : [],         // method to add widgets, e.g. widgets: ['zebra']
			widgetOptions    : {
				zebra : [ 'even', 'odd' ]  // zebra widget alternating row class names
			},

			// *** callbacks
			initialized      : null,       // function( table ) {},

			// *** extra css class names
			tableClass       : '',
			cssAsc           : '',
			cssDesc          : '',
			cssNone          : '',
			cssHeader        : '',
			cssHeaderRow     : '',
			cssProcessing    : '', // processing icon applied to header during sort/filter

			cssChildRow      : 'tablesorter-childRow', // class name indiciating that a row is to be attached to its parent
			cssInfoBlock     : 'tablesorter-infoOnly', // don't sort tbody with this class name (only one class name allowed here!)
			cssNoSort        : 'tablesorter-noSort',   // class name added to element inside header; clicking on it won't cause a sort
			cssIgnoreRow     : 'tablesorter-ignoreRow',// header row to ignore; cells within this row will not be added to c.$headers

			cssIcon          : 'tablesorter-icon', // if this class does not exist, the {icon} will not be added from the headerTemplate
			cssIconNone      : '', // class name added to the icon when there is no column sort
			cssIconAsc       : '', // class name added to the icon when the column has an ascending sort
			cssIconDesc      : '', // class name added to the icon when the column has a descending sort
			cssIconDisabled  : '', // class name added to the icon when the column has a disabled sort

			// *** events
			pointerClick     : 'click',
			pointerDown      : 'mousedown',
			pointerUp        : 'mouseup',

			// *** selectors
			selectorHeaders  : '> thead th, > thead td',
			selectorSort     : 'th, td', // jQuery selector of content within selectorHeaders that is clickable to trigger a sort
			selectorRemove   : '.remove-me',

			// *** advanced
			debug            : false,

			// *** Internal variables
			headerList: [],
			empties: {},
			strings: {},
			parsers: [],

			// *** parser options for validator; values must be falsy!
			globalize: 0,
			imgAttr: 0

			// removed: widgetZebra: { css: ['even', 'odd'] }

		},

		// internal css classes - these will ALWAYS be added to
		// the table and MUST only contain one class name - fixes #381
		css : {
			table      : 'tablesorter',
			cssHasChild: 'tablesorter-hasChildRow',
			childRow   : 'tablesorter-childRow',
			colgroup   : 'tablesorter-colgroup',
			header     : 'tablesorter-header',
			headerRow  : 'tablesorter-headerRow',
			headerIn   : 'tablesorter-header-inner',
			icon       : 'tablesorter-icon',
			processing : 'tablesorter-processing',
			sortAsc    : 'tablesorter-headerAsc',
			sortDesc   : 'tablesorter-headerDesc',
			sortNone   : 'tablesorter-headerUnSorted'
		},

		// labels applied to sortable headers for accessibility (aria) support
		language : {
			sortAsc      : 'Ascending sort applied, ',
			sortDesc     : 'Descending sort applied, ',
			sortNone     : 'No sort applied, ',
			sortDisabled : 'sorting is disabled',
			nextAsc      : 'activate to apply an ascending sort',
			nextDesc     : 'activate to apply a descending sort',
			nextNone     : 'activate to remove the sort'
		},

		regex : {
			templateContent : /\{content\}/g,
			templateIcon    : /\{icon\}/g,
			templateName    : /\{name\}/i,
			spaces          : /\s+/g,
			nonWord         : /\W/g,
			formElements    : /(input|select|button|textarea)/i,

			// *** sort functions ***
			// regex used in natural sort
			// chunk/tokenize numbers & letters
			chunk  : /(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
			// replace chunks @ ends
			chunks : /(^\\0|\\0$)/,
			hex    : /^0x[0-9a-f]+$/i,

			// *** formatFloat ***
			comma                : /,/g,
			digitNonUS           : /[\s|\.]/g,
			digitNegativeTest    : /^\s*\([.\d]+\)/,
			digitNegativeReplace : /^\s*\(([.\d]+)\)/,

			// *** isDigit ***
			digitTest    : /^[\-+(]?\d+[)]?$/,
			digitReplace : /[,.'"\s]/g

		},

		// digit sort, text location
		string : {
			max      : 1,
			min      : -1,
			emptymin : 1,
			emptymax : -1,
			zero     : 0,
			none     : 0,
			'null'   : 0,
			top      : true,
			bottom   : false
		},

		keyCodes : {
			enter : 13
		},

		// placeholder date parser data (globalize)
		dates : {},

		// These methods can be applied on table.config instance
		instanceMethods : {},

		/*
		▄█████ ██████ ██████ ██  ██ █████▄
		▀█▄    ██▄▄     ██   ██  ██ ██▄▄██
		   ▀█▄ ██▀▀     ██   ██  ██ ██▀▀▀
		█████▀ ██████   ██   ▀████▀ ██
		*/

		setup : function( table, c ) {
			// if no thead or tbody, or tablesorter is already present, quit
			if ( !table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true ) {
				if ( ts.debug(c, 'core') ) {
					if ( table.hasInitialized ) {
						console.warn( 'Stopping initialization. Tablesorter has already been initialized' );
					} else {
						console.error( 'Stopping initialization! No table, thead or tbody', table );
					}
				}
				return;
			}

			var tmp = '',
				$table = $( table ),
				meta = $.metadata;
			// initialization flag
			table.hasInitialized = false;
			// table is being processed flag
			table.isProcessing = true;
			// make sure to store the config object
			table.config = c;
			// save the settings where they read
			$.data( table, 'tablesorter', c );
			if ( ts.debug(c, 'core') ) {
				console[ console.group ? 'group' : 'log' ]( 'Initializing tablesorter v' + ts.version );
				$.data( table, 'startoveralltimer', new Date() );
			}

			// removing this in version 3 (only supports jQuery 1.7+)
			c.supportsDataObject = ( function( version ) {
				version[ 0 ] = parseInt( version[ 0 ], 10 );
				return ( version[ 0 ] > 1 ) || ( version[ 0 ] === 1 && parseInt( version[ 1 ], 10 ) >= 4 );
			})( $.fn.jquery.split( '.' ) );
			// ensure case insensitivity
			c.emptyTo = c.emptyTo.toLowerCase();
			c.stringTo = c.stringTo.toLowerCase();
			c.last = { sortList : [], clickedIndex : -1 };
			// add table theme class only if there isn't already one there
			if ( !/tablesorter\-/.test( $table.attr( 'class' ) ) ) {
				tmp = ( c.theme !== '' ? ' tablesorter-' + c.theme : '' );
			}

			// give the table a unique id, which will be used in namespace binding
			if ( !c.namespace ) {
				c.namespace = '.tablesorter' + Math.random().toString( 16 ).slice( 2 );
			} else {
				// make sure namespace starts with a period & doesn't have weird characters
				c.namespace = '.' + c.namespace.replace( ts.regex.nonWord, '' );
			}

			c.table = table;
			c.$table = $table
				// add namespace to table to allow bindings on extra elements to target
				// the parent table (e.g. parser-input-select)
				.addClass( ts.css.table + ' ' + c.tableClass + tmp + ' ' + c.namespace.slice(1) )
				.attr( 'role', 'grid' );
			c.$headers = $table.find( c.selectorHeaders );

			c.$table.children().children( 'tr' ).attr( 'role', 'row' );
			c.$tbodies = $table.children( 'tbody:not(.' + c.cssInfoBlock + ')' ).attr({
				'aria-live' : 'polite',
				'aria-relevant' : 'all'
			});
			if ( c.$table.children( 'caption' ).length ) {
				tmp = c.$table.children( 'caption' )[ 0 ];
				if ( !tmp.id ) { tmp.id = c.namespace.slice( 1 ) + 'caption'; }
				c.$table.attr( 'aria-labelledby', tmp.id );
			}
			c.widgetInit = {}; // keep a list of initialized widgets
			// change textExtraction via data-attribute
			c.textExtraction = c.$table.attr( 'data-text-extraction' ) || c.textExtraction || 'basic';
			// build headers
			ts.buildHeaders( c );
			// fixate columns if the users supplies the fixedWidth option
			// do this after theme has been applied
			ts.fixColumnWidth( table );
			// add widgets from class name
			ts.addWidgetFromClass( table );
			// add widget options before parsing (e.g. grouping widget has parser settings)
			ts.applyWidgetOptions( table );
			// try to auto detect column type, and store in tables config
			ts.setupParsers( c );
			// start total row count at zero
			c.totalRows = 0;
			// only validate options while debugging. See #1528
			if (c.debug) {
				ts.validateOptions( c );
			}
			// build the cache for the tbody cells
			// delayInit will delay building the cache until the user starts a sort
			if ( !c.delayInit ) { ts.buildCache( c ); }
			// bind all header events and methods
			ts.bindEvents( table, c.$headers, true );
			ts.bindMethods( c );
			// get sort list from jQuery data or metadata
			// in jQuery < 1.4, an error occurs when calling $table.data()
			if ( c.supportsDataObject && typeof $table.data().sortlist !== 'undefined' ) {
				c.sortList = $table.data().sortlist;
			} else if ( meta && ( $table.metadata() && $table.metadata().sortlist ) ) {
				c.sortList = $table.metadata().sortlist;
			}
			// apply widget init code
			ts.applyWidget( table, true );
			// if user has supplied a sort list to constructor
			if ( c.sortList.length > 0 ) {
				// save sortList before any sortAppend is added
				c.last.sortList = c.sortList;
				ts.sortOn( c, c.sortList, {}, !c.initWidgets );
			} else {
				ts.setHeadersCss( c );
				if ( c.initWidgets ) {
					// apply widget format
					ts.applyWidget( table, false );
				}
			}

			// show processesing icon
			if ( c.showProcessing ) {
				$table
				.unbind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace )
				.bind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace, function( e ) {
					clearTimeout( c.timerProcessing );
					ts.isProcessing( table );
					if ( e.type === 'sortBegin' ) {
						c.timerProcessing = setTimeout( function() {
							ts.isProcessing( table, true );
						}, 500 );
					}
				});
			}

			// initialized
			table.hasInitialized = true;
			table.isProcessing = false;
			if ( ts.debug(c, 'core') ) {
				console.log( 'Overall initialization time:' + ts.benchmark( $.data( table, 'startoveralltimer' ) ) );
				if ( ts.debug(c, 'core') && console.groupEnd ) { console.groupEnd(); }
			}
			$table.triggerHandler( 'tablesorter-initialized', table );
			if ( typeof c.initialized === 'function' ) {
				c.initialized( table );
			}
		},

		bindMethods : function( c ) {
			var $table = c.$table,
				namespace = c.namespace,
				events = ( 'sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete ' +
					'sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup ' +
					'mouseleave ' ).split( ' ' )
					.join( namespace + ' ' );
			// apply easy methods that trigger bound events
			$table
			.unbind( events.replace( ts.regex.spaces, ' ' ) )
			.bind( 'sortReset' + namespace, function( e, callback ) {
				e.stopPropagation();
				// using this.config to ensure functions are getting a non-cached version of the config
				ts.sortReset( this.config, function( table ) {
					if (table.isApplyingWidgets) {
						// multiple triggers in a row... filterReset, then sortReset - see #1361
						// wait to update widgets
						setTimeout( function() {
							ts.applyWidget( table, '', callback );
						}, 100 );
					} else {
						ts.applyWidget( table, '', callback );
					}
				});
			})
			.bind( 'updateAll' + namespace, function( e, resort, callback ) {
				e.stopPropagation();
				ts.updateAll( this.config, resort, callback );
			})
			.bind( 'update' + namespace + ' updateRows' + namespace, function( e, resort, callback ) {
				e.stopPropagation();
				ts.update( this.config, resort, callback );
			})
			.bind( 'updateHeaders' + namespace, function( e, callback ) {
				e.stopPropagation();
				ts.updateHeaders( this.config, callback );
			})
			.bind( 'updateCell' + namespace, function( e, cell, resort, callback ) {
				e.stopPropagation();
				ts.updateCell( this.config, cell, resort, callback );
			})
			.bind( 'addRows' + namespace, function( e, $row, resort, callback ) {
				e.stopPropagation();
				ts.addRows( this.config, $row, resort, callback );
			})
			.bind( 'updateComplete' + namespace, function() {
				this.isUpdating = false;
			})
			.bind( 'sorton' + namespace, function( e, list, callback, init ) {
				e.stopPropagation();
				ts.sortOn( this.config, list, callback, init );
			})
			.bind( 'appendCache' + namespace, function( e, callback, init ) {
				e.stopPropagation();
				ts.appendCache( this.config, init );
				if ( $.isFunction( callback ) ) {
					callback( this );
				}
			})
			// $tbodies variable is used by the tbody sorting widget
			.bind( 'updateCache' + namespace, function( e, callback, $tbodies ) {
				e.stopPropagation();
				ts.updateCache( this.config, callback, $tbodies );
			})
			.bind( 'applyWidgetId' + namespace, function( e, id ) {
				e.stopPropagation();
				ts.applyWidgetId( this, id );
			})
			.bind( 'applyWidgets' + namespace, function( e, callback ) {
				e.stopPropagation();
				// apply widgets (false = not initializing)
				ts.applyWidget( this, false, callback );
			})
			.bind( 'refreshWidgets' + namespace, function( e, all, dontapply ) {
				e.stopPropagation();
				ts.refreshWidgets( this, all, dontapply );
			})
			.bind( 'removeWidget' + namespace, function( e, name, refreshing ) {
				e.stopPropagation();
				ts.removeWidget( this, name, refreshing );
			})
			.bind( 'destroy' + namespace, function( e, removeClasses, callback ) {
				e.stopPropagation();
				ts.destroy( this, removeClasses, callback );
			})
			.bind( 'resetToLoadState' + namespace, function( e ) {
				e.stopPropagation();
				// remove all widgets
				ts.removeWidget( this, true, false );
				var tmp = $.extend( true, {}, c.originalSettings );
				// restore original settings; this clears out current settings, but does not clear
				// values saved to storage.
				c = $.extend( true, {}, ts.defaults, tmp );
				c.originalSettings = tmp;
				this.hasInitialized = false;
				// setup the entire table again
				ts.setup( this, c );
			});
		},

		bindEvents : function( table, $headers, core ) {
			table = $( table )[ 0 ];
			var tmp,
				c = table.config,
				namespace = c.namespace,
				downTarget = null;
			if ( core !== true ) {
				$headers.addClass( namespace.slice( 1 ) + '_extra_headers' );
				tmp = ts.getClosest( $headers, 'table' );
				if ( tmp.length && tmp[ 0 ].nodeName === 'TABLE' && tmp[ 0 ] !== table ) {
					$( tmp[ 0 ] ).addClass( namespace.slice( 1 ) + '_extra_table' );
				}
			}
			tmp = ( c.pointerDown + ' ' + c.pointerUp + ' ' + c.pointerClick + ' sort keyup ' )
				.replace( ts.regex.spaces, ' ' )
				.split( ' ' )
				.join( namespace + ' ' );
			// apply event handling to headers and/or additional headers (stickyheaders, scroller, etc)
			$headers
			// http://stackoverflow.com/questions/5312849/jquery-find-self;
			.find( c.selectorSort )
			.add( $headers.filter( c.selectorSort ) )
			.unbind( tmp )
			.bind( tmp, function( e, external ) {
				var $cell, cell, temp,
					$target = $( e.target ),
					// wrap event type in spaces, so the match doesn't trigger on inner words
					type = ' ' + e.type + ' ';
				// only recognize left clicks
				if ( ( ( e.which || e.button ) !== 1 && !type.match( ' ' + c.pointerClick + ' | sort | keyup ' ) ) ||
					// allow pressing enter
					( type === ' keyup ' && e.which !== ts.keyCodes.enter ) ||
					// allow triggering a click event (e.which is undefined) & ignore physical clicks
					( type.match( ' ' + c.pointerClick + ' ' ) && typeof e.which !== 'undefined' ) ) {
					return;
				}
				// ignore mouseup if mousedown wasn't on the same target
				if ( type.match( ' ' + c.pointerUp + ' ' ) && downTarget !== e.target && external !== true ) {
					return;
				}
				// set target on mousedown
				if ( type.match( ' ' + c.pointerDown + ' ' ) ) {
					downTarget = e.target;
					// preventDefault needed or jQuery v1.3.2 and older throws an
					// "Uncaught TypeError: handler.apply is not a function" error
					temp = $target.jquery.split( '.' );
					if ( temp[ 0 ] === '1' && temp[ 1 ] < 4 ) { e.preventDefault(); }
					return;
				}
				downTarget = null;
				$cell = ts.getClosest( $( this ), '.' + ts.css.header );
				// prevent sort being triggered on form elements
				if ( ts.regex.formElements.test( e.target.nodeName ) ||
					// nosort class name, or elements within a nosort container
					$target.hasClass( c.cssNoSort ) || $target.parents( '.' + c.cssNoSort ).length > 0 ||
					// disabled cell directly clicked
					$cell.hasClass( 'sorter-false' ) ||
					// elements within a button
					$target.parents( 'button' ).length > 0 ) {
					return !c.cancelSelection;
				}
				if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
					ts.buildCache( c );
				}
				// use column index from data-attribute or index of current row; fixes #1116
				c.last.clickedIndex = $cell.attr( 'data-column' ) || $cell.index();
				cell = c.$headerIndexed[ c.last.clickedIndex ][0];
				if ( cell && !cell.sortDisabled ) {
					ts.initSort( c, cell, e );
				}
			});
			if ( c.cancelSelection ) {
				// cancel selection
				$headers
					.attr( 'unselectable', 'on' )
					.bind( 'selectstart', false )
					.css({
						'user-select' : 'none',
						'MozUserSelect' : 'none' // not needed for jQuery 1.8+
					});
			}
		},

		buildHeaders : function( c ) {
			var $temp, icon, timer, indx;
			c.headerList = [];
			c.headerContent = [];
			c.sortVars = [];
			if ( ts.debug(c, 'core') ) {
				timer = new Date();
			}
			// children tr in tfoot - see issue #196 & #547
			// don't pass table.config to computeColumnIndex here - widgets (math) pass it to "quickly" index tbody cells
			c.columns = ts.computeColumnIndex( c.$table.children( 'thead, tfoot' ).children( 'tr' ) );
			// add icon if cssIcon option exists
			icon = c.cssIcon ?
				'<i class="' + ( c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + ' ' + ts.css.icon ) + '"></i>' :
				'';
			// redefine c.$headers here in case of an updateAll that replaces or adds an entire header cell - see #683
			c.$headers = $( $.map( c.$table.find( c.selectorHeaders ), function( elem, index ) {
				var configHeaders, header, column, template, tmp,
					$elem = $( elem );
				// ignore cell (don't add it to c.$headers) if row has ignoreRow class
				if ( ts.getClosest( $elem, 'tr' ).hasClass( c.cssIgnoreRow ) ) { return; }
				// transfer data-column to element if not th/td - #1459
				if ( !/(th|td)/i.test( elem.nodeName ) ) {
					tmp = ts.getClosest( $elem, 'th, td' );
					$elem.attr( 'data-column', tmp.attr( 'data-column' ) );
				}
				// make sure to get header cell & not column indexed cell
				configHeaders = ts.getColumnData( c.table, c.headers, index, true );
				// save original header content
				c.headerContent[ index ] = $elem.html();
				// if headerTemplate is empty, don't reformat the header cell
				if ( c.headerTemplate !== '' && !$elem.find( '.' + ts.css.headerIn ).length ) {
					// set up header template
					template = c.headerTemplate
						.replace( ts.regex.templateContent, $elem.html() )
						.replace( ts.regex.templateIcon, $elem.find( '.' + ts.css.icon ).length ? '' : icon );
					if ( c.onRenderTemplate ) {
						header = c.onRenderTemplate.apply( $elem, [ index, template ] );
						// only change t if something is returned
						if ( header && typeof header === 'string' ) {
							template = header;
						}
					}
					$elem.html( '<div class="' + ts.css.headerIn + '">' + template + '</div>' ); // faster than wrapInner
				}
				if ( c.onRenderHeader ) {
					c.onRenderHeader.apply( $elem, [ index, c, c.$table ] );
				}
				column = parseInt( $elem.attr( 'data-column' ), 10 );
				elem.column = column;
				tmp = ts.getOrder( ts.getData( $elem, configHeaders, 'sortInitialOrder' ) || c.sortInitialOrder );
				// this may get updated numerous times if there are multiple rows
				c.sortVars[ column ] = {
					count : -1, // set to -1 because clicking on the header automatically adds one
					order : tmp ?
						( c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ] ) : // desc, asc, unsorted
						( c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ] ),  // asc, desc, unsorted
					lockedOrder : false,
					sortedBy : ''
				};
				tmp = ts.getData( $elem, configHeaders, 'lockedOrder' ) || false;
				if ( typeof tmp !== 'undefined' && tmp !== false ) {
					c.sortVars[ column ].lockedOrder = true;
					c.sortVars[ column ].order = ts.getOrder( tmp ) ? [ 1, 1 ] : [ 0, 0 ];
				}
				// add cell to headerList
				c.headerList[ index ] = elem;
				$elem.addClass( ts.css.header + ' ' + c.cssHeader );
				// add to parent in case there are multiple rows
				ts.getClosest( $elem, 'tr' )
					.addClass( ts.css.headerRow + ' ' + c.cssHeaderRow )
					.attr( 'role', 'row' );
				// allow keyboard cursor to focus on element
				if ( c.tabIndex ) {
					$elem.attr( 'tabindex', 0 );
				}
				return elem;
			}) );
			// cache headers per column
			c.$headerIndexed = [];
			for ( indx = 0; indx < c.columns; indx++ ) {
				// colspan in header making a column undefined
				if ( ts.isEmptyObject( c.sortVars[ indx ] ) ) {
					c.sortVars[ indx ] = {};
				}
				// Use c.$headers.parent() in case selectorHeaders doesn't point to the th/td
				$temp = c.$headers.filter( '[data-column="' + indx + '"]' );
				// target sortable column cells, unless there are none, then use non-sortable cells
				// .last() added in jQuery 1.4; use .filter(':last') to maintain compatibility with jQuery v1.2.6
				c.$headerIndexed[ indx ] = $temp.length ?
					$temp.not( '.sorter-false' ).length ?
						$temp.not( '.sorter-false' ).filter( ':last' ) :
						$temp.filter( ':last' ) :
					$();
			}
			c.$table.find( c.selectorHeaders ).attr({
				scope: 'col',
				role : 'columnheader'
			});
			// enable/disable sorting
			ts.updateHeader( c );
			if ( ts.debug(c, 'core') ) {
				console.log( 'Built headers:' + ts.benchmark( timer ) );
				console.log( c.$headers );
			}
		},

		// Use it to add a set of methods to table.config which will be available for all tables.
		// This should be done before table initialization
		addInstanceMethods : function( methods ) {
			$.extend( ts.instanceMethods, methods );
		},

		/*
		█████▄ ▄████▄ █████▄ ▄█████ ██████ █████▄ ▄█████
		██▄▄██ ██▄▄██ ██▄▄██ ▀█▄    ██▄▄   ██▄▄██ ▀█▄
		██▀▀▀  ██▀▀██ ██▀██     ▀█▄ ██▀▀   ██▀██     ▀█▄
		██     ██  ██ ██  ██ █████▀ ██████ ██  ██ █████▀
		*/
		setupParsers : function( c, $tbodies ) {
			var rows, list, span, max, colIndex, indx, header, configHeaders,
				noParser, parser, extractor, time, tbody, len,
				table = c.table,
				tbodyIndex = 0,
				debug = ts.debug(c, 'core'),
				debugOutput = {};
			// update table bodies in case we start with an empty table
			c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
			tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies;
			len = tbody.length;
			if ( len === 0 ) {
				return debug ? console.warn( 'Warning: *Empty table!* Not building a parser cache' ) : '';
			} else if ( debug ) {
				time = new Date();
				console[ console.group ? 'group' : 'log' ]( 'Detecting parsers for each column' );
			}
			list = {
				extractors: [],
				parsers: []
			};
			while ( tbodyIndex < len ) {
				rows = tbody[ tbodyIndex ].rows;
				if ( rows.length ) {
					colIndex = 0;
					max = c.columns;
					for ( indx = 0; indx < max; indx++ ) {
						header = c.$headerIndexed[ colIndex ];
						if ( header && header.length ) {
							// get column indexed table cell; adding true parameter fixes #1362 but
							// it would break backwards compatibility...
							configHeaders = ts.getColumnData( table, c.headers, colIndex ); // , true );
							// get column parser/extractor
							extractor = ts.getParserById( ts.getData( header, configHeaders, 'extractor' ) );
							parser = ts.getParserById( ts.getData( header, configHeaders, 'sorter' ) );
							noParser = ts.getData( header, configHeaders, 'parser' ) === 'false';
							// empty cells behaviour - keeping emptyToBottom for backwards compatibility
							c.empties[colIndex] = (
								ts.getData( header, configHeaders, 'empty' ) ||
								c.emptyTo || ( c.emptyToBottom ? 'bottom' : 'top' ) ).toLowerCase();
							// text strings behaviour in numerical sorts
							c.strings[colIndex] = (
								ts.getData( header, configHeaders, 'string' ) ||
								c.stringTo ||
								'max' ).toLowerCase();
							if ( noParser ) {
								parser = ts.getParserById( 'no-parser' );
							}
							if ( !extractor ) {
								// For now, maybe detect someday
								extractor = false;
							}
							if ( !parser ) {
								parser = ts.detectParserForColumn( c, rows, -1, colIndex );
							}
							if ( debug ) {
								debugOutput[ '(' + colIndex + ') ' + header.text() ] = {
									parser : parser.id,
									extractor : extractor ? extractor.id : 'none',
									string : c.strings[ colIndex ],
									empty  : c.empties[ colIndex ]
								};
							}
							list.parsers[ colIndex ] = parser;
							list.extractors[ colIndex ] = extractor;
							span = header[ 0 ].colSpan - 1;
							if ( span > 0 ) {
								colIndex += span;
								max += span;
								while ( span + 1 > 0 ) {
									// set colspan columns to use the same parsers & extractors
									list.parsers[ colIndex - span ] = parser;
									list.extractors[ colIndex - span ] = extractor;
									span--;
								}
							}
						}
						colIndex++;
					}
				}
				tbodyIndex += ( list.parsers.length ) ? len : 1;
			}
			if ( debug ) {
				if ( !ts.isEmptyObject( debugOutput ) ) {
					console[ console.table ? 'table' : 'log' ]( debugOutput );
				} else {
					console.warn( '  No parsers detected!' );
				}
				console.log( 'Completed detecting parsers' + ts.benchmark( time ) );
				if ( console.groupEnd ) { console.groupEnd(); }
			}
			c.parsers = list.parsers;
			c.extractors = list.extractors;
		},

		addParser : function( parser ) {
			var indx,
				len = ts.parsers.length,
				add = true;
			for ( indx = 0; indx < len; indx++ ) {
				if ( ts.parsers[ indx ].id.toLowerCase() === parser.id.toLowerCase() ) {
					add = false;
				}
			}
			if ( add ) {
				ts.parsers[ ts.parsers.length ] = parser;
			}
		},

		getParserById : function( name ) {
			/*jshint eqeqeq:false */ // eslint-disable-next-line eqeqeq
			if ( name == 'false' ) { return false; }
			var indx,
				len = ts.parsers.length;
			for ( indx = 0; indx < len; indx++ ) {
				if ( ts.parsers[ indx ].id.toLowerCase() === ( name.toString() ).toLowerCase() ) {
					return ts.parsers[ indx ];
				}
			}
			return false;
		},

		detectParserForColumn : function( c, rows, rowIndex, cellIndex ) {
			var cur, $node, row,
				indx = ts.parsers.length,
				node = false,
				nodeValue = '',
				debug = ts.debug(c, 'core'),
				keepLooking = true;
			while ( nodeValue === '' && keepLooking ) {
				rowIndex++;
				row = rows[ rowIndex ];
				// stop looking after 50 empty rows
				if ( row && rowIndex < 50 ) {
					if ( row.className.indexOf( ts.cssIgnoreRow ) < 0 ) {
						node = rows[ rowIndex ].cells[ cellIndex ];
						nodeValue = ts.getElementText( c, node, cellIndex );
						$node = $( node );
						if ( debug ) {
							console.log( 'Checking if value was empty on row ' + rowIndex + ', column: ' +
								cellIndex + ': "' + nodeValue + '"' );
						}
					}
				} else {
					keepLooking = false;
				}
			}
			while ( --indx >= 0 ) {
				cur = ts.parsers[ indx ];
				// ignore the default text parser because it will always be true
				if ( cur && cur.id !== 'text' && cur.is && cur.is( nodeValue, c.table, node, $node ) ) {
					return cur;
				}
			}
			// nothing found, return the generic parser (text)
			return ts.getParserById( 'text' );
		},

		getElementText : function( c, node, cellIndex ) {
			if ( !node ) { return ''; }
			var tmp,
				extract = c.textExtraction || '',
				// node could be a jquery object
				// http://jsperf.com/jquery-vs-instanceof-jquery/2
				$node = node.jquery ? node : $( node );
			if ( typeof extract === 'string' ) {
				// check data-attribute first when set to 'basic'; don't use node.innerText - it's really slow!
				// http://www.kellegous.com/j/2013/02/27/innertext-vs-textcontent/
				if ( extract === 'basic' && typeof ( tmp = $node.attr( c.textAttribute ) ) !== 'undefined' ) {
					return $.trim( tmp );
				}
				return $.trim( node.textContent || $node.text() );
			} else {
				if ( typeof extract === 'function' ) {
					return $.trim( extract( $node[ 0 ], c.table, cellIndex ) );
				} else if ( typeof ( tmp = ts.getColumnData( c.table, extract, cellIndex ) ) === 'function' ) {
					return $.trim( tmp( $node[ 0 ], c.table, cellIndex ) );
				}
			}
			// fallback
			return $.trim( $node[ 0 ].textContent || $node.text() );
		},

		// centralized function to extract/parse cell contents
		getParsedText : function( c, cell, colIndex, txt ) {
			if ( typeof txt === 'undefined' ) {
				txt = ts.getElementText( c, cell, colIndex );
			}
			// if no parser, make sure to return the txt
			var val = '' + txt,
				parser = c.parsers[ colIndex ],
				extractor = c.extractors[ colIndex ];
			if ( parser ) {
				// do extract before parsing, if there is one
				if ( extractor && typeof extractor.format === 'function' ) {
					txt = extractor.format( txt, c.table, cell, colIndex );
				}
				// allow parsing if the string is empty, previously parsing would change it to zero,
				// in case the parser needs to extract data from the table cell attributes
				val = parser.id === 'no-parser' ? '' :
					// make sure txt is a string (extractor may have converted it)
					parser.format( '' + txt, c.table, cell, colIndex );
				if ( c.ignoreCase && typeof val === 'string' ) {
					val = val.toLowerCase();
				}
			}
			return val;
		},

		/*
		▄████▄ ▄████▄ ▄████▄ ██  ██ ██████
		██  ▀▀ ██▄▄██ ██  ▀▀ ██▄▄██ ██▄▄
		██  ▄▄ ██▀▀██ ██  ▄▄ ██▀▀██ ██▀▀
		▀████▀ ██  ██ ▀████▀ ██  ██ ██████
		*/
		buildCache : function( c, callback, $tbodies ) {
			var cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row,
				cols, $cells, cell, cacheTime, totalRows, rowData, prevRowData,
				colMax, span, cacheIndex, hasParser, max, len, index,
				table = c.table,
				parsers = c.parsers,
				debug = ts.debug(c, 'core');
			// update tbody variable
			c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
			$tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies,
			c.cache = {};
			c.totalRows = 0;
			// if no parsers found, return - it's an empty table.
			if ( !parsers ) {
				return debug ? console.warn( 'Warning: *Empty table!* Not building a cache' ) : '';
			}
			if ( debug ) {
				cacheTime = new Date();
			}
			// processing icon
			if ( c.showProcessing ) {
				ts.isProcessing( table, true );
			}
			for ( tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++ ) {
				colMax = []; // column max value per tbody
				cache = c.cache[ tbodyIndex ] = {
					normalized: [] // array of normalized row data; last entry contains 'rowData' above
					// colMax: #   // added at the end
				};

				totalRows = ( $tbody[ tbodyIndex ] && $tbody[ tbodyIndex ].rows.length ) || 0;
				for ( rowIndex = 0; rowIndex < totalRows; ++rowIndex ) {
					rowData = {
						// order: original row order #
						// $row : jQuery Object[]
						child: [], // child row text (filter widget)
						raw: []    // original row text
					};
					/** Add the table data to main data array */
					$row = $( $tbody[ tbodyIndex ].rows[ rowIndex ] );
					cols = [];
					// ignore "remove-me" rows
					if ( $row.hasClass( c.selectorRemove.slice(1) ) ) {
						continue;
					}
					// if this is a child row, add it to the last row's children and continue to the next row
					// ignore child row class, if it is the first row
					if ( $row.hasClass( c.cssChildRow ) && rowIndex !== 0 ) {
						len = cache.normalized.length - 1;
						prevRowData = cache.normalized[ len ][ c.columns ];
						prevRowData.$row = prevRowData.$row.add( $row );
						// add 'hasChild' class name to parent row
						if ( !$row.prev().hasClass( c.cssChildRow ) ) {
							$row.prev().addClass( ts.css.cssHasChild );
						}
						// save child row content (un-parsed!)
						$cells = $row.children( 'th, td' );
						len = prevRowData.child.length;
						prevRowData.child[ len ] = [];
						// child row content does not account for colspans/rowspans; so indexing may be off
						cacheIndex = 0;
						max = c.columns;
						for ( colIndex = 0; colIndex < max; colIndex++ ) {
							cell = $cells[ colIndex ];
							if ( cell ) {
								prevRowData.child[ len ][ colIndex ] = ts.getParsedText( c, cell, colIndex );
								span = $cells[ colIndex ].colSpan - 1;
								if ( span > 0 ) {
									cacheIndex += span;
									max += span;
								}
							}
							cacheIndex++;
						}
						// go to the next for loop
						continue;
					}
					rowData.$row = $row;
					rowData.order = rowIndex; // add original row position to rowCache
					cacheIndex = 0;
					max = c.columns;
					for ( colIndex = 0; colIndex < max; ++colIndex ) {
						cell = $row[ 0 ].cells[ colIndex ];
						if ( cell && cacheIndex < c.columns ) {
							hasParser = typeof parsers[ cacheIndex ] !== 'undefined';
							if ( !hasParser && debug ) {
								console.warn( 'No parser found for row: ' + rowIndex + ', column: ' + colIndex +
									'; cell containing: "' + $(cell).text() + '"; does it have a header?' );
							}
							val = ts.getElementText( c, cell, cacheIndex );
							rowData.raw[ cacheIndex ] = val; // save original row text
							// save raw column text even if there is no parser set
							txt = ts.getParsedText( c, cell, cacheIndex, val );
							cols[ cacheIndex ] = txt;
							if ( hasParser && ( parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
								// determine column max value (ignore sign)
								colMax[ cacheIndex ] = Math.max( Math.abs( txt ) || 0, colMax[ cacheIndex ] || 0 );
							}
							// allow colSpan in tbody
							span = cell.colSpan - 1;
							if ( span > 0 ) {
								index = 0;
								while ( index <= span ) {
									// duplicate text (or not) to spanned columns
									// instead of setting duplicate span to empty string, use textExtraction to try to get a value
									// see http://stackoverflow.com/q/36449711/145346
									txt = c.duplicateSpan || index === 0 ?
										txt :
										typeof c.textExtraction !== 'string' ?
											ts.getElementText( c, cell, cacheIndex + index ) || '' :
											'';
									rowData.raw[ cacheIndex + index ] = txt;
									cols[ cacheIndex + index ] = txt;
									index++;
								}
								cacheIndex += span;
								max += span;
							}
						}
						cacheIndex++;
					}
					// ensure rowData is always in the same location (after the last column)
					cols[ c.columns ] = rowData;
					cache.normalized[ cache.normalized.length ] = cols;
				}
				cache.colMax = colMax;
				// total up rows, not including child rows
				c.totalRows += cache.normalized.length;

			}
			if ( c.showProcessing ) {
				ts.isProcessing( table ); // remove processing icon
			}
			if ( debug ) {
				len = Math.min( 5, c.cache[ 0 ].normalized.length );
				console[ console.group ? 'group' : 'log' ]( 'Building cache for ' + c.totalRows +
					' rows (showing ' + len + ' rows in log) and ' + c.columns + ' columns' +
					ts.benchmark( cacheTime ) );
				val = {};
				for ( colIndex = 0; colIndex < c.columns; colIndex++ ) {
					for ( cacheIndex = 0; cacheIndex < len; cacheIndex++ ) {
						if ( !val[ 'row: ' + cacheIndex ] ) {
							val[ 'row: ' + cacheIndex ] = {};
						}
						val[ 'row: ' + cacheIndex ][ c.$headerIndexed[ colIndex ].text() ] =
							c.cache[ 0 ].normalized[ cacheIndex ][ colIndex ];
					}
				}
				console[ console.table ? 'table' : 'log' ]( val );
				if ( console.groupEnd ) { console.groupEnd(); }
			}
			if ( $.isFunction( callback ) ) {
				callback( table );
			}
		},

		getColumnText : function( table, column, callback, rowFilter ) {
			table = $( table )[0];
			var tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result,
				hasCallback = typeof callback === 'function',
				allColumns = column === 'all',
				data = { raw : [], parsed: [], $cell: [] },
				c = table.config;
			if ( ts.isEmptyObject( c ) ) {
				if ( ts.debug(c, 'core') ) {
					console.warn( 'No cache found - aborting getColumnText function!' );
				}
			} else {
				tbodyLen = c.$tbodies.length;
				for ( tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++ ) {
					cache = c.cache[ tbodyIndex ].normalized;
					rowLen = cache.length;
					for ( rowIndex = 0; rowIndex < rowLen; rowIndex++ ) {
						row = cache[ rowIndex ];
						if ( rowFilter && !row[ c.columns ].$row.is( rowFilter ) ) {
							continue;
						}
						result = true;
						parsed = ( allColumns ) ? row.slice( 0, c.columns ) : row[ column ];
						row = row[ c.columns ];
						raw = ( allColumns ) ? row.raw : row.raw[ column ];
						$cell = ( allColumns ) ? row.$row.children() : row.$row.children().eq( column );
						if ( hasCallback ) {
							result = callback({
								tbodyIndex : tbodyIndex,
								rowIndex : rowIndex,
								parsed : parsed,
								raw : raw,
								$row : row.$row,
								$cell : $cell
							});
						}
						if ( result !== false ) {
							data.parsed[ data.parsed.length ] = parsed;
							data.raw[ data.raw.length ] = raw;
							data.$cell[ data.$cell.length ] = $cell;
						}
					}
				}
				// return everything
				return data;
			}
		},

		/*
		██  ██ █████▄ █████▄ ▄████▄ ██████ ██████
		██  ██ ██▄▄██ ██  ██ ██▄▄██   ██   ██▄▄
		██  ██ ██▀▀▀  ██  ██ ██▀▀██   ██   ██▀▀
		▀████▀ ██     █████▀ ██  ██   ██   ██████
		*/
		setHeadersCss : function( c ) {
			var indx, column,
				list = c.sortList,
				len = list.length,
				none = ts.css.sortNone + ' ' + c.cssNone,
				css = [ ts.css.sortAsc + ' ' + c.cssAsc, ts.css.sortDesc + ' ' + c.cssDesc ],
				cssIcon = [ c.cssIconAsc, c.cssIconDesc, c.cssIconNone ],
				aria = [ 'ascending', 'descending' ],
				updateColumnSort = function($el, index) {
					$el
						.removeClass( none )
						.addClass( css[ index ] )
						.attr( 'aria-sort', aria[ index ] )
						.find( '.' + ts.css.icon )
						.removeClass( cssIcon[ 2 ] )
						.addClass( cssIcon[ index ] );
				},
				// find the footer
				$extras = c.$table
					.find( 'tfoot tr' )
					.children( 'td, th' )
					.add( $( c.namespace + '_extra_headers' ) )
					.removeClass( css.join( ' ' ) ),
				// remove all header information
				$sorted = c.$headers
					.add( $( 'thead ' + c.namespace + '_extra_headers' ) )
					.removeClass( css.join( ' ' ) )
					.addClass( none )
					.attr( 'aria-sort', 'none' )
					.find( '.' + ts.css.icon )
					.removeClass( cssIcon.join( ' ' ) )
					.end();
			// add css none to all sortable headers
			$sorted
				.not( '.sorter-false' )
				.find( '.' + ts.css.icon )
				.addClass( cssIcon[ 2 ] );
			// add disabled css icon class
			if ( c.cssIconDisabled ) {
				$sorted
					.filter( '.sorter-false' )
					.find( '.' + ts.css.icon )
					.addClass( c.cssIconDisabled );
			}
			for ( indx = 0; indx < len; indx++ ) {
				// direction = 2 means reset!
				if ( list[ indx ][ 1 ] !== 2 ) {
					// multicolumn sorting updating - see #1005
					// .not(function() {}) needs jQuery 1.4
					// filter(function(i, el) {}) <- el is undefined in jQuery v1.2.6
					$sorted = c.$headers.filter( function( i ) {
						// only include headers that are in the sortList (this includes colspans)
						var include = true,
							$el = c.$headers.eq( i ),
							col = parseInt( $el.attr( 'data-column' ), 10 ),
							end = col + ts.getClosest( $el, 'th, td' )[0].colSpan;
						for ( ; col < end; col++ ) {
							include = include ? include || ts.isValueInArray( col, c.sortList ) > -1 : false;
						}
						return include;
					});

					// choose the :last in case there are nested columns
					$sorted = $sorted
						.not( '.sorter-false' )
						.filter( '[data-column="' + list[ indx ][ 0 ] + '"]' + ( len === 1 ? ':last' : '' ) );
					if ( $sorted.length ) {
						for ( column = 0; column < $sorted.length; column++ ) {
							if ( !$sorted[ column ].sortDisabled ) {
								updateColumnSort( $sorted.eq( column ), list[ indx ][ 1 ] );
							}
						}
					}
					// add sorted class to footer & extra headers, if they exist
					if ( $extras.length ) {
						updateColumnSort( $extras.filter( '[data-column="' + list[ indx ][ 0 ] + '"]' ), list[ indx ][ 1 ] );
					}
				}
			}
			// add verbose aria labels
			len = c.$headers.length;
			for ( indx = 0; indx < len; indx++ ) {
				ts.setColumnAriaLabel( c, c.$headers.eq( indx ) );
			}
		},

		getClosest : function( $el, selector ) {
			// jQuery v1.2.6 doesn't have closest()
			if ( $.fn.closest ) {
				return $el.closest( selector );
			}
			return $el.is( selector ) ?
				$el :
				$el.parents( selector ).filter( ':first' );
		},

		// nextSort (optional), lets you disable next sort text
		setColumnAriaLabel : function( c, $header, nextSort ) {
			if ( $header.length ) {
				var column = parseInt( $header.attr( 'data-column' ), 10 ),
					vars = c.sortVars[ column ],
					tmp = $header.hasClass( ts.css.sortAsc ) ?
						'sortAsc' :
						$header.hasClass( ts.css.sortDesc ) ? 'sortDesc' : 'sortNone',
					txt = $.trim( $header.text() ) + ': ' + ts.language[ tmp ];
				if ( $header.hasClass( 'sorter-false' ) || nextSort === false ) {
					txt += ts.language.sortDisabled;
				} else {
					tmp = ( vars.count + 1 ) % vars.order.length;
					nextSort = vars.order[ tmp ];
					// if nextSort
					txt += ts.language[ nextSort === 0 ? 'nextAsc' : nextSort === 1 ? 'nextDesc' : 'nextNone' ];
				}
				$header.attr( 'aria-label', txt );
				if (vars.sortedBy) {
					$header.attr( 'data-sortedBy', vars.sortedBy );
				} else {
					$header.removeAttr('data-sortedBy');
				}
			}
		},

		updateHeader : function( c ) {
			var index, isDisabled, $header, col,
				table = c.table,
				len = c.$headers.length;
			for ( index = 0; index < len; index++ ) {
				$header = c.$headers.eq( index );
				col = ts.getColumnData( table, c.headers, index, true );
				// add 'sorter-false' class if 'parser-false' is set
				isDisabled = ts.getData( $header, col, 'sorter' ) === 'false' || ts.getData( $header, col, 'parser' ) === 'false';
				ts.setColumnSort( c, $header, isDisabled );
			}
		},

		setColumnSort : function( c, $header, isDisabled ) {
			var id = c.table.id;
			$header[ 0 ].sortDisabled = isDisabled;
			$header[ isDisabled ? 'addClass' : 'removeClass' ]( 'sorter-false' )
				.attr( 'aria-disabled', '' + isDisabled );
			// disable tab index on disabled cells
			if ( c.tabIndex ) {
				if ( isDisabled ) {
					$header.removeAttr( 'tabindex' );
				} else {
					$header.attr( 'tabindex', '0' );
				}
			}
			// aria-controls - requires table ID
			if ( id ) {
				if ( isDisabled ) {
					$header.removeAttr( 'aria-controls' );
				} else {
					$header.attr( 'aria-controls', id );
				}
			}
		},

		updateHeaderSortCount : function( c, list ) {
			var col, dir, group, indx, primary, temp, val, order,
				sortList = list || c.sortList,
				len = sortList.length;
			c.sortList = [];
			for ( indx = 0; indx < len; indx++ ) {
				val = sortList[ indx ];
				// ensure all sortList values are numeric - fixes #127
				col = parseInt( val[ 0 ], 10 );
				// prevents error if sorton array is wrong
				if ( col < c.columns ) {

					// set order if not already defined - due to colspan header without associated header cell
					// adding this check prevents a javascript error
					if ( !c.sortVars[ col ].order ) {
						if ( ts.getOrder( c.sortInitialOrder ) ) {
							order = c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ];
						} else {
							order = c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ];
						}
						c.sortVars[ col ].order = order;
						c.sortVars[ col ].count = 0;
					}

					order = c.sortVars[ col ].order;
					dir = ( '' + val[ 1 ] ).match( /^(1|d|s|o|n)/ );
					dir = dir ? dir[ 0 ] : '';
					// 0/(a)sc (default), 1/(d)esc, (s)ame, (o)pposite, (n)ext
					switch ( dir ) {
						case '1' : case 'd' : // descending
							dir = 1;
							break;
						case 's' : // same direction (as primary column)
							// if primary sort is set to 's', make it ascending
							dir = primary || 0;
							break;
						case 'o' :
							temp = order[ ( primary || 0 ) % order.length ];
							// opposite of primary column; but resets if primary resets
							dir = temp === 0 ? 1 : temp === 1 ? 0 : 2;
							break;
						case 'n' :
							dir = order[ ( ++c.sortVars[ col ].count ) % order.length ];
							break;
						default : // ascending
							dir = 0;
							break;
					}
					primary = indx === 0 ? dir : primary;
					group = [ col, parseInt( dir, 10 ) || 0 ];
					c.sortList[ c.sortList.length ] = group;
					dir = $.inArray( group[ 1 ], order ); // fixes issue #167
					c.sortVars[ col ].count = dir >= 0 ? dir : group[ 1 ] % order.length;
				}
			}
		},

		updateAll : function( c, resort, callback ) {
			var table = c.table;
			table.isUpdating = true;
			ts.refreshWidgets( table, true, true );
			ts.buildHeaders( c );
			ts.bindEvents( table, c.$headers, true );
			ts.bindMethods( c );
			ts.commonUpdate( c, resort, callback );
		},

		update : function( c, resort, callback ) {
			var table = c.table;
			table.isUpdating = true;
			// update sorting (if enabled/disabled)
			ts.updateHeader( c );
			ts.commonUpdate( c, resort, callback );
		},

		// simple header update - see #989
		updateHeaders : function( c, callback ) {
			c.table.isUpdating = true;
			ts.buildHeaders( c );
			ts.bindEvents( c.table, c.$headers, true );
			ts.resortComplete( c, callback );
		},

		updateCell : function( c, cell, resort, callback ) {
			// updateCell for child rows is a mess - we'll ignore them for now
			// eventually I'll break out the "update" row cache code to make everything consistent
			if ( $( cell ).closest( 'tr' ).hasClass( c.cssChildRow ) ) {
				console.warn('Tablesorter Warning! "updateCell" for child row content has been disabled, use "update" instead');
				return;
			}
			if ( ts.isEmptyObject( c.cache ) ) {
				// empty table, do an update instead - fixes #1099
				ts.updateHeader( c );
				ts.commonUpdate( c, resort, callback );
				return;
			}
			c.table.isUpdating = true;
			c.$table.find( c.selectorRemove ).remove();
			// get position from the dom
			var tmp, indx, row, icell, cache, len,
				$tbodies = c.$tbodies,
				$cell = $( cell ),
				// update cache - format: function( s, table, cell, cellIndex )
				// no closest in jQuery v1.2.6
				tbodyIndex = $tbodies.index( ts.getClosest( $cell, 'tbody' ) ),
				tbcache = c.cache[ tbodyIndex ],
				$row = ts.getClosest( $cell, 'tr' );
			cell = $cell[ 0 ]; // in case cell is a jQuery object
			// tbody may not exist if update is initialized while tbody is removed for processing
			if ( $tbodies.length && tbodyIndex >= 0 ) {
				row = $tbodies.eq( tbodyIndex ).find( 'tr' ).not( '.' + c.cssChildRow ).index( $row );
				cache = tbcache.normalized[ row ];
				len = $row[ 0 ].cells.length;
				if ( len !== c.columns ) {
					// colspan in here somewhere!
					icell = 0;
					tmp = false;
					for ( indx = 0; indx < len; indx++ ) {
						if ( !tmp && $row[ 0 ].cells[ indx ] !== cell ) {
							icell += $row[ 0 ].cells[ indx ].colSpan;
						} else {
							tmp = true;
						}
					}
				} else {
					icell = $cell.index();
				}
				tmp = ts.getElementText( c, cell, icell ); // raw
				cache[ c.columns ].raw[ icell ] = tmp;
				tmp = ts.getParsedText( c, cell, icell, tmp );
				cache[ icell ] = tmp; // parsed
				if ( ( c.parsers[ icell ].type || '' ).toLowerCase() === 'numeric' ) {
					// update column max value (ignore sign)
					tbcache.colMax[ icell ] = Math.max( Math.abs( tmp ) || 0, tbcache.colMax[ icell ] || 0 );
				}
				tmp = resort !== 'undefined' ? resort : c.resort;
				if ( tmp !== false ) {
					// widgets will be reapplied
					ts.checkResort( c, tmp, callback );
				} else {
					// don't reapply widgets is resort is false, just in case it causes
					// problems with element focus
					ts.resortComplete( c, callback );
				}
			} else {
				if ( ts.debug(c, 'core') ) {
					console.error( 'updateCell aborted, tbody missing or not within the indicated table' );
				}
				c.table.isUpdating = false;
			}
		},

		addRows : function( c, $row, resort, callback ) {
			var txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order,
				cacheIndex, rowData, cells, cell, span,
				// allow passing a row string if only one non-info tbody exists in the table
				valid = typeof $row === 'string' && c.$tbodies.length === 1 && /<tr/.test( $row || '' ),
				table = c.table;
			if ( valid ) {
				$row = $( $row );
				c.$tbodies.append( $row );
			} else if (
				!$row ||
				// row is a jQuery object?
				!( $row instanceof $ ) ||
				// row contained in the table?
				( ts.getClosest( $row, 'table' )[ 0 ] !== c.table )
			) {
				if ( ts.debug(c, 'core') ) {
					console.error( 'addRows method requires (1) a jQuery selector reference to rows that have already ' +
						'been added to the table, or (2) row HTML string to be added to a table with only one tbody' );
				}
				return false;
			}
			table.isUpdating = true;
			if ( ts.isEmptyObject( c.cache ) ) {
				// empty table, do an update instead - fixes #450
				ts.updateHeader( c );
				ts.commonUpdate( c, resort, callback );
			} else {
				rows = $row.filter( 'tr' ).attr( 'role', 'row' ).length;
				tbodyIndex = c.$tbodies.index( $row.parents( 'tbody' ).filter( ':first' ) );
				// fixes adding rows to an empty table - see issue #179
				if ( !( c.parsers && c.parsers.length ) ) {
					ts.setupParsers( c );
				}
				// add each row
				for ( rowIndex = 0; rowIndex < rows; rowIndex++ ) {
					cacheIndex = 0;
					len = $row[ rowIndex ].cells.length;
					order = c.cache[ tbodyIndex ].normalized.length;
					cells = [];
					rowData = {
						child : [],
						raw : [],
						$row : $row.eq( rowIndex ),
						order : order
					};
					// add each cell
					for ( cellIndex = 0; cellIndex < len; cellIndex++ ) {
						cell = $row[ rowIndex ].cells[ cellIndex ];
						txt = ts.getElementText( c, cell, cacheIndex );
						rowData.raw[ cacheIndex ] = txt;
						val = ts.getParsedText( c, cell, cacheIndex, txt );
						cells[ cacheIndex ] = val;
						if ( ( c.parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
							// update column max value (ignore sign)
							c.cache[ tbodyIndex ].colMax[ cacheIndex ] =
								Math.max( Math.abs( val ) || 0, c.cache[ tbodyIndex ].colMax[ cacheIndex ] || 0 );
						}
						span = cell.colSpan - 1;
						if ( span > 0 ) {
							cacheIndex += span;
						}
						cacheIndex++;
					}
					// add the row data to the end
					cells[ c.columns ] = rowData;
					// update cache
					c.cache[ tbodyIndex ].normalized[ order ] = cells;
				}
				// resort using current settings
				ts.checkResort( c, resort, callback );
			}
		},

		updateCache : function( c, callback, $tbodies ) {
			// rebuild parsers
			if ( !( c.parsers && c.parsers.length ) ) {
				ts.setupParsers( c, $tbodies );
			}
			// rebuild the cache map
			ts.buildCache( c, callback, $tbodies );
		},

		// init flag (true) used by pager plugin to prevent widget application
		// renamed from appendToTable
		appendCache : function( c, init ) {
			var parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime,
				table = c.table,
				$tbodies = c.$tbodies,
				rows = [],
				cache = c.cache;
			// empty table - fixes #206/#346
			if ( ts.isEmptyObject( cache ) ) {
				// run pager appender in case the table was just emptied
				return c.appender ? c.appender( table, rows ) :
					table.isUpdating ? c.$table.triggerHandler( 'updateComplete', table ) : ''; // Fixes #532
			}
			if ( ts.debug(c, 'core') ) {
				appendTime = new Date();
			}
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = $tbodies.eq( tbodyIndex );
				if ( $tbody.length ) {
					// detach tbody for manipulation
					$curTbody = ts.processTbody( table, $tbody, true );
					parsed = cache[ tbodyIndex ].normalized;
					totalRows = parsed.length;
					for ( rowIndex = 0; rowIndex < totalRows; rowIndex++ ) {
						rows[rows.length] = parsed[ rowIndex ][ c.columns ].$row;
						// removeRows used by the pager plugin; don't render if using ajax - fixes #411
						if ( !c.appender || ( c.pager && !c.pager.removeRows && !c.pager.ajax ) ) {
							$curTbody.append( parsed[ rowIndex ][ c.columns ].$row );
						}
					}
					// restore tbody
					ts.processTbody( table, $curTbody, false );
				}
			}
			if ( c.appender ) {
				c.appender( table, rows );
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'Rebuilt table' + ts.benchmark( appendTime ) );
			}
			// apply table widgets; but not before ajax completes
			if ( !init && !c.appender ) {
				ts.applyWidget( table );
			}
			if ( table.isUpdating ) {
				c.$table.triggerHandler( 'updateComplete', table );
			}
		},

		commonUpdate : function( c, resort, callback ) {
			// remove rows/elements before update
			c.$table.find( c.selectorRemove ).remove();
			// rebuild parsers
			ts.setupParsers( c );
			// rebuild the cache map
			ts.buildCache( c );
			ts.checkResort( c, resort, callback );
		},

		/*
		▄█████ ▄████▄ █████▄ ██████ ██ █████▄ ▄████▄
		▀█▄    ██  ██ ██▄▄██   ██   ██ ██  ██ ██ ▄▄▄
		   ▀█▄ ██  ██ ██▀██    ██   ██ ██  ██ ██ ▀██
		█████▀ ▀████▀ ██  ██   ██   ██ ██  ██ ▀████▀
		*/
		initSort : function( c, cell, event ) {
			if ( c.table.isUpdating ) {
				// let any updates complete before initializing a sort
				return setTimeout( function() {
					ts.initSort( c, cell, event );
				}, 50 );
			}

			var arry, indx, headerIndx, dir, temp, tmp, $header,
				notMultiSort = !event[ c.sortMultiSortKey ],
				table = c.table,
				len = c.$headers.length,
				th = ts.getClosest( $( cell ), 'th, td' ),
				col = parseInt( th.attr( 'data-column' ), 10 ),
				sortedBy = event.type === 'mouseup' ? 'user' : event.type,
				order = c.sortVars[ col ].order;
			th = th[0];
			// Only call sortStart if sorting is enabled
			c.$table.triggerHandler( 'sortStart', table );
			// get current column sort order
			tmp = ( c.sortVars[ col ].count + 1 ) % order.length;
			c.sortVars[ col ].count = event[ c.sortResetKey ] ? 2 : tmp;
			// reset all sorts on non-current column - issue #30
			if ( c.sortRestart ) {
				for ( headerIndx = 0; headerIndx < len; headerIndx++ ) {
					$header = c.$headers.eq( headerIndx );
					tmp = parseInt( $header.attr( 'data-column' ), 10 );
					// only reset counts on columns that weren't just clicked on and if not included in a multisort
					if ( col !== tmp && ( notMultiSort || $header.hasClass( ts.css.sortNone ) ) ) {
						c.sortVars[ tmp ].count = -1;
					}
				}
			}
			// user only wants to sort on one column
			if ( notMultiSort ) {
				$.each( c.sortVars, function( i ) {
					c.sortVars[ i ].sortedBy = '';
				});
				// flush the sort list
				c.sortList = [];
				c.last.sortList = [];
				if ( c.sortForce !== null ) {
					arry = c.sortForce;
					for ( indx = 0; indx < arry.length; indx++ ) {
						if ( arry[ indx ][ 0 ] !== col ) {
							c.sortList[ c.sortList.length ] = arry[ indx ];
							c.sortVars[ arry[ indx ][ 0 ] ].sortedBy = 'sortForce';
						}
					}
				}
				// add column to sort list
				dir = order[ c.sortVars[ col ].count ];
				if ( dir < 2 ) {
					c.sortList[ c.sortList.length ] = [ col, dir ];
					c.sortVars[ col ].sortedBy = sortedBy;
					// add other columns if header spans across multiple
					if ( th.colSpan > 1 ) {
						for ( indx = 1; indx < th.colSpan; indx++ ) {
							c.sortList[ c.sortList.length ] = [ col + indx, dir ];
							// update count on columns in colSpan
							c.sortVars[ col + indx ].count = $.inArray( dir, order );
							c.sortVars[ col + indx ].sortedBy = sortedBy;
						}
					}
				}
				// multi column sorting
			} else {
				// get rid of the sortAppend before adding more - fixes issue #115 & #523
				c.sortList = $.extend( [], c.last.sortList );

				// the user has clicked on an already sorted column
				if ( ts.isValueInArray( col, c.sortList ) >= 0 ) {
					// reverse the sorting direction
					c.sortVars[ col ].sortedBy = sortedBy;
					for ( indx = 0; indx < c.sortList.length; indx++ ) {
						tmp = c.sortList[ indx ];
						if ( tmp[ 0 ] === col ) {
							// order.count seems to be incorrect when compared to cell.count
							tmp[ 1 ] = order[ c.sortVars[ col ].count ];
							if ( tmp[1] === 2 ) {
								c.sortList.splice( indx, 1 );
								c.sortVars[ col ].count = -1;
							}
						}
					}
				} else {
					// add column to sort list array
					dir = order[ c.sortVars[ col ].count ];
					c.sortVars[ col ].sortedBy = sortedBy;
					if ( dir < 2 ) {
						c.sortList[ c.sortList.length ] = [ col, dir ];
						// add other columns if header spans across multiple
						if ( th.colSpan > 1 ) {
							for ( indx = 1; indx < th.colSpan; indx++ ) {
								c.sortList[ c.sortList.length ] = [ col + indx, dir ];
								// update count on columns in colSpan
								c.sortVars[ col + indx ].count = $.inArray( dir, order );
								c.sortVars[ col + indx ].sortedBy = sortedBy;
							}
						}
					}
				}
			}
			// save sort before applying sortAppend
			c.last.sortList = $.extend( [], c.sortList );
			if ( c.sortList.length && c.sortAppend ) {
				arry = $.isArray( c.sortAppend ) ? c.sortAppend : c.sortAppend[ c.sortList[ 0 ][ 0 ] ];
				if ( !ts.isEmptyObject( arry ) ) {
					for ( indx = 0; indx < arry.length; indx++ ) {
						if ( arry[ indx ][ 0 ] !== col && ts.isValueInArray( arry[ indx ][ 0 ], c.sortList ) < 0 ) {
							dir = arry[ indx ][ 1 ];
							temp = ( '' + dir ).match( /^(a|d|s|o|n)/ );
							if ( temp ) {
								tmp = c.sortList[ 0 ][ 1 ];
								switch ( temp[ 0 ] ) {
									case 'd' :
										dir = 1;
										break;
									case 's' :
										dir = tmp;
										break;
									case 'o' :
										dir = tmp === 0 ? 1 : 0;
										break;
									case 'n' :
										dir = ( tmp + 1 ) % order.length;
										break;
									default:
										dir = 0;
										break;
								}
							}
							c.sortList[ c.sortList.length ] = [ arry[ indx ][ 0 ], dir ];
							c.sortVars[ arry[ indx ][ 0 ] ].sortedBy = 'sortAppend';
						}
					}
				}
			}
			// sortBegin event triggered immediately before the sort
			c.$table.triggerHandler( 'sortBegin', table );
			// setTimeout needed so the processing icon shows up
			setTimeout( function() {
				// set css for headers
				ts.setHeadersCss( c );
				ts.multisort( c );
				ts.appendCache( c );
				c.$table.triggerHandler( 'sortBeforeEnd', table );
				c.$table.triggerHandler( 'sortEnd', table );
			}, 1 );
		},

		// sort multiple columns
		multisort : function( c ) { /*jshint loopfunc:true */
			var tbodyIndex, sortTime, colMax, rows, tmp,
				table = c.table,
				sorter = [],
				dir = 0,
				textSorter = c.textSorter || '',
				sortList = c.sortList,
				sortLen = sortList.length,
				len = c.$tbodies.length;
			if ( c.serverSideSorting || ts.isEmptyObject( c.cache ) ) {
				// empty table - fixes #206/#346
				return;
			}
			if ( ts.debug(c, 'core') ) { sortTime = new Date(); }
			// cache textSorter to optimize speed
			if ( typeof textSorter === 'object' ) {
				colMax = c.columns;
				while ( colMax-- ) {
					tmp = ts.getColumnData( table, textSorter, colMax );
					if ( typeof tmp === 'function' ) {
						sorter[ colMax ] = tmp;
					}
				}
			}
			for ( tbodyIndex = 0; tbodyIndex < len; tbodyIndex++ ) {
				colMax = c.cache[ tbodyIndex ].colMax;
				rows = c.cache[ tbodyIndex ].normalized;

				rows.sort( function( a, b ) {
					var sortIndex, num, col, order, sort, x, y;
					// rows is undefined here in IE, so don't use it!
					for ( sortIndex = 0; sortIndex < sortLen; sortIndex++ ) {
						col = sortList[ sortIndex ][ 0 ];
						order = sortList[ sortIndex ][ 1 ];
						// sort direction, true = asc, false = desc
						dir = order === 0;

						if ( c.sortStable && a[ col ] === b[ col ] && sortLen === 1 ) {
							return a[ c.columns ].order - b[ c.columns ].order;
						}

						// fallback to natural sort since it is more robust
						num = /n/i.test( ts.getSortType( c.parsers, col ) );
						if ( num && c.strings[ col ] ) {
							// sort strings in numerical columns
							if ( typeof ( ts.string[ c.strings[ col ] ] ) === 'boolean' ) {
								num = ( dir ? 1 : -1 ) * ( ts.string[ c.strings[ col ] ] ? -1 : 1 );
							} else {
								num = ( c.strings[ col ] ) ? ts.string[ c.strings[ col ] ] || 0 : 0;
							}
							// fall back to built-in numeric sort
							// var sort = $.tablesorter['sort' + s]( a[col], b[col], dir, colMax[col], table );
							sort = c.numberSorter ? c.numberSorter( a[ col ], b[ col ], dir, colMax[ col ], table ) :
								ts[ 'sortNumeric' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], num, colMax[ col ], col, c );
						} else {
							// set a & b depending on sort direction
							x = dir ? a : b;
							y = dir ? b : a;
							// text sort function
							if ( typeof textSorter === 'function' ) {
								// custom OVERALL text sorter
								sort = textSorter( x[ col ], y[ col ], dir, col, table );
							} else if ( typeof sorter[ col ] === 'function' ) {
								// custom text sorter for a SPECIFIC COLUMN
								sort = sorter[ col ]( x[ col ], y[ col ], dir, col, table );
							} else {
								// fall back to natural sort
								sort = ts[ 'sortNatural' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ] || '', b[ col ] || '', col, c );
							}
						}
						if ( sort ) { return sort; }
					}
					return a[ c.columns ].order - b[ c.columns ].order;
				});
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'Applying sort ' + sortList.toString() + ts.benchmark( sortTime ) );
			}
		},

		resortComplete : function( c, callback ) {
			if ( c.table.isUpdating ) {
				c.$table.triggerHandler( 'updateComplete', c.table );
			}
			if ( $.isFunction( callback ) ) {
				callback( c.table );
			}
		},

		checkResort : function( c, resort, callback ) {
			var sortList = $.isArray( resort ) ? resort : c.sortList,
				// if no resort parameter is passed, fallback to config.resort (true by default)
				resrt = typeof resort === 'undefined' ? c.resort : resort;
			// don't try to resort if the table is still processing
			// this will catch spamming of the updateCell method
			if ( resrt !== false && !c.serverSideSorting && !c.table.isProcessing ) {
				if ( sortList.length ) {
					ts.sortOn( c, sortList, function() {
						ts.resortComplete( c, callback );
					}, true );
				} else {
					ts.sortReset( c, function() {
						ts.resortComplete( c, callback );
						ts.applyWidget( c.table, false );
					} );
				}
			} else {
				ts.resortComplete( c, callback );
				ts.applyWidget( c.table, false );
			}
		},

		sortOn : function( c, list, callback, init ) {
			var indx,
				table = c.table;
			c.$table.triggerHandler( 'sortStart', table );
			for (indx = 0; indx < c.columns; indx++) {
				c.sortVars[ indx ].sortedBy = ts.isValueInArray( indx, list ) > -1 ? 'sorton' : '';
			}
			// update header count index
			ts.updateHeaderSortCount( c, list );
			// set css for headers
			ts.setHeadersCss( c );
			// fixes #346
			if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
				ts.buildCache( c );
			}
			c.$table.triggerHandler( 'sortBegin', table );
			// sort the table and append it to the dom
			ts.multisort( c );
			ts.appendCache( c, init );
			c.$table.triggerHandler( 'sortBeforeEnd', table );
			c.$table.triggerHandler( 'sortEnd', table );
			ts.applyWidget( table );
			if ( $.isFunction( callback ) ) {
				callback( table );
			}
		},

		sortReset : function( c, callback ) {
			c.sortList = [];
			var indx;
			for (indx = 0; indx < c.columns; indx++) {
				c.sortVars[ indx ].count = -1;
				c.sortVars[ indx ].sortedBy = '';
			}
			ts.setHeadersCss( c );
			ts.multisort( c );
			ts.appendCache( c );
			if ( $.isFunction( callback ) ) {
				callback( c.table );
			}
		},

		getSortType : function( parsers, column ) {
			return ( parsers && parsers[ column ] ) ? parsers[ column ].type || '' : '';
		},

		getOrder : function( val ) {
			// look for 'd' in 'desc' order; return true
			return ( /^d/i.test( val ) || val === 1 );
		},

		// Natural sort - https://github.com/overset/javascript-natural-sort (date sorting removed)
		sortNatural : function( a, b ) {
			if ( a === b ) { return 0; }
			a = ( a || '' ).toString();
			b = ( b || '' ).toString();
			var aNum, bNum, aFloat, bFloat, indx, max,
				regex = ts.regex;
			// first try and sort Hex codes
			if ( regex.hex.test( b ) ) {
				aNum = parseInt( a.match( regex.hex ), 16 );
				bNum = parseInt( b.match( regex.hex ), 16 );
				if ( aNum < bNum ) { return -1; }
				if ( aNum > bNum ) { return 1; }
			}
			// chunk/tokenize
			aNum = a.replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
			bNum = b.replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
			max = Math.max( aNum.length, bNum.length );
			// natural sorting through split numeric strings and default strings
			for ( indx = 0; indx < max; indx++ ) {
				// find floats not starting with '0', string or 0 if not defined
				aFloat = isNaN( aNum[ indx ] ) ? aNum[ indx ] || 0 : parseFloat( aNum[ indx ] ) || 0;
				bFloat = isNaN( bNum[ indx ] ) ? bNum[ indx ] || 0 : parseFloat( bNum[ indx ] ) || 0;
				// handle numeric vs string comparison - number < string - (Kyle Adams)
				if ( isNaN( aFloat ) !== isNaN( bFloat ) ) { return isNaN( aFloat ) ? 1 : -1; }
				// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
				if ( typeof aFloat !== typeof bFloat ) {
					aFloat += '';
					bFloat += '';
				}
				if ( aFloat < bFloat ) { return -1; }
				if ( aFloat > bFloat ) { return 1; }
			}
			return 0;
		},

		sortNaturalAsc : function( a, b, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
			return ts.sortNatural( a, b );
		},

		sortNaturalDesc : function( a, b, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
			return ts.sortNatural( b, a );
		},

		// basic alphabetical sort
		sortText : function( a, b ) {
			return a > b ? 1 : ( a < b ? -1 : 0 );
		},

		// return text string value by adding up ascii value
		// so the text is somewhat sorted when using a digital sort
		// this is NOT an alphanumeric sort
		getTextValue : function( val, num, max ) {
			if ( max ) {
				// make sure the text value is greater than the max numerical value (max)
				var indx,
					len = val ? val.length : 0,
					n = max + num;
				for ( indx = 0; indx < len; indx++ ) {
					n += val.charCodeAt( indx );
				}
				return num * n;
			}
			return 0;
		},

		sortNumericAsc : function( a, b, num, max, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
			if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
			if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
			return a - b;
		},

		sortNumericDesc : function( a, b, num, max, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
			if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
			if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
			return b - a;
		},

		sortNumeric : function( a, b ) {
			return a - b;
		},

		/*
		██ ██ ██ ██ █████▄ ▄████▄ ██████ ██████ ▄█████
		██ ██ ██ ██ ██  ██ ██ ▄▄▄ ██▄▄     ██   ▀█▄
		██ ██ ██ ██ ██  ██ ██ ▀██ ██▀▀     ██      ▀█▄
		███████▀ ██ █████▀ ▀████▀ ██████   ██   █████▀
		*/
		addWidget : function( widget ) {
			if ( widget.id && !ts.isEmptyObject( ts.getWidgetById( widget.id ) ) ) {
				console.warn( '"' + widget.id + '" widget was loaded more than once!' );
			}
			ts.widgets[ ts.widgets.length ] = widget;
		},

		hasWidget : function( $table, name ) {
			$table = $( $table );
			return $table.length && $table[ 0 ].config && $table[ 0 ].config.widgetInit[ name ] || false;
		},

		getWidgetById : function( name ) {
			var indx, widget,
				len = ts.widgets.length;
			for ( indx = 0; indx < len; indx++ ) {
				widget = ts.widgets[ indx ];
				if ( widget && widget.id && widget.id.toLowerCase() === name.toLowerCase() ) {
					return widget;
				}
			}
		},

		applyWidgetOptions : function( table ) {
			var indx, widget, wo,
				c = table.config,
				len = c.widgets.length;
			if ( len ) {
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.getWidgetById( c.widgets[ indx ] );
					if ( widget && widget.options ) {
						wo = $.extend( true, {}, widget.options );
						c.widgetOptions = $.extend( true, wo, c.widgetOptions );
						// add widgetOptions to defaults for option validator
						$.extend( true, ts.defaults.widgetOptions, widget.options );
					}
				}
			}
		},

		addWidgetFromClass : function( table ) {
			var len, indx,
				c = table.config,
				// look for widgets to apply from table class
				// don't match from 'ui-widget-content'; use \S instead of \w to include widgets
				// with dashes in the name, e.g. "widget-test-2" extracts out "test-2"
				regex = '^' + c.widgetClass.replace( ts.regex.templateName, '(\\S+)+' ) + '$',
				widgetClass = new RegExp( regex, 'g' ),
				// split up table class (widget id's can include dashes) - stop using match
				// otherwise only one widget gets extracted, see #1109
				widgets = ( table.className || '' ).split( ts.regex.spaces );
			if ( widgets.length ) {
				len = widgets.length;
				for ( indx = 0; indx < len; indx++ ) {
					if ( widgets[ indx ].match( widgetClass ) ) {
						c.widgets[ c.widgets.length ] = widgets[ indx ].replace( widgetClass, '$1' );
					}
				}
			}
		},

		applyWidgetId : function( table, id, init ) {
			table = $(table)[0];
			var applied, time, name,
				c = table.config,
				wo = c.widgetOptions,
				debug = ts.debug(c, 'core'),
				widget = ts.getWidgetById( id );
			if ( widget ) {
				name = widget.id;
				applied = false;
				// add widget name to option list so it gets reapplied after sorting, filtering, etc
				if ( $.inArray( name, c.widgets ) < 0 ) {
					c.widgets[ c.widgets.length ] = name;
				}
				if ( debug ) { time = new Date(); }

				if ( init || !( c.widgetInit[ name ] ) ) {
					// set init flag first to prevent calling init more than once (e.g. pager)
					c.widgetInit[ name ] = true;
					if ( table.hasInitialized ) {
						// don't reapply widget options on tablesorter init
						ts.applyWidgetOptions( table );
					}
					if ( typeof widget.init === 'function' ) {
						applied = true;
						if ( debug ) {
							console[ console.group ? 'group' : 'log' ]( 'Initializing ' + name + ' widget' );
						}
						widget.init( table, widget, c, wo );
					}
				}
				if ( !init && typeof widget.format === 'function' ) {
					applied = true;
					if ( debug ) {
						console[ console.group ? 'group' : 'log' ]( 'Updating ' + name + ' widget' );
					}
					widget.format( table, c, wo, false );
				}
				if ( debug ) {
					if ( applied ) {
						console.log( 'Completed ' + ( init ? 'initializing ' : 'applying ' ) + name + ' widget' + ts.benchmark( time ) );
						if ( console.groupEnd ) { console.groupEnd(); }
					}
				}
			}
		},

		applyWidget : function( table, init, callback ) {
			table = $( table )[ 0 ]; // in case this is called externally
			var indx, len, names, widget, time,
				c = table.config,
				debug = ts.debug(c, 'core'),
				widgets = [];
			// prevent numerous consecutive widget applications
			if ( init !== false && table.hasInitialized && ( table.isApplyingWidgets || table.isUpdating ) ) {
				return;
			}
			if ( debug ) { time = new Date(); }
			ts.addWidgetFromClass( table );
			// prevent "tablesorter-ready" from firing multiple times in a row
			clearTimeout( c.timerReady );
			if ( c.widgets.length ) {
				table.isApplyingWidgets = true;
				// ensure unique widget ids
				c.widgets = $.grep( c.widgets, function( val, index ) {
					return $.inArray( val, c.widgets ) === index;
				});
				names = c.widgets || [];
				len = names.length;
				// build widget array & add priority as needed
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.getWidgetById( names[ indx ] );
					if ( widget && widget.id ) {
						// set priority to 10 if not defined
						if ( !widget.priority ) { widget.priority = 10; }
						widgets[ indx ] = widget;
					} else if ( debug ) {
						console.warn( '"' + names[ indx ] + '" was enabled, but the widget code has not been loaded!' );
					}
				}
				// sort widgets by priority
				widgets.sort( function( a, b ) {
					return a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;
				});
				// add/update selected widgets
				len = widgets.length;
				if ( debug ) {
					console[ console.group ? 'group' : 'log' ]( 'Start ' + ( init ? 'initializing' : 'applying' ) + ' widgets' );
				}
				for ( indx = 0; indx < len; indx++ ) {
					widget = widgets[ indx ];
					if ( widget && widget.id ) {
						ts.applyWidgetId( table, widget.id, init );
					}
				}
				if ( debug && console.groupEnd ) { console.groupEnd(); }
			}
			c.timerReady = setTimeout( function() {
				table.isApplyingWidgets = false;
				$.data( table, 'lastWidgetApplication', new Date() );
				c.$table.triggerHandler( 'tablesorter-ready' );
				// callback executed on init only
				if ( !init && typeof callback === 'function' ) {
					callback( table );
				}
				if ( debug ) {
					widget = c.widgets.length;
					console.log( 'Completed ' +
						( init === true ? 'initializing ' : 'applying ' ) + widget +
						' widget' + ( widget !== 1 ? 's' : '' ) + ts.benchmark( time ) );
				}
			}, 10 );
		},

		removeWidget : function( table, name, refreshing ) {
			table = $( table )[ 0 ];
			var index, widget, indx, len,
				c = table.config;
			// if name === true, add all widgets from $.tablesorter.widgets
			if ( name === true ) {
				name = [];
				len = ts.widgets.length;
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.widgets[ indx ];
					if ( widget && widget.id ) {
						name[ name.length ] = widget.id;
					}
				}
			} else {
				// name can be either an array of widgets names,
				// or a space/comma separated list of widget names
				name = ( $.isArray( name ) ? name.join( ',' ) : name || '' ).toLowerCase().split( /[\s,]+/ );
			}
			len = name.length;
			for ( index = 0; index < len; index++ ) {
				widget = ts.getWidgetById( name[ index ] );
				indx = $.inArray( name[ index ], c.widgets );
				// don't remove the widget from config.widget if refreshing
				if ( indx >= 0 && refreshing !== true ) {
					c.widgets.splice( indx, 1 );
				}
				if ( widget && widget.remove ) {
					if ( ts.debug(c, 'core') ) {
						console.log( ( refreshing ? 'Refreshing' : 'Removing' ) + ' "' + name[ index ] + '" widget' );
					}
					widget.remove( table, c, c.widgetOptions, refreshing );
					c.widgetInit[ name[ index ] ] = false;
				}
			}
			c.$table.triggerHandler( 'widgetRemoveEnd', table );
		},

		refreshWidgets : function( table, doAll, dontapply ) {
			table = $( table )[ 0 ]; // see issue #243
			var indx, widget,
				c = table.config,
				curWidgets = c.widgets,
				widgets = ts.widgets,
				len = widgets.length,
				list = [],
				callback = function( table ) {
					$( table ).triggerHandler( 'refreshComplete' );
				};
			// remove widgets not defined in config.widgets, unless doAll is true
			for ( indx = 0; indx < len; indx++ ) {
				widget = widgets[ indx ];
				if ( widget && widget.id && ( doAll || $.inArray( widget.id, curWidgets ) < 0 ) ) {
					list[ list.length ] = widget.id;
				}
			}
			ts.removeWidget( table, list.join( ',' ), true );
			if ( dontapply !== true ) {
				// call widget init if
				ts.applyWidget( table, doAll || false, callback );
				if ( doAll ) {
					// apply widget format
					ts.applyWidget( table, false, callback );
				}
			} else {
				callback( table );
			}
		},

		/*
		██  ██ ██████ ██ ██     ██ ██████ ██ ██████ ▄█████
		██  ██   ██   ██ ██     ██   ██   ██ ██▄▄   ▀█▄
		██  ██   ██   ██ ██     ██   ██   ██ ██▀▀      ▀█▄
		▀████▀   ██   ██ ██████ ██   ██   ██ ██████ █████▀
		*/
		benchmark : function( diff ) {
			return ( ' (' + ( new Date().getTime() - diff.getTime() ) + ' ms)' );
		},
		// deprecated ts.log
		log : function() {
			console.log( arguments );
		},
		debug : function(c, name) {
			return c && (
				c.debug === true ||
				typeof c.debug === 'string' && c.debug.indexOf(name) > -1
			);
		},

		// $.isEmptyObject from jQuery v1.4
		isEmptyObject : function( obj ) {
			/*jshint forin: false */
			for ( var name in obj ) {
				return false;
			}
			return true;
		},

		isValueInArray : function( column, arry ) {
			var indx,
				len = arry && arry.length || 0;
			for ( indx = 0; indx < len; indx++ ) {
				if ( arry[ indx ][ 0 ] === column ) {
					return indx;
				}
			}
			return -1;
		},

		formatFloat : function( str, table ) {
			if ( typeof str !== 'string' || str === '' ) { return str; }
			// allow using formatFloat without a table; defaults to US number format
			var num,
				usFormat = table && table.config ? table.config.usNumberFormat !== false :
					typeof table !== 'undefined' ? table : true;
			if ( usFormat ) {
				// US Format - 1,234,567.89 -> 1234567.89
				str = str.replace( ts.regex.comma, '' );
			} else {
				// German Format = 1.234.567,89 -> 1234567.89
				// French Format = 1 234 567,89 -> 1234567.89
				str = str.replace( ts.regex.digitNonUS, '' ).replace( ts.regex.comma, '.' );
			}
			if ( ts.regex.digitNegativeTest.test( str ) ) {
				// make (#) into a negative number -> (10) = -10
				str = str.replace( ts.regex.digitNegativeReplace, '-$1' );
			}
			num = parseFloat( str );
			// return the text instead of zero
			return isNaN( num ) ? $.trim( str ) : num;
		},

		isDigit : function( str ) {
			// replace all unwanted chars and match
			return isNaN( str ) ?
				ts.regex.digitTest.test( str.toString().replace( ts.regex.digitReplace, '' ) ) :
				str !== '';
		},

		// computeTableHeaderCellIndexes from:
		// http://www.javascripttoolbox.com/lib/table/examples.php
		// http://www.javascripttoolbox.com/temp/table_cellindex.html
		computeColumnIndex : function( $rows, c ) {
			var i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol,
				// total columns has been calculated, use it to set the matrixrow
				columns = c && c.columns || 0,
				matrix = [],
				matrixrow = new Array( columns );
			for ( i = 0; i < $rows.length; i++ ) {
				cells = $rows[ i ].cells;
				for ( j = 0; j < cells.length; j++ ) {
					cell = cells[ j ];
					rowIndex = i;
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					if ( typeof matrix[ rowIndex ] === 'undefined' ) {
						matrix[ rowIndex ] = [];
					}
					// Find first available column in the first row
					for ( k = 0; k < matrix[ rowIndex ].length + 1; k++ ) {
						if ( typeof matrix[ rowIndex ][ k ] === 'undefined' ) {
							firstAvailCol = k;
							break;
						}
					}
					// jscs:disable disallowEmptyBlocks
					if ( columns && cell.cellIndex === firstAvailCol ) {
						// don't to anything
					} else if ( cell.setAttribute ) {
						// jscs:enable disallowEmptyBlocks
						// add data-column (setAttribute = IE8+)
						cell.setAttribute( 'data-column', firstAvailCol );
					} else {
						// remove once we drop support for IE7 - 1/12/2016
						$( cell ).attr( 'data-column', firstAvailCol );
					}
					for ( k = rowIndex; k < rowIndex + rowSpan; k++ ) {
						if ( typeof matrix[ k ] === 'undefined' ) {
							matrix[ k ] = [];
						}
						matrixrow = matrix[ k ];
						for ( l = firstAvailCol; l < firstAvailCol + colSpan; l++ ) {
							matrixrow[ l ] = 'x';
						}
					}
				}
			}
			ts.checkColumnCount($rows, matrix, matrixrow.length);
			return matrixrow.length;
		},

		checkColumnCount : function($rows, matrix, columns) {
			// this DOES NOT report any tbody column issues, except for the math and
			// and column selector widgets
			var i, len,
				valid = true,
				cells = [];
			for ( i = 0; i < matrix.length; i++ ) {
				// some matrix entries are undefined when testing the footer because
				// it is using the rowIndex property
				if ( matrix[i] ) {
					len = matrix[i].length;
					if ( matrix[i].length !== columns ) {
						valid = false;
						break;
					}
				}
			}
			if ( !valid ) {
				$rows.each( function( indx, el ) {
					var cell = el.parentElement.nodeName;
					if ( cells.indexOf( cell ) < 0 ) {
						cells.push( cell );
					}
				});
				console.error(
					'Invalid or incorrect number of columns in the ' +
					cells.join( ' or ' ) + '; expected ' + columns +
					', but found ' + len + ' columns'
				);
			}
		},

		// automatically add a colgroup with col elements set to a percentage width
		fixColumnWidth : function( table ) {
			table = $( table )[ 0 ];
			var overallWidth, percent, $tbodies, len, index,
				c = table.config,
				$colgroup = c.$table.children( 'colgroup' );
			// remove plugin-added colgroup, in case we need to refresh the widths
			if ( $colgroup.length && $colgroup.hasClass( ts.css.colgroup ) ) {
				$colgroup.remove();
			}
			if ( c.widthFixed && c.$table.children( 'colgroup' ).length === 0 ) {
				$colgroup = $( '<colgroup class="' + ts.css.colgroup + '">' );
				overallWidth = c.$table.width();
				// only add col for visible columns - fixes #371
				$tbodies = c.$tbodies.find( 'tr:first' ).children( ':visible' );
				len = $tbodies.length;
				for ( index = 0; index < len; index++ ) {
					percent = parseInt( ( $tbodies.eq( index ).width() / overallWidth ) * 1000, 10 ) / 10 + '%';
					$colgroup.append( $( '<col>' ).css( 'width', percent ) );
				}
				c.$table.prepend( $colgroup );
			}
		},

		// get sorter, string, empty, etc options for each column from
		// jQuery data, metadata, header option or header class name ('sorter-false')
		// priority = jQuery data > meta > headers option > header class name
		getData : function( header, configHeader, key ) {
			var meta, cl4ss,
				val = '',
				$header = $( header );
			if ( !$header.length ) { return ''; }
			meta = $.metadata ? $header.metadata() : false;
			cl4ss = ' ' + ( $header.attr( 'class' ) || '' );
			if ( typeof $header.data( key ) !== 'undefined' ||
				typeof $header.data( key.toLowerCase() ) !== 'undefined' ) {
				// 'data-lockedOrder' is assigned to 'lockedorder'; but 'data-locked-order' is assigned to 'lockedOrder'
				// 'data-sort-initial-order' is assigned to 'sortInitialOrder'
				val += $header.data( key ) || $header.data( key.toLowerCase() );
			} else if ( meta && typeof meta[ key ] !== 'undefined' ) {
				val += meta[ key ];
			} else if ( configHeader && typeof configHeader[ key ] !== 'undefined' ) {
				val += configHeader[ key ];
			} else if ( cl4ss !== ' ' && cl4ss.match( ' ' + key + '-' ) ) {
				// include sorter class name 'sorter-text', etc; now works with 'sorter-my-custom-parser'
				val = cl4ss.match( new RegExp( '\\s' + key + '-([\\w-]+)' ) )[ 1 ] || '';
			}
			return $.trim( val );
		},

		getColumnData : function( table, obj, indx, getCell, $headers ) {
			if ( typeof obj !== 'object' || obj === null ) {
				return obj;
			}
			table = $( table )[ 0 ];
			var $header, key,
				c = table.config,
				$cells = ( $headers || c.$headers ),
				// c.$headerIndexed is not defined initially
				$cell = c.$headerIndexed && c.$headerIndexed[ indx ] ||
					$cells.find( '[data-column="' + indx + '"]:last' );
			if ( typeof obj[ indx ] !== 'undefined' ) {
				return getCell ? obj[ indx ] : obj[ $cells.index( $cell ) ];
			}
			for ( key in obj ) {
				if ( typeof key === 'string' ) {
					$header = $cell
						// header cell with class/id
						.filter( key )
						// find elements within the header cell with cell/id
						.add( $cell.find( key ) );
					if ( $header.length ) {
						return obj[ key ];
					}
				}
			}
			return;
		},

		// *** Process table ***
		// add processing indicator
		isProcessing : function( $table, toggle, $headers ) {
			$table = $( $table );
			var c = $table[ 0 ].config,
				// default to all headers
				$header = $headers || $table.find( '.' + ts.css.header );
			if ( toggle ) {
				// don't use sortList if custom $headers used
				if ( typeof $headers !== 'undefined' && c.sortList.length > 0 ) {
					// get headers from the sortList
					$header = $header.filter( function() {
						// get data-column from attr to keep compatibility with jQuery 1.2.6
						return this.sortDisabled ?
							false :
							ts.isValueInArray( parseFloat( $( this ).attr( 'data-column' ) ), c.sortList ) >= 0;
					});
				}
				$table.add( $header ).addClass( ts.css.processing + ' ' + c.cssProcessing );
			} else {
				$table.add( $header ).removeClass( ts.css.processing + ' ' + c.cssProcessing );
			}
		},

		// detach tbody but save the position
		// don't use tbody because there are portions that look for a tbody index (updateCell)
		processTbody : function( table, $tb, getIt ) {
			table = $( table )[ 0 ];
			if ( getIt ) {
				table.isProcessing = true;
				$tb.before( '<colgroup class="tablesorter-savemyplace"/>' );
				return $.fn.detach ? $tb.detach() : $tb.remove();
			}
			var holdr = $( table ).find( 'colgroup.tablesorter-savemyplace' );
			$tb.insertAfter( holdr );
			holdr.remove();
			table.isProcessing = false;
		},

		clearTableBody : function( table ) {
			$( table )[ 0 ].config.$tbodies.children().detach();
		},

		// used when replacing accented characters during sorting
		characterEquivalents : {
			'a' : '\u00e1\u00e0\u00e2\u00e3\u00e4\u0105\u00e5', // áàâãäąå
			'A' : '\u00c1\u00c0\u00c2\u00c3\u00c4\u0104\u00c5', // ÁÀÂÃÄĄÅ
			'c' : '\u00e7\u0107\u010d', // çćč
			'C' : '\u00c7\u0106\u010c', // ÇĆČ
			'e' : '\u00e9\u00e8\u00ea\u00eb\u011b\u0119', // éèêëěę
			'E' : '\u00c9\u00c8\u00ca\u00cb\u011a\u0118', // ÉÈÊËĚĘ
			'i' : '\u00ed\u00ec\u0130\u00ee\u00ef\u0131', // íìİîïı
			'I' : '\u00cd\u00cc\u0130\u00ce\u00cf', // ÍÌİÎÏ
			'o' : '\u00f3\u00f2\u00f4\u00f5\u00f6\u014d', // óòôõöō
			'O' : '\u00d3\u00d2\u00d4\u00d5\u00d6\u014c', // ÓÒÔÕÖŌ
			'ss': '\u00df', // ß (s sharp)
			'SS': '\u1e9e', // ẞ (Capital sharp s)
			'u' : '\u00fa\u00f9\u00fb\u00fc\u016f', // úùûüů
			'U' : '\u00da\u00d9\u00db\u00dc\u016e' // ÚÙÛÜŮ
		},

		replaceAccents : function( str ) {
			var chr,
				acc = '[',
				eq = ts.characterEquivalents;
			if ( !ts.characterRegex ) {
				ts.characterRegexArray = {};
				for ( chr in eq ) {
					if ( typeof chr === 'string' ) {
						acc += eq[ chr ];
						ts.characterRegexArray[ chr ] = new RegExp( '[' + eq[ chr ] + ']', 'g' );
					}
				}
				ts.characterRegex = new RegExp( acc + ']' );
			}
			if ( ts.characterRegex.test( str ) ) {
				for ( chr in eq ) {
					if ( typeof chr === 'string' ) {
						str = str.replace( ts.characterRegexArray[ chr ], chr );
					}
				}
			}
			return str;
		},

		validateOptions : function( c ) {
			var setting, setting2, typ, timer,
				// ignore options containing an array
				ignore = 'headers sortForce sortList sortAppend widgets'.split( ' ' ),
				orig = c.originalSettings;
			if ( orig ) {
				if ( ts.debug(c, 'core') ) {
					timer = new Date();
				}
				for ( setting in orig ) {
					typ = typeof ts.defaults[setting];
					if ( typ === 'undefined' ) {
						console.warn( 'Tablesorter Warning! "table.config.' + setting + '" option not recognized' );
					} else if ( typ === 'object' ) {
						for ( setting2 in orig[setting] ) {
							typ = ts.defaults[setting] && typeof ts.defaults[setting][setting2];
							if ( $.inArray( setting, ignore ) < 0 && typ === 'undefined' ) {
								console.warn( 'Tablesorter Warning! "table.config.' + setting + '.' + setting2 + '" option not recognized' );
							}
						}
					}
				}
				if ( ts.debug(c, 'core') ) {
					console.log( 'validate options time:' + ts.benchmark( timer ) );
				}
			}
		},

		// restore headers
		restoreHeaders : function( table ) {
			var index, $cell,
				c = $( table )[ 0 ].config,
				$headers = c.$table.find( c.selectorHeaders ),
				len = $headers.length;
			// don't use c.$headers here in case header cells were swapped
			for ( index = 0; index < len; index++ ) {
				$cell = $headers.eq( index );
				// only restore header cells if it is wrapped
				// because this is also used by the updateAll method
				if ( $cell.find( '.' + ts.css.headerIn ).length ) {
					$cell.html( c.headerContent[ index ] );
				}
			}
		},

		destroy : function( table, removeClasses, callback ) {
			table = $( table )[ 0 ];
			if ( !table.hasInitialized ) { return; }
			// remove all widgets
			ts.removeWidget( table, true, false );
			var events,
				$t = $( table ),
				c = table.config,
				$h = $t.find( 'thead:first' ),
				$r = $h.find( 'tr.' + ts.css.headerRow ).removeClass( ts.css.headerRow + ' ' + c.cssHeaderRow ),
				$f = $t.find( 'tfoot:first > tr' ).children( 'th, td' );
			if ( removeClasses === false && $.inArray( 'uitheme', c.widgets ) >= 0 ) {
				// reapply uitheme classes, in case we want to maintain appearance
				$t.triggerHandler( 'applyWidgetId', [ 'uitheme' ] );
				$t.triggerHandler( 'applyWidgetId', [ 'zebra' ] );
			}
			// remove widget added rows, just in case
			$h.find( 'tr' ).not( $r ).remove();
			// disable tablesorter - not using .unbind( namespace ) because namespacing was
			// added in jQuery v1.4.3 - see http://api.jquery.com/event.namespace/
			events = 'sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton ' +
				'appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave ' +
				'keypress sortBegin sortEnd resetToLoadState '.split( ' ' )
				.join( c.namespace + ' ' );
			$t
				.removeData( 'tablesorter' )
				.unbind( events.replace( ts.regex.spaces, ' ' ) );
			c.$headers
				.add( $f )
				.removeClass( [ ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone ].join( ' ' ) )
				.removeAttr( 'data-column' )
				.removeAttr( 'aria-label' )
				.attr( 'aria-disabled', 'true' );
			$r
				.find( c.selectorSort )
				.unbind( ( 'mousedown mouseup keypress '.split( ' ' ).join( c.namespace + ' ' ) ).replace( ts.regex.spaces, ' ' ) );
			ts.restoreHeaders( table );
			$t.toggleClass( ts.css.table + ' ' + c.tableClass + ' tablesorter-' + c.theme, removeClasses === false );
			$t.removeClass(c.namespace.slice(1));
			// clear flag in case the plugin is initialized again
			table.hasInitialized = false;
			delete table.config.cache;
			if ( typeof callback === 'function' ) {
				callback( table );
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'tablesorter has been removed' );
			}
		}

	};

	$.fn.tablesorter = function( settings ) {
		return this.each( function() {
			var table = this,
			// merge & extend config options
			c = $.extend( true, {}, ts.defaults, settings, ts.instanceMethods );
			// save initial settings
			c.originalSettings = settings;
			// create a table from data (build table widget)
			if ( !table.hasInitialized && ts.buildTable && this.nodeName !== 'TABLE' ) {
				// return the table (in case the original target is the table's container)
				ts.buildTable( table, c );
			} else {
				ts.setup( table, c );
			}
		});
	};

	// set up debug logs
	if ( !( window.console && window.console.log ) ) {
		// access $.tablesorter.logs for browsers that don't have a console...
		ts.logs = [];
		/*jshint -W020 */
		console = {};
		console.log = console.warn = console.error = console.table = function() {
			var arg = arguments.length > 1 ? arguments : arguments[0];
			ts.logs[ ts.logs.length ] = { date: Date.now(), log: arg };
		};
	}

	// add default parsers
	ts.addParser({
		id : 'no-parser',
		is : function() {
			return false;
		},
		format : function() {
			return '';
		},
		type : 'text'
	});

	ts.addParser({
		id : 'text',
		is : function() {
			return true;
		},
		format : function( str, table ) {
			var c = table.config;
			if ( str ) {
				str = $.trim( c.ignoreCase ? str.toLocaleLowerCase() : str );
				str = c.sortLocaleCompare ? ts.replaceAccents( str ) : str;
			}
			return str;
		},
		type : 'text'
	});

	ts.regex.nondigit = /[^\w,. \-()]/g;
	ts.addParser({
		id : 'digit',
		is : function( str ) {
			return ts.isDigit( str );
		},
		format : function( str, table ) {
			var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
			return str && typeof num === 'number' ? num :
				str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
		},
		type : 'numeric'
	});

	ts.regex.currencyReplace = /[+\-,. ]/g;
	ts.regex.currencyTest = /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/;
	ts.addParser({
		id : 'currency',
		is : function( str ) {
			str = ( str || '' ).replace( ts.regex.currencyReplace, '' );
			// test for £$€¤¥¢
			return ts.regex.currencyTest.test( str );
		},
		format : function( str, table ) {
			var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
			return str && typeof num === 'number' ? num :
				str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
		},
		type : 'numeric'
	});

	// too many protocols to add them all https://en.wikipedia.org/wiki/URI_scheme
	// now, this regex can be updated before initialization
	ts.regex.urlProtocolTest = /^(https?|ftp|file):\/\//;
	ts.regex.urlProtocolReplace = /(https?|ftp|file):\/\/(www\.)?/;
	ts.addParser({
		id : 'url',
		is : function( str ) {
			return ts.regex.urlProtocolTest.test( str );
		},
		format : function( str ) {
			return str ? $.trim( str.replace( ts.regex.urlProtocolReplace, '' ) ) : str;
		},
		type : 'text'
	});

	ts.regex.dash = /-/g;
	ts.regex.isoDate = /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/;
	ts.addParser({
		id : 'isoDate',
		is : function( str ) {
			return ts.regex.isoDate.test( str );
		},
		format : function( str ) {
			var date = str ? new Date( str.replace( ts.regex.dash, '/' ) ) : str;
			return date instanceof Date && isFinite( date ) ? date.getTime() : str;
		},
		type : 'numeric'
	});

	ts.regex.percent = /%/g;
	ts.regex.percentTest = /(\d\s*?%|%\s*?\d)/;
	ts.addParser({
		id : 'percent',
		is : function( str ) {
			return ts.regex.percentTest.test( str ) && str.length < 15;
		},
		format : function( str, table ) {
			return str ? ts.formatFloat( str.replace( ts.regex.percent, '' ), table ) : str;
		},
		type : 'numeric'
	});

	// added image parser to core v2.17.9
	ts.addParser({
		id : 'image',
		is : function( str, table, node, $node ) {
			return $node.find( 'img' ).length > 0;
		},
		format : function( str, table, cell ) {
			return $( cell ).find( 'img' ).attr( table.config.imgAttr || 'alt' ) || str;
		},
		parsed : true, // filter widget flag
		type : 'text'
	});

	ts.regex.dateReplace = /(\S)([AP]M)$/i; // used by usLongDate & time parser
	ts.regex.usLongDateTest1 = /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i;
	ts.regex.usLongDateTest2 = /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i;
	ts.addParser({
		id : 'usLongDate',
		is : function( str ) {
			// two digit years are not allowed cross-browser
			// Jan 01, 2013 12:34:56 PM or 01 Jan 2013
			return ts.regex.usLongDateTest1.test( str ) || ts.regex.usLongDateTest2.test( str );
		},
		format : function( str ) {
			var date = str ? new Date( str.replace( ts.regex.dateReplace, '$1 $2' ) ) : str;
			return date instanceof Date && isFinite( date ) ? date.getTime() : str;
		},
		type : 'numeric'
	});

	// testing for ##-##-#### or ####-##-##, so it's not perfect; time can be included
	ts.regex.shortDateTest = /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/;
	// escaped "-" because JSHint in Firefox was showing it as an error
	ts.regex.shortDateReplace = /[\-.,]/g;
	// XXY covers MDY & DMY formats
	ts.regex.shortDateXXY = /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/;
	ts.regex.shortDateYMD = /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/;
	ts.convertFormat = function( dateString, format ) {
		dateString = ( dateString || '' )
			.replace( ts.regex.spaces, ' ' )
			.replace( ts.regex.shortDateReplace, '/' );
		if ( format === 'mmddyyyy' ) {
			dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$1/$2' );
		} else if ( format === 'ddmmyyyy' ) {
			dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$2/$1' );
		} else if ( format === 'yyyymmdd' ) {
			dateString = dateString.replace( ts.regex.shortDateYMD, '$1/$2/$3' );
		}
		var date = new Date( dateString );
		return date instanceof Date && isFinite( date ) ? date.getTime() : '';
	};

	ts.addParser({
		id : 'shortDate', // 'mmddyyyy', 'ddmmyyyy' or 'yyyymmdd'
		is : function( str ) {
			str = ( str || '' ).replace( ts.regex.spaces, ' ' ).replace( ts.regex.shortDateReplace, '/' );
			return ts.regex.shortDateTest.test( str );
		},
		format : function( str, table, cell, cellIndex ) {
			if ( str ) {
				var c = table.config,
					$header = c.$headerIndexed[ cellIndex ],
					format = $header.length && $header.data( 'dateFormat' ) ||
						ts.getData( $header, ts.getColumnData( table, c.headers, cellIndex ), 'dateFormat' ) ||
						c.dateFormat;
				// save format because getData can be slow...
				if ( $header.length ) {
					$header.data( 'dateFormat', format );
				}
				return ts.convertFormat( str, format ) || str;
			}
			return str;
		},
		type : 'numeric'
	});

	// match 24 hour time & 12 hours time + am/pm - see http://regexr.com/3c3tk
	ts.regex.timeTest = /^(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)$|^((?:[01]\d|[2][0-4]):[0-5]\d)$/i;
	ts.regex.timeMatch = /(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)|((?:[01]\d|[2][0-4]):[0-5]\d)/i;
	ts.addParser({
		id : 'time',
		is : function( str ) {
			return ts.regex.timeTest.test( str );
		},
		format : function( str ) {
			// isolate time... ignore month, day and year
			var temp,
				timePart = ( str || '' ).match( ts.regex.timeMatch ),
				orig = new Date( str ),
				// no time component? default to 00:00 by leaving it out, but only if str is defined
				time = str && ( timePart !== null ? timePart[ 0 ] : '00:00 AM' ),
				date = time ? new Date( '2000/01/01 ' + time.replace( ts.regex.dateReplace, '$1 $2' ) ) : time;
			if ( date instanceof Date && isFinite( date ) ) {
				temp = orig instanceof Date && isFinite( orig ) ? orig.getTime() : 0;
				// if original string was a valid date, add it to the decimal so the column sorts in some kind of order
				// luckily new Date() ignores the decimals
				return temp ? parseFloat( date.getTime() + '.' + orig.getTime() ) : date.getTime();
			}
			return str;
		},
		type : 'numeric'
	});

	ts.addParser({
		id : 'metadata',
		is : function() {
			return false;
		},
		format : function( str, table, cell ) {
			var c = table.config,
			p = ( !c.parserMetadataName ) ? 'sortValue' : c.parserMetadataName;
			return $( cell ).metadata()[ p ];
		},
		type : 'numeric'
	});

	/*
		██████ ██████ █████▄ █████▄ ▄████▄
		  ▄█▀  ██▄▄   ██▄▄██ ██▄▄██ ██▄▄██
		▄█▀    ██▀▀   ██▀▀██ ██▀▀█  ██▀▀██
		██████ ██████ █████▀ ██  ██ ██  ██
		*/
	// add default widgets
	ts.addWidget({
		id : 'zebra',
		priority : 90,
		format : function( table, c, wo ) {
			var $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len,
				child = new RegExp( c.cssChildRow, 'i' ),
				$tbodies = c.$tbodies.add( $( c.namespace + '_extra_table' ).children( 'tbody:not(.' + c.cssInfoBlock + ')' ) );
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				// loop through the visible rows
				count = 0;
				$visibleRows = $tbodies.eq( tbodyIndex ).children( 'tr:visible' ).not( c.selectorRemove );
				len = $visibleRows.length;
				for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {
					$row = $visibleRows.eq( rowIndex );
					// style child rows the same way the parent row was styled
					if ( !child.test( $row[ 0 ].className ) ) { count++; }
					isEven = ( count % 2 === 0 );
					$row
						.removeClass( wo.zebra[ isEven ? 1 : 0 ] )
						.addClass( wo.zebra[ isEven ? 0 : 1 ] );
				}
			}
		},
		remove : function( table, c, wo, refreshing ) {
			if ( refreshing ) { return; }
			var tbodyIndex, $tbody,
				$tbodies = c.$tbodies,
				toRemove = ( wo.zebra || [ 'even', 'odd' ] ).join( ' ' );
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody
				$tbody.children().removeClass( toRemove );
				ts.processTbody( table, $tbody, false ); // restore tbody
			}
		}
	});

})( jQuery );

/*! Widget: storage - updated 2018-03-18 (v2.30.0) */
/*global JSON:false */
;(function ($, window, document) {
	'use strict';

	var ts = $.tablesorter || {};

	// update defaults for validator; these values must be falsy!
	$.extend(true, ts.defaults, {
		fixedUrl: '',
		widgetOptions: {
			storage_fixedUrl: '',
			storage_group: '',
			storage_page: '',
			storage_storageType: '',
			storage_tableId: '',
			storage_useSessionStorage: ''
		}
	});

	// *** Store data in local storage, with a cookie fallback ***
	/* IE7 needs JSON library for JSON.stringify - (http://caniuse.com/#search=json)
	   if you need it, then include https://github.com/douglascrockford/JSON-js

	   $.parseJSON is not available is jQuery versions older than 1.4.1, using older
	   versions will only allow storing information for one page at a time

	   // *** Save data (JSON format only) ***
	   // val must be valid JSON... use http://jsonlint.com/ to ensure it is valid
	   var val = { "mywidget" : "data1" }; // valid JSON uses double quotes
	   // $.tablesorter.storage(table, key, val);
	   $.tablesorter.storage(table, 'tablesorter-mywidget', val);

	   // *** Get data: $.tablesorter.storage(table, key); ***
	   v = $.tablesorter.storage(table, 'tablesorter-mywidget');
	   // val may be empty, so also check for your data
	   val = (v && v.hasOwnProperty('mywidget')) ? v.mywidget : '';
	   alert(val); // 'data1' if saved, or '' if not
	*/
	ts.storage = function(table, key, value, options) {
		table = $(table)[0];
		var cookieIndex, cookies, date,
			hasStorage = false,
			values = {},
			c = table.config,
			wo = c && c.widgetOptions,
			debug = ts.debug(c, 'storage'),
			storageType = (
				( options && options.storageType ) || ( wo && wo.storage_storageType )
			).toString().charAt(0).toLowerCase(),
			// deprecating "useSessionStorage"; any storageType setting overrides it
			session = storageType ? '' :
				( options && options.useSessionStorage ) || ( wo && wo.storage_useSessionStorage ),
			$table = $(table),
			// id from (1) options ID, (2) table 'data-table-group' attribute, (3) widgetOptions.storage_tableId,
			// (4) table ID, then (5) table index
			id = options && options.id ||
				$table.attr( options && options.group || wo && wo.storage_group || 'data-table-group') ||
				wo && wo.storage_tableId || table.id || $('.tablesorter').index( $table ),
			// url from (1) options url, (2) table 'data-table-page' attribute, (3) widgetOptions.storage_fixedUrl,
			// (4) table.config.fixedUrl (deprecated), then (5) window location path
			url = options && options.url ||
				$table.attr(options && options.page || wo && wo.storage_page || 'data-table-page') ||
				wo && wo.storage_fixedUrl || c && c.fixedUrl || window.location.pathname;

		// skip if using cookies
		if (storageType !== 'c') {
			storageType = (storageType === 's' || session) ? 'sessionStorage' : 'localStorage';
			// https://gist.github.com/paulirish/5558557
			if (storageType in window) {
				try {
					window[storageType].setItem('_tmptest', 'temp');
					hasStorage = true;
					window[storageType].removeItem('_tmptest');
				} catch (error) {
					console.warn( storageType + ' is not supported in this browser' );
				}
			}
		}
		if (debug) {
			console.log('Storage >> Using', hasStorage ? storageType : 'cookies');
		}
		// *** get value ***
		if ($.parseJSON) {
			if (hasStorage) {
				values = $.parseJSON( window[storageType][key] || 'null' ) || {};
			} else {
				// old browser, using cookies
				cookies = document.cookie.split(/[;\s|=]/);
				// add one to get from the key to the value
				cookieIndex = $.inArray(key, cookies) + 1;
				values = (cookieIndex !== 0) ? $.parseJSON(cookies[cookieIndex] || 'null') || {} : {};
			}
		}
		// allow value to be an empty string too
		if (typeof value !== 'undefined' && window.JSON && JSON.hasOwnProperty('stringify')) {
			// add unique identifiers = url pathname > table ID/index on page > data
			if (!values[url]) {
				values[url] = {};
			}
			values[url][id] = value;
			// *** set value ***
			if (hasStorage) {
				window[storageType][key] = JSON.stringify(values);
			} else {
				date = new Date();
				date.setTime(date.getTime() + (31536e+6)); // 365 days
				document.cookie = key + '=' + (JSON.stringify(values)).replace(/\"/g, '\"') + '; expires=' + date.toGMTString() + '; path=/';
			}
		} else {
			return values && values[url] ? values[url][id] : '';
		}
	};

})(jQuery, window, document);

/*! Widget: uitheme - updated 2018-03-18 (v2.30.0) */
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	ts.themes = {
		'bootstrap' : {
			table        : 'table table-bordered table-striped',
			caption      : 'caption',
			// header class names
			header       : 'bootstrap-header', // give the header a gradient background (theme.bootstrap_2.css)
			sortNone     : '',
			sortAsc      : '',
			sortDesc     : '',
			active       : '', // applied when column is sorted
			hover        : '', // custom css required - a defined bootstrap style may not override other classes
			// icon class names
			icons        : '', // add 'bootstrap-icon-white' to make them white; this icon class is added to the <i> in the header
			iconSortNone : 'bootstrap-icon-unsorted', // class name added to icon when column is not sorted
			iconSortAsc  : 'glyphicon glyphicon-chevron-up', // class name added to icon when column has ascending sort
			iconSortDesc : 'glyphicon glyphicon-chevron-down', // class name added to icon when column has descending sort
			filterRow    : '', // filter row class
			footerRow    : '',
			footerCells  : '',
			even         : '', // even row zebra striping
			odd          : ''  // odd row zebra striping
		},
		'jui' : {
			table        : 'ui-widget ui-widget-content ui-corner-all', // table classes
			caption      : 'ui-widget-content',
			// header class names
			header       : 'ui-widget-header ui-corner-all ui-state-default', // header classes
			sortNone     : '',
			sortAsc      : '',
			sortDesc     : '',
			active       : 'ui-state-active', // applied when column is sorted
			hover        : 'ui-state-hover',  // hover class
			// icon class names
			icons        : 'ui-icon', // icon class added to the <i> in the header
			iconSortNone : 'ui-icon-carat-2-n-s ui-icon-caret-2-n-s', // class name added to icon when column is not sorted
			iconSortAsc  : 'ui-icon-carat-1-n ui-icon-caret-1-n', // class name added to icon when column has ascending sort
			iconSortDesc : 'ui-icon-carat-1-s ui-icon-caret-1-s', // class name added to icon when column has descending sort
			filterRow    : '',
			footerRow    : '',
			footerCells  : '',
			even         : 'ui-widget-content', // even row zebra striping
			odd          : 'ui-state-default'   // odd row zebra striping
		}
	};

	$.extend(ts.css, {
		wrapper : 'tablesorter-wrapper' // ui theme & resizable
	});

	ts.addWidget({
		id: 'uitheme',
		priority: 10,
		format: function(table, c, wo) {
			var i, tmp, hdr, icon, time, $header, $icon, $tfoot, $h, oldtheme, oldremove, oldIconRmv, hasOldTheme,
				themesAll = ts.themes,
				$table = c.$table.add( $( c.namespace + '_extra_table' ) ),
				$headers = c.$headers.add( $( c.namespace + '_extra_headers' ) ),
				theme = c.theme || 'jui',
				themes = themesAll[theme] || {},
				remove = $.trim( [ themes.sortNone, themes.sortDesc, themes.sortAsc, themes.active ].join( ' ' ) ),
				iconRmv = $.trim( [ themes.iconSortNone, themes.iconSortDesc, themes.iconSortAsc ].join( ' ' ) ),
				debug = ts.debug(c, 'uitheme');
			if (debug) { time = new Date(); }
			// initialization code - run once
			if (!$table.hasClass('tablesorter-' + theme) || c.theme !== c.appliedTheme || !wo.uitheme_applied) {
				wo.uitheme_applied = true;
				oldtheme = themesAll[c.appliedTheme] || {};
				hasOldTheme = !$.isEmptyObject(oldtheme);
				oldremove =  hasOldTheme ? [ oldtheme.sortNone, oldtheme.sortDesc, oldtheme.sortAsc, oldtheme.active ].join( ' ' ) : '';
				oldIconRmv = hasOldTheme ? [ oldtheme.iconSortNone, oldtheme.iconSortDesc, oldtheme.iconSortAsc ].join( ' ' ) : '';
				if (hasOldTheme) {
					wo.zebra[0] = $.trim( ' ' + wo.zebra[0].replace(' ' + oldtheme.even, '') );
					wo.zebra[1] = $.trim( ' ' + wo.zebra[1].replace(' ' + oldtheme.odd, '') );
					c.$tbodies.children().removeClass( [ oldtheme.even, oldtheme.odd ].join(' ') );
				}
				// update zebra stripes
				if (themes.even) { wo.zebra[0] += ' ' + themes.even; }
				if (themes.odd) { wo.zebra[1] += ' ' + themes.odd; }
				// add caption style
				$table.children('caption')
					.removeClass(oldtheme.caption || '')
					.addClass(themes.caption);
				// add table/footer class names
				$tfoot = $table
					// remove other selected themes
					.removeClass( (c.appliedTheme ? 'tablesorter-' + (c.appliedTheme || '') : '') + ' ' + (oldtheme.table || '') )
					.addClass('tablesorter-' + theme + ' ' + (themes.table || '')) // add theme widget class name
					.children('tfoot');
				c.appliedTheme = c.theme;

				if ($tfoot.length) {
					$tfoot
						// if oldtheme.footerRow or oldtheme.footerCells are undefined, all class names are removed
						.children('tr').removeClass(oldtheme.footerRow || '').addClass(themes.footerRow)
						.children('th, td').removeClass(oldtheme.footerCells || '').addClass(themes.footerCells);
				}
				// update header classes
				$headers
					.removeClass( (hasOldTheme ? [ oldtheme.header, oldtheme.hover, oldremove ].join(' ') : '') || '' )
					.addClass(themes.header)
					.not('.sorter-false')
					.unbind('mouseenter.tsuitheme mouseleave.tsuitheme')
					.bind('mouseenter.tsuitheme mouseleave.tsuitheme', function(event) {
						// toggleClass with switch added in jQuery 1.3
						$(this)[ event.type === 'mouseenter' ? 'addClass' : 'removeClass' ](themes.hover || '');
					});

				$headers.each(function() {
					var $this = $(this);
					if (!$this.find('.' + ts.css.wrapper).length) {
						// Firefox needs this inner div to position the icon & resizer correctly
						$this.wrapInner('<div class="' + ts.css.wrapper + '" style="position:relative;height:100%;width:100%"></div>');
					}
				});
				if (c.cssIcon) {
					// if c.cssIcon is '', then no <i> is added to the header
					$headers
						.find('.' + ts.css.icon)
						.removeClass(hasOldTheme ? [ oldtheme.icons, oldIconRmv ].join(' ') : '')
						.addClass(themes.icons || '');
				}
				// filter widget initializes after uitheme
				if (ts.hasWidget( c.table, 'filter' )) {
					tmp = function() {
						$table.children('thead').children('.' + ts.css.filterRow)
							.removeClass(hasOldTheme ? oldtheme.filterRow || '' : '')
							.addClass(themes.filterRow || '');
					};
					if (wo.filter_initialized) {
						tmp();
					} else {
						$table.one('filterInit', function() {
							tmp();
						});
					}
				}
			}
			for (i = 0; i < c.columns; i++) {
				$header = c.$headers
					.add($(c.namespace + '_extra_headers'))
					.not('.sorter-false')
					.filter('[data-column="' + i + '"]');
				$icon = (ts.css.icon) ? $header.find('.' + ts.css.icon) : $();
				$h = $headers.not('.sorter-false').filter('[data-column="' + i + '"]:last');
				if ($h.length) {
					$header.removeClass(remove);
					$icon.removeClass(iconRmv);
					if ($h[0].sortDisabled) {
						// no sort arrows for disabled columns!
						$icon.removeClass(themes.icons || '');
					} else {
						hdr = themes.sortNone;
						icon = themes.iconSortNone;
						if ($h.hasClass(ts.css.sortAsc)) {
							hdr = [ themes.sortAsc, themes.active ].join(' ');
							icon = themes.iconSortAsc;
						} else if ($h.hasClass(ts.css.sortDesc)) {
							hdr = [ themes.sortDesc, themes.active ].join(' ');
							icon = themes.iconSortDesc;
						}
						$header.addClass(hdr);
						$icon.addClass(icon || '');
					}
				}
			}
			if (debug) {
				console.log('uitheme >> Applied ' + theme + ' theme' + ts.benchmark(time));
			}
		},
		remove: function(table, c, wo, refreshing) {
			if (!wo.uitheme_applied) { return; }
			var $table = c.$table,
				theme = c.appliedTheme || 'jui',
				themes = ts.themes[ theme ] || ts.themes.jui,
				$headers = $table.children('thead').children(),
				remove = themes.sortNone + ' ' + themes.sortDesc + ' ' + themes.sortAsc,
				iconRmv = themes.iconSortNone + ' ' + themes.iconSortDesc + ' ' + themes.iconSortAsc;
			$table.removeClass('tablesorter-' + theme + ' ' + themes.table);
			wo.uitheme_applied = false;
			if (refreshing) { return; }
			$table.find(ts.css.header).removeClass(themes.header);
			$headers
				.unbind('mouseenter.tsuitheme mouseleave.tsuitheme') // remove hover
				.removeClass(themes.hover + ' ' + remove + ' ' + themes.active)
				.filter('.' + ts.css.filterRow)
				.removeClass(themes.filterRow);
			$headers.find('.' + ts.css.icon).removeClass(themes.icons + ' ' + iconRmv);
		}
	});

})(jQuery);

/*! Widget: columns - updated 5/24/2017 (v2.28.11) */
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	ts.addWidget({
		id: 'columns',
		priority: 65,
		options : {
			columns : [ 'primary', 'secondary', 'tertiary' ]
		},
		format: function(table, c, wo) {
			var $tbody, tbodyIndex, $rows, rows, $row, $cells, remove, indx,
			$table = c.$table,
			$tbodies = c.$tbodies,
			sortList = c.sortList,
			len = sortList.length,
			// removed c.widgetColumns support
			css = wo && wo.columns || [ 'primary', 'secondary', 'tertiary' ],
			last = css.length - 1;
			remove = css.join(' ');
			// check if there is a sort (on initialization there may not be one)
			for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true); // detach tbody
				$rows = $tbody.children('tr');
				// loop through the visible rows
				$rows.each(function() {
					$row = $(this);
					if (this.style.display !== 'none') {
						// remove all columns class names
						$cells = $row.children().removeClass(remove);
						// add appropriate column class names
						if (sortList && sortList[0]) {
							// primary sort column class
							$cells.eq(sortList[0][0]).addClass(css[0]);
							if (len > 1) {
								for (indx = 1; indx < len; indx++) {
									// secondary, tertiary, etc sort column classes
									$cells.eq(sortList[indx][0]).addClass( css[indx] || css[last] );
								}
							}
						}
					}
				});
				ts.processTbody(table, $tbody, false);
			}
			// add classes to thead and tfoot
			rows = wo.columns_thead !== false ? [ 'thead tr' ] : [];
			if (wo.columns_tfoot !== false) {
				rows.push('tfoot tr');
			}
			if (rows.length) {
				$rows = $table.find( rows.join(',') ).children().removeClass(remove);
				if (len) {
					for (indx = 0; indx < len; indx++) {
						// add primary. secondary, tertiary, etc sort column classes
						$rows.filter('[data-column="' + sortList[indx][0] + '"]').addClass(css[indx] || css[last]);
					}
				}
			}
		},
		remove: function(table, c, wo) {
			var tbodyIndex, $tbody,
				$tbodies = c.$tbodies,
				remove = (wo.columns || [ 'primary', 'secondary', 'tertiary' ]).join(' ');
			c.$headers.removeClass(remove);
			c.$table.children('tfoot').children('tr').children('th, td').removeClass(remove);
			for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true); // remove tbody
				$tbody.children('tr').each(function() {
					$(this).children().removeClass(remove);
				});
				ts.processTbody(table, $tbody, false); // restore tbody
			}
		}
	});

})(jQuery);

/*! Widget: filter - updated 2018-03-18 (v2.30.0) *//*
 * Requires tablesorter v2.8+ and jQuery 1.7+
 * by Rob Garrison
 */
;( function ( $ ) {
	'use strict';
	var tsf, tsfRegex,
		ts = $.tablesorter || {},
		tscss = ts.css,
		tskeyCodes = ts.keyCodes;

	$.extend( tscss, {
		filterRow      : 'tablesorter-filter-row',
		filter         : 'tablesorter-filter',
		filterDisabled : 'disabled',
		filterRowHide  : 'hideme'
	});

	$.extend( tskeyCodes, {
		backSpace : 8,
		escape : 27,
		space : 32,
		left : 37,
		down : 40
	});

	ts.addWidget({
		id: 'filter',
		priority: 50,
		options : {
			filter_cellFilter    : '',    // css class name added to the filter cell ( string or array )
			filter_childRows     : false, // if true, filter includes child row content in the search
			filter_childByColumn : false, // ( filter_childRows must be true ) if true = search child rows by column; false = search all child row text grouped
			filter_childWithSibs : true,  // if true, include matching child row siblings
			filter_columnAnyMatch: true,  // if true, allows using '#:{query}' in AnyMatch searches ( column:query )
			filter_columnFilters : true,  // if true, a filter will be added to the top of each table column
			filter_cssFilter     : '',    // css class name added to the filter row & each input in the row ( tablesorter-filter is ALWAYS added )
			filter_defaultAttrib : 'data-value', // data attribute in the header cell that contains the default filter value
			filter_defaultFilter : {},    // add a default column filter type '~{query}' to make fuzzy searches default; '{q1} AND {q2}' to make all searches use a logical AND.
			filter_excludeFilter : {},    // filters to exclude, per column
			filter_external      : '',    // jQuery selector string ( or jQuery object ) of external filters
			filter_filteredRow   : 'filtered', // class added to filtered rows; define in css with "display:none" to hide the filtered-out rows
			filter_filterLabel   : 'Filter "{{label}}" column by...', // Aria-label added to filter input/select; see #1495
			filter_formatter     : null,  // add custom filter elements to the filter row
			filter_functions     : null,  // add custom filter functions using this option
			filter_hideEmpty     : true,  // hide filter row when table is empty
			filter_hideFilters   : false, // collapse filter row when mouse leaves the area
			filter_ignoreCase    : true,  // if true, make all searches case-insensitive
			filter_liveSearch    : true,  // if true, search column content while the user types ( with a delay )
			filter_matchType     : { 'input': 'exact', 'select': 'exact' }, // global query settings ('exact' or 'match'); overridden by "filter-match" or "filter-exact" class
			filter_onlyAvail     : 'filter-onlyAvail', // a header with a select dropdown & this class name will only show available ( visible ) options within the drop down
			filter_placeholder   : { search : '', select : '' }, // default placeholder text ( overridden by any header 'data-placeholder' setting )
			filter_reset         : null,  // jQuery selector string of an element used to reset the filters
			filter_resetOnEsc    : true,  // Reset filter input when the user presses escape - normalized across browsers
			filter_saveFilters   : false, // Use the $.tablesorter.storage utility to save the most recent filters
			filter_searchDelay   : 300,   // typing delay in milliseconds before starting a search
			filter_searchFiltered: true,  // allow searching through already filtered rows in special circumstances; will speed up searching in large tables if true
			filter_selectSource  : null,  // include a function to return an array of values to be added to the column filter select
			filter_selectSourceSeparator : '|', // filter_selectSource array text left of the separator is added to the option value, right into the option text
			filter_serversideFiltering : false, // if true, must perform server-side filtering b/c client-side filtering is disabled, but the ui and events will still be used.
			filter_startsWith    : false, // if true, filter start from the beginning of the cell contents
			filter_useParsedData : false  // filter all data using parsed content
		},
		format: function( table, c, wo ) {
			if ( !c.$table.hasClass( 'hasFilters' ) ) {
				tsf.init( table, c, wo );
			}
		},
		remove: function( table, c, wo, refreshing ) {
			var tbodyIndex, $tbody,
				$table = c.$table,
				$tbodies = c.$tbodies,
				events = (
					'addRows updateCell update updateRows updateComplete appendCache filterReset ' +
					'filterAndSortReset filterFomatterUpdate filterEnd search stickyHeadersInit '
				).split( ' ' ).join( c.namespace + 'filter ' );
			$table
				.removeClass( 'hasFilters' )
				// add filter namespace to all BUT search
				.unbind( events.replace( ts.regex.spaces, ' ' ) )
				// remove the filter row even if refreshing, because the column might have been moved
				.find( '.' + tscss.filterRow ).remove();
			wo.filter_initialized = false;
			if ( refreshing ) { return; }
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody
				$tbody.children().removeClass( wo.filter_filteredRow ).show();
				ts.processTbody( table, $tbody, false ); // restore tbody
			}
			if ( wo.filter_reset ) {
				$( document ).undelegate( wo.filter_reset, 'click' + c.namespace + 'filter' );
			}
		}
	});

	tsf = ts.filter = {

		// regex used in filter 'check' functions - not for general use and not documented
		regex: {
			regex     : /^\/((?:\\\/|[^\/])+)\/([migyu]{0,5})?$/, // regex to test for regex
			child     : /tablesorter-childRow/, // child row class name; this gets updated in the script
			filtered  : /filtered/, // filtered (hidden) row class name; updated in the script
			type      : /undefined|number/, // check type
			exact     : /(^[\"\'=]+)|([\"\'=]+$)/g, // exact match (allow '==')
			operators : /[<>=]/g, // replace operators
			query     : '(q|query)', // replace filter queries
			wild01    : /\?/g, // wild card match 0 or 1
			wild0More : /\*/g, // wild care match 0 or more
			quote     : /\"/g,
			isNeg1    : /(>=?\s*-\d)/,
			isNeg2    : /(<=?\s*\d)/
		},
		// function( c, data ) { }
		// c = table.config
		// data.$row = jQuery object of the row currently being processed
		// data.$cells = jQuery object of all cells within the current row
		// data.filters = array of filters for all columns ( some may be undefined )
		// data.filter = filter for the current column
		// data.iFilter = same as data.filter, except lowercase ( if wo.filter_ignoreCase is true )
		// data.exact = table cell text ( or parsed data if column parser enabled; may be a number & not a string )
		// data.iExact = same as data.exact, except lowercase ( if wo.filter_ignoreCase is true; may be a number & not a string )
		// data.cache = table cell text from cache, so it has been parsed ( & in all lower case if c.ignoreCase is true )
		// data.cacheArray = An array of parsed content from each table cell in the row being processed
		// data.index = column index; table = table element ( DOM )
		// data.parsed = array ( by column ) of boolean values ( from filter_useParsedData or 'filter-parsed' class )
		types: {
			or : function( c, data, vars ) {
				// look for "|", but not if it is inside of a regular expression
				if ( ( tsfRegex.orTest.test( data.iFilter ) || tsfRegex.orSplit.test( data.filter ) ) &&
					// this test for regex has potential to slow down the overall search
					!tsfRegex.regex.test( data.filter ) ) {
					var indx, filterMatched, query, regex,
						// duplicate data but split filter
						data2 = $.extend( {}, data ),
						filter = data.filter.split( tsfRegex.orSplit ),
						iFilter = data.iFilter.split( tsfRegex.orSplit ),
						len = filter.length;
					for ( indx = 0; indx < len; indx++ ) {
						data2.nestedFilters = true;
						data2.filter = '' + ( tsf.parseFilter( c, filter[ indx ], data ) || '' );
						data2.iFilter = '' + ( tsf.parseFilter( c, iFilter[ indx ], data ) || '' );
						query = '(' + ( tsf.parseFilter( c, data2.filter, data ) || '' ) + ')';
						try {
							// use try/catch, because query may not be a valid regex if "|" is contained within a partial regex search,
							// e.g "/(Alex|Aar" -> Uncaught SyntaxError: Invalid regular expression: /(/(Alex)/: Unterminated group
							regex = new RegExp( data.isMatch ? query : '^' + query + '$', c.widgetOptions.filter_ignoreCase ? 'i' : '' );
							// filterMatched = data2.filter === '' && indx > 0 ? true
							// look for an exact match with the 'or' unless the 'filter-match' class is found
							filterMatched = regex.test( data2.exact ) || tsf.processTypes( c, data2, vars );
							if ( filterMatched ) {
								return filterMatched;
							}
						} catch ( error ) {
							return null;
						}
					}
					// may be null from processing types
					return filterMatched || false;
				}
				return null;
			},
			// Look for an AND or && operator ( logical and )
			and : function( c, data, vars ) {
				if ( tsfRegex.andTest.test( data.filter ) ) {
					var indx, filterMatched, result, query, regex,
						// duplicate data but split filter
						data2 = $.extend( {}, data ),
						filter = data.filter.split( tsfRegex.andSplit ),
						iFilter = data.iFilter.split( tsfRegex.andSplit ),
						len = filter.length;
					for ( indx = 0; indx < len; indx++ ) {
						data2.nestedFilters = true;
						data2.filter = '' + ( tsf.parseFilter( c, filter[ indx ], data ) || '' );
						data2.iFilter = '' + ( tsf.parseFilter( c, iFilter[ indx ], data ) || '' );
						query = ( '(' + ( tsf.parseFilter( c, data2.filter, data ) || '' ) + ')' )
							// replace wild cards since /(a*)/i will match anything
							.replace( tsfRegex.wild01, '\\S{1}' ).replace( tsfRegex.wild0More, '\\S*' );
						try {
							// use try/catch just in case RegExp is invalid
							regex = new RegExp( data.isMatch ? query : '^' + query + '$', c.widgetOptions.filter_ignoreCase ? 'i' : '' );
							// look for an exact match with the 'and' unless the 'filter-match' class is found
							result = ( regex.test( data2.exact ) || tsf.processTypes( c, data2, vars ) );
							if ( indx === 0 ) {
								filterMatched = result;
							} else {
								filterMatched = filterMatched && result;
							}
						} catch ( error ) {
							return null;
						}
					}
					// may be null from processing types
					return filterMatched || false;
				}
				return null;
			},
			// Look for regex
			regex: function( c, data ) {
				if ( tsfRegex.regex.test( data.filter ) ) {
					var matches,
						// cache regex per column for optimal speed
						regex = data.filter_regexCache[ data.index ] || tsfRegex.regex.exec( data.filter ),
						isRegex = regex instanceof RegExp;
					try {
						if ( !isRegex ) {
							// force case insensitive search if ignoreCase option set?
							// if ( c.ignoreCase && !regex[2] ) { regex[2] = 'i'; }
							data.filter_regexCache[ data.index ] = regex = new RegExp( regex[1], regex[2] );
						}
						matches = regex.test( data.exact );
					} catch ( error ) {
						matches = false;
					}
					return matches;
				}
				return null;
			},
			// Look for operators >, >=, < or <=
			operators: function( c, data ) {
				// ignore empty strings... because '' < 10 is true
				if ( tsfRegex.operTest.test( data.iFilter ) && data.iExact !== '' ) {
					var cachedValue, result, txt,
						table = c.table,
						parsed = data.parsed[ data.index ],
						query = ts.formatFloat( data.iFilter.replace( tsfRegex.operators, '' ), table ),
						parser = c.parsers[ data.index ] || {},
						savedSearch = query;
					// parse filter value in case we're comparing numbers ( dates )
					if ( parsed || parser.type === 'numeric' ) {
						txt = $.trim( '' + data.iFilter.replace( tsfRegex.operators, '' ) );
						result = tsf.parseFilter( c, txt, data, true );
						query = ( typeof result === 'number' && result !== '' && !isNaN( result ) ) ? result : query;
					}
					// iExact may be numeric - see issue #149;
					// check if cached is defined, because sometimes j goes out of range? ( numeric columns )
					if ( ( parsed || parser.type === 'numeric' ) && !isNaN( query ) &&
						typeof data.cache !== 'undefined' ) {
						cachedValue = data.cache;
					} else {
						txt = isNaN( data.iExact ) ? data.iExact.replace( ts.regex.nondigit, '' ) : data.iExact;
						cachedValue = ts.formatFloat( txt, table );
					}
					if ( tsfRegex.gtTest.test( data.iFilter ) ) {
						result = tsfRegex.gteTest.test( data.iFilter ) ? cachedValue >= query : cachedValue > query;
					} else if ( tsfRegex.ltTest.test( data.iFilter ) ) {
						result = tsfRegex.lteTest.test( data.iFilter ) ? cachedValue <= query : cachedValue < query;
					}
					// keep showing all rows if nothing follows the operator
					if ( !result && savedSearch === '' ) {
						result = true;
					}
					return result;
				}
				return null;
			},
			// Look for a not match
			notMatch: function( c, data ) {
				if ( tsfRegex.notTest.test( data.iFilter ) ) {
					var indx,
						txt = data.iFilter.replace( '!', '' ),
						filter = tsf.parseFilter( c, txt, data ) || '';
					if ( tsfRegex.exact.test( filter ) ) {
						// look for exact not matches - see #628
						filter = filter.replace( tsfRegex.exact, '' );
						return filter === '' ? true : $.trim( filter ) !== data.iExact;
					} else {
						indx = data.iExact.search( $.trim( filter ) );
						return filter === '' ? true :
							// return true if not found
							data.anyMatch ? indx < 0 :
							// return false if found
							!( c.widgetOptions.filter_startsWith ? indx === 0 : indx >= 0 );
					}
				}
				return null;
			},
			// Look for quotes or equals to get an exact match; ignore type since iExact could be numeric
			exact: function( c, data ) {
				/*jshint eqeqeq:false */
				if ( tsfRegex.exact.test( data.iFilter ) ) {
					var txt = data.iFilter.replace( tsfRegex.exact, '' ),
						filter = tsf.parseFilter( c, txt, data ) || '';
					// eslint-disable-next-line eqeqeq
					return data.anyMatch ? $.inArray( filter, data.rowArray ) >= 0 : filter == data.iExact;
				}
				return null;
			},
			// Look for a range ( using ' to ' or ' - ' ) - see issue #166; thanks matzhu!
			range : function( c, data ) {
				if ( tsfRegex.toTest.test( data.iFilter ) ) {
					var result, tmp, range1, range2,
						table = c.table,
						index = data.index,
						parsed = data.parsed[index],
						// make sure the dash is for a range and not indicating a negative number
						query = data.iFilter.split( tsfRegex.toSplit );

					tmp = query[0].replace( ts.regex.nondigit, '' ) || '';
					range1 = ts.formatFloat( tsf.parseFilter( c, tmp, data ), table );
					tmp = query[1].replace( ts.regex.nondigit, '' ) || '';
					range2 = ts.formatFloat( tsf.parseFilter( c, tmp, data ), table );
					// parse filter value in case we're comparing numbers ( dates )
					if ( parsed || c.parsers[ index ].type === 'numeric' ) {
						result = c.parsers[ index ].format( '' + query[0], table, c.$headers.eq( index ), index );
						range1 = ( result !== '' && !isNaN( result ) ) ? result : range1;
						result = c.parsers[ index ].format( '' + query[1], table, c.$headers.eq( index ), index );
						range2 = ( result !== '' && !isNaN( result ) ) ? result : range2;
					}
					if ( ( parsed || c.parsers[ index ].type === 'numeric' ) && !isNaN( range1 ) && !isNaN( range2 ) ) {
						result = data.cache;
					} else {
						tmp = isNaN( data.iExact ) ? data.iExact.replace( ts.regex.nondigit, '' ) : data.iExact;
						result = ts.formatFloat( tmp, table );
					}
					if ( range1 > range2 ) {
						tmp = range1; range1 = range2; range2 = tmp; // swap
					}
					return ( result >= range1 && result <= range2 ) || ( range1 === '' || range2 === '' );
				}
				return null;
			},
			// Look for wild card: ? = single, * = multiple, or | = logical OR
			wild : function( c, data ) {
				if ( tsfRegex.wildOrTest.test( data.iFilter ) ) {
					var query = '' + ( tsf.parseFilter( c, data.iFilter, data ) || '' );
					// look for an exact match with the 'or' unless the 'filter-match' class is found
					if ( !tsfRegex.wildTest.test( query ) && data.nestedFilters ) {
						query = data.isMatch ? query : '^(' + query + ')$';
					}
					// parsing the filter may not work properly when using wildcards =/
					try {
						return new RegExp(
							query.replace( tsfRegex.wild01, '\\S{1}' ).replace( tsfRegex.wild0More, '\\S*' ),
							c.widgetOptions.filter_ignoreCase ? 'i' : ''
						)
						.test( data.exact );
					} catch ( error ) {
						return null;
					}
				}
				return null;
			},
			// fuzzy text search; modified from https://github.com/mattyork/fuzzy ( MIT license )
			fuzzy: function( c, data ) {
				if ( tsfRegex.fuzzyTest.test( data.iFilter ) ) {
					var indx,
						patternIndx = 0,
						len = data.iExact.length,
						txt = data.iFilter.slice( 1 ),
						pattern = tsf.parseFilter( c, txt, data ) || '';
					for ( indx = 0; indx < len; indx++ ) {
						if ( data.iExact[ indx ] === pattern[ patternIndx ] ) {
							patternIndx += 1;
						}
					}
					return patternIndx === pattern.length;
				}
				return null;
			}
		},
		init: function( table ) {
			// filter language options
			ts.language = $.extend( true, {}, {
				to  : 'to',
				or  : 'or',
				and : 'and'
			}, ts.language );

			var options, string, txt, $header, column, val, fxn, noSelect,
				c = table.config,
				wo = c.widgetOptions,
				processStr = function(prefix, str, suffix) {
					str = str.trim();
					// don't include prefix/suffix if str is empty
					return str === '' ? '' : (prefix || '') + str + (suffix || '');
				};
			c.$table.addClass( 'hasFilters' );
			c.lastSearch = [];

			// define timers so using clearTimeout won't cause an undefined error
			wo.filter_searchTimer = null;
			wo.filter_initTimer = null;
			wo.filter_formatterCount = 0;
			wo.filter_formatterInit = [];
			wo.filter_anyColumnSelector = '[data-column="all"],[data-column="any"]';
			wo.filter_multipleColumnSelector = '[data-column*="-"],[data-column*=","]';

			val = '\\{' + tsfRegex.query + '\\}';
			$.extend( tsfRegex, {
				child : new RegExp( c.cssChildRow ),
				filtered : new RegExp( wo.filter_filteredRow ),
				alreadyFiltered : new RegExp( '(\\s+(-' + processStr('|', ts.language.or) + processStr('|', ts.language.to) + ')\\s+)', 'i' ),
				toTest : new RegExp( '\\s+(-' + processStr('|', ts.language.to) + ')\\s+', 'i' ),
				toSplit : new RegExp( '(?:\\s+(?:-' + processStr('|', ts.language.to) + ')\\s+)', 'gi' ),
				andTest : new RegExp( '\\s+(' + processStr('', ts.language.and, '|') + '&&)\\s+', 'i' ),
				andSplit : new RegExp( '(?:\\s+(?:' + processStr('', ts.language.and, '|') + '&&)\\s+)', 'gi' ),
				orTest : new RegExp( '(\\|' + processStr('|\\s+', ts.language.or, '\\s+') + ')', 'i' ),
				orSplit : new RegExp( '(?:\\|' + processStr('|\\s+(?:', ts.language.or, ')\\s+') + ')', 'gi' ),
				iQuery : new RegExp( val, 'i' ),
				igQuery : new RegExp( val, 'ig' ),
				operTest : /^[<>]=?/,
				gtTest  : />/,
				gteTest : />=/,
				ltTest  : /</,
				lteTest : /<=/,
				notTest : /^\!/,
				wildOrTest : /[\?\*\|]/,
				wildTest : /\?\*/,
				fuzzyTest : /^~/,
				exactTest : /[=\"\|!]/
			});

			// don't build filter row if columnFilters is false or all columns are set to 'filter-false'
			// see issue #156
			val = c.$headers.filter( '.filter-false, .parser-false' ).length;
			if ( wo.filter_columnFilters !== false && val !== c.$headers.length ) {
				// build filter row
				tsf.buildRow( table, c, wo );
			}

			txt = 'addRows updateCell update updateRows updateComplete appendCache filterReset ' +
				'filterAndSortReset filterResetSaved filterEnd search '.split( ' ' ).join( c.namespace + 'filter ' );
			c.$table.bind( txt, function( event, filter ) {
				val = wo.filter_hideEmpty &&
					$.isEmptyObject( c.cache ) &&
					!( c.delayInit && event.type === 'appendCache' );
				// hide filter row using the 'filtered' class name
				c.$table.find( '.' + tscss.filterRow ).toggleClass( wo.filter_filteredRow, val ); // fixes #450
				if ( !/(search|filter)/.test( event.type ) ) {
					event.stopPropagation();
					tsf.buildDefault( table, true );
				}
				// Add filterAndSortReset - see #1361
				if ( event.type === 'filterReset' || event.type === 'filterAndSortReset' ) {
					c.$table.find( '.' + tscss.filter ).add( wo.filter_$externalFilters ).val( '' );
					if ( event.type === 'filterAndSortReset' ) {
						ts.sortReset( this.config, function() {
							tsf.searching( table, [] );
						});
					} else {
						tsf.searching( table, [] );
					}
				} else if ( event.type === 'filterResetSaved' ) {
					ts.storage( table, 'tablesorter-filters', '' );
				} else if ( event.type === 'filterEnd' ) {
					tsf.buildDefault( table, true );
				} else {
					// send false argument to force a new search; otherwise if the filter hasn't changed,
					// it will return
					filter = event.type === 'search' ? filter :
						event.type === 'updateComplete' ? c.$table.data( 'lastSearch' ) : '';
					if ( /(update|add)/.test( event.type ) && event.type !== 'updateComplete' ) {
						// force a new search since content has changed
						c.lastCombinedFilter = null;
						c.lastSearch = [];
						// update filterFormatters after update (& small delay) - Fixes #1237
						setTimeout(function() {
							c.$table.triggerHandler( 'filterFomatterUpdate' );
						}, 100);
					}
					// pass true ( skipFirst ) to prevent the tablesorter.setFilters function from skipping the first
					// input ensures all inputs are updated when a search is triggered on the table
					// $( 'table' ).trigger( 'search', [...] );
					tsf.searching( table, filter, true );
				}
				return false;
			});

			// reset button/link
			if ( wo.filter_reset ) {
				if ( wo.filter_reset instanceof $ ) {
					// reset contains a jQuery object, bind to it
					wo.filter_reset.click( function() {
						c.$table.triggerHandler( 'filterReset' );
					});
				} else if ( $( wo.filter_reset ).length ) {
					// reset is a jQuery selector, use event delegation
					$( document )
						.undelegate( wo.filter_reset, 'click' + c.namespace + 'filter' )
						.delegate( wo.filter_reset, 'click' + c.namespace + 'filter', function() {
							// trigger a reset event, so other functions ( filter_formatter ) know when to reset
							c.$table.triggerHandler( 'filterReset' );
						});
				}
			}
			if ( wo.filter_functions ) {
				for ( column = 0; column < c.columns; column++ ) {
					fxn = ts.getColumnData( table, wo.filter_functions, column );
					if ( fxn ) {
						// remove 'filter-select' from header otherwise the options added here are replaced with
						// all options
						$header = c.$headerIndexed[ column ].removeClass( 'filter-select' );
						// don't build select if 'filter-false' or 'parser-false' set
						noSelect = !( $header.hasClass( 'filter-false' ) || $header.hasClass( 'parser-false' ) );
						options = '';
						if ( fxn === true && noSelect ) {
							tsf.buildSelect( table, column );
						} else if ( typeof fxn === 'object' && noSelect ) {
							// add custom drop down list
							for ( string in fxn ) {
								if ( typeof string === 'string' ) {
									options += options === '' ?
										'<option value="">' +
											( $header.data( 'placeholder' ) ||
												$header.attr( 'data-placeholder' ) ||
												wo.filter_placeholder.select ||
												''
											) +
										'</option>' : '';
									val = string;
									txt = string;
									if ( string.indexOf( wo.filter_selectSourceSeparator ) >= 0 ) {
										val = string.split( wo.filter_selectSourceSeparator );
										txt = val[1];
										val = val[0];
									}
									options += '<option ' +
										( txt === val ? '' : 'data-function-name="' + string + '" ' ) +
										'value="' + val + '">' + txt + '</option>';
								}
							}
							c.$table
								.find( 'thead' )
								.find( 'select.' + tscss.filter + '[data-column="' + column + '"]' )
								.append( options );
							txt = wo.filter_selectSource;
							fxn = typeof txt === 'function' ? true : ts.getColumnData( table, txt, column );
							if ( fxn ) {
								// updating so the extra options are appended
								tsf.buildSelect( c.table, column, '', true, $header.hasClass( wo.filter_onlyAvail ) );
							}
						}
					}
				}
			}
			// not really updating, but if the column has both the 'filter-select' class &
			// filter_functions set to true, it would append the same options twice.
			tsf.buildDefault( table, true );

			tsf.bindSearch( table, c.$table.find( '.' + tscss.filter ), true );
			if ( wo.filter_external ) {
				tsf.bindSearch( table, wo.filter_external );
			}

			if ( wo.filter_hideFilters ) {
				tsf.hideFilters( c );
			}

			// show processing icon
			if ( c.showProcessing ) {
				txt = 'filterStart filterEnd '.split( ' ' ).join( c.namespace + 'filter-sp ' );
				c.$table
					.unbind( txt.replace( ts.regex.spaces, ' ' ) )
					.bind( txt, function( event, columns ) {
					// only add processing to certain columns to all columns
					$header = ( columns ) ?
						c.$table
							.find( '.' + tscss.header )
							.filter( '[data-column]' )
							.filter( function() {
								return columns[ $( this ).data( 'column' ) ] !== '';
							}) : '';
					ts.isProcessing( table, event.type === 'filterStart', columns ? $header : '' );
				});
			}

			// set filtered rows count ( intially unfiltered )
			c.filteredRows = c.totalRows;

			// add default values
			txt = 'tablesorter-initialized pagerBeforeInitialized '.split( ' ' ).join( c.namespace + 'filter ' );
			c.$table
			.unbind( txt.replace( ts.regex.spaces, ' ' ) )
			.bind( txt, function() {
				tsf.completeInit( this );
			});
			// if filter widget is added after pager has initialized; then set filter init flag
			if ( c.pager && c.pager.initialized && !wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterFomatterUpdate' );
				setTimeout( function() {
					tsf.filterInitComplete( c );
				}, 100 );
			} else if ( !wo.filter_initialized ) {
				tsf.completeInit( table );
			}
		},
		completeInit: function( table ) {
			// redefine 'c' & 'wo' so they update properly inside this callback
			var c = table.config,
				wo = c.widgetOptions,
				filters = tsf.setDefaults( table, c, wo ) || [];
			if ( filters.length ) {
				// prevent delayInit from triggering a cache build if filters are empty
				if ( !( c.delayInit && filters.join( '' ) === '' ) ) {
					ts.setFilters( table, filters, true );
				}
			}
			c.$table.triggerHandler( 'filterFomatterUpdate' );
			// trigger init after setTimeout to prevent multiple filterStart/End/Init triggers
			setTimeout( function() {
				if ( !wo.filter_initialized ) {
					tsf.filterInitComplete( c );
				}
			}, 100 );
		},

		// $cell parameter, but not the config, is passed to the filter_formatters,
		// so we have to work with it instead
		formatterUpdated: function( $cell, column ) {
			// prevent error if $cell is undefined - see #1056
			var $table = $cell && $cell.closest( 'table' );
			var config = $table.length && $table[0].config,
				wo = config && config.widgetOptions;
			if ( wo && !wo.filter_initialized ) {
				// add updates by column since this function
				// may be called numerous times before initialization
				wo.filter_formatterInit[ column ] = 1;
			}
		},
		filterInitComplete: function( c ) {
			var indx, len,
				wo = c.widgetOptions,
				count = 0,
				completed = function() {
					wo.filter_initialized = true;
					// update lastSearch - it gets cleared often
					c.lastSearch = c.$table.data( 'lastSearch' );
					c.$table.triggerHandler( 'filterInit', c );
					tsf.findRows( c.table, c.lastSearch || [] );
					if (ts.debug(c, 'filter')) {
						console.log('Filter >> Widget initialized');
					}
				};
			if ( $.isEmptyObject( wo.filter_formatter ) ) {
				completed();
			} else {
				len = wo.filter_formatterInit.length;
				for ( indx = 0; indx < len; indx++ ) {
					if ( wo.filter_formatterInit[ indx ] === 1 ) {
						count++;
					}
				}
				clearTimeout( wo.filter_initTimer );
				if ( !wo.filter_initialized && count === wo.filter_formatterCount ) {
					// filter widget initialized
					completed();
				} else if ( !wo.filter_initialized ) {
					// fall back in case a filter_formatter doesn't call
					// $.tablesorter.filter.formatterUpdated( $cell, column ), and the count is off
					wo.filter_initTimer = setTimeout( function() {
						completed();
					}, 500 );
				}
			}
		},
		// encode or decode filters for storage; see #1026
		processFilters: function( filters, encode ) {
			var indx,
				// fixes #1237; previously returning an encoded "filters" value
				result = [],
				mode = encode ? encodeURIComponent : decodeURIComponent,
				len = filters.length;
			for ( indx = 0; indx < len; indx++ ) {
				if ( filters[ indx ] ) {
					result[ indx ] = mode( filters[ indx ] );
				}
			}
			return result;
		},
		setDefaults: function( table, c, wo ) {
			var isArray, saved, indx, col, $filters,
				// get current ( default ) filters
				filters = ts.getFilters( table ) || [];
			if ( wo.filter_saveFilters && ts.storage ) {
				saved = ts.storage( table, 'tablesorter-filters' ) || [];
				isArray = $.isArray( saved );
				// make sure we're not just getting an empty array
				if ( !( isArray && saved.join( '' ) === '' || !isArray ) ) {
					filters = tsf.processFilters( saved );
				}
			}
			// if no filters saved, then check default settings
			if ( filters.join( '' ) === '' ) {
				// allow adding default setting to external filters
				$filters = c.$headers.add( wo.filter_$externalFilters )
					.filter( '[' + wo.filter_defaultAttrib + ']' );
				for ( indx = 0; indx <= c.columns; indx++ ) {
					// include data-column='all' external filters
					col = indx === c.columns ? 'all' : indx;
					filters[ indx ] = $filters
						.filter( '[data-column="' + col + '"]' )
						.attr( wo.filter_defaultAttrib ) || filters[indx] || '';
				}
			}
			c.$table.data( 'lastSearch', filters );
			return filters;
		},
		parseFilter: function( c, filter, data, parsed ) {
			return parsed || data.parsed[ data.index ] ?
				c.parsers[ data.index ].format( filter, c.table, [], data.index ) :
				filter;
		},
		buildRow: function( table, c, wo ) {
			var $filter, col, column, $header, makeSelect, disabled, name, ffxn, tmp,
				// c.columns defined in computeThIndexes()
				cellFilter = wo.filter_cellFilter,
				columns = c.columns,
				arry = $.isArray( cellFilter ),
				buildFilter = '<tr role="search" class="' + tscss.filterRow + ' ' + c.cssIgnoreRow + '">';
			for ( column = 0; column < columns; column++ ) {
				if ( c.$headerIndexed[ column ].length ) {
					// account for entire column set with colspan. See #1047
					tmp = c.$headerIndexed[ column ] && c.$headerIndexed[ column ][0].colSpan || 0;
					if ( tmp > 1 ) {
						buildFilter += '<td data-column="' + column + '-' + ( column + tmp - 1 ) + '" colspan="' + tmp + '"';
					} else {
						buildFilter += '<td data-column="' + column + '"';
					}
					if ( arry ) {
						buildFilter += ( cellFilter[ column ] ? ' class="' + cellFilter[ column ] + '"' : '' );
					} else {
						buildFilter += ( cellFilter !== '' ? ' class="' + cellFilter + '"' : '' );
					}
					buildFilter += '></td>';
				}
			}
			c.$filters = $( buildFilter += '</tr>' )
				.appendTo( c.$table.children( 'thead' ).eq( 0 ) )
				.children( 'td' );
			// build each filter input
			for ( column = 0; column < columns; column++ ) {
				disabled = false;
				// assuming last cell of a column is the main column
				$header = c.$headerIndexed[ column ];
				if ( $header && $header.length ) {
					// $filter = c.$filters.filter( '[data-column="' + column + '"]' );
					$filter = tsf.getColumnElm( c, c.$filters, column );
					ffxn = ts.getColumnData( table, wo.filter_functions, column );
					makeSelect = ( wo.filter_functions && ffxn && typeof ffxn !== 'function' ) ||
						$header.hasClass( 'filter-select' );
					// get data from jQuery data, metadata, headers option or header class name
					col = ts.getColumnData( table, c.headers, column );
					disabled = ts.getData( $header[0], col, 'filter' ) === 'false' ||
						ts.getData( $header[0], col, 'parser' ) === 'false';

					if ( makeSelect ) {
						buildFilter = $( '<select>' ).appendTo( $filter );
					} else {
						ffxn = ts.getColumnData( table, wo.filter_formatter, column );
						if ( ffxn ) {
							wo.filter_formatterCount++;
							buildFilter = ffxn( $filter, column );
							// no element returned, so lets go find it
							if ( buildFilter && buildFilter.length === 0 ) {
								buildFilter = $filter.children( 'input' );
							}
							// element not in DOM, so lets attach it
							if ( buildFilter && ( buildFilter.parent().length === 0 ||
								( buildFilter.parent().length && buildFilter.parent()[0] !== $filter[0] ) ) ) {
								$filter.append( buildFilter );
							}
						} else {
							buildFilter = $( '<input type="search">' ).appendTo( $filter );
						}
						if ( buildFilter ) {
							tmp = $header.data( 'placeholder' ) ||
								$header.attr( 'data-placeholder' ) ||
								wo.filter_placeholder.search || '';
							buildFilter.attr( 'placeholder', tmp );
						}
					}
					if ( buildFilter ) {
						// add filter class name
						name = ( $.isArray( wo.filter_cssFilter ) ?
							( typeof wo.filter_cssFilter[column] !== 'undefined' ? wo.filter_cssFilter[column] || '' : '' ) :
							wo.filter_cssFilter ) || '';
						// copy data-column from table cell (it will include colspan)
						buildFilter.addClass( tscss.filter + ' ' + name );
						name = wo.filter_filterLabel;
						tmp = name.match(/{{([^}]+?)}}/g);
						if (!tmp) {
							tmp = [ '{{label}}' ];
						}
						$.each(tmp, function(indx, attr) {
							var regex = new RegExp(attr, 'g'),
								data = $header.attr('data-' + attr.replace(/{{|}}/g, '')),
								text = typeof data === 'undefined' ? $header.text() : data;
							name = name.replace( regex, $.trim( text ) );
						});
						buildFilter.attr({
							'data-column': $filter.attr( 'data-column' ),
							'aria-label': name
						});
						if ( disabled ) {
							buildFilter.attr( 'placeholder', '' ).addClass( tscss.filterDisabled )[0].disabled = true;
						}
					}
				}
			}
		},
		bindSearch: function( table, $el, internal ) {
			table = $( table )[0];
			$el = $( $el ); // allow passing a selector string
			if ( !$el.length ) { return; }
			var tmp,
				c = table.config,
				wo = c.widgetOptions,
				namespace = c.namespace + 'filter',
				$ext = wo.filter_$externalFilters;
			if ( internal !== true ) {
				// save anyMatch element
				tmp = wo.filter_anyColumnSelector + ',' + wo.filter_multipleColumnSelector;
				wo.filter_$anyMatch = $el.filter( tmp );
				if ( $ext && $ext.length ) {
					wo.filter_$externalFilters = wo.filter_$externalFilters.add( $el );
				} else {
					wo.filter_$externalFilters = $el;
				}
				// update values ( external filters added after table initialization )
				ts.setFilters( table, c.$table.data( 'lastSearch' ) || [], internal === false );
			}
			// unbind events
			tmp = ( 'keypress keyup keydown search change input '.split( ' ' ).join( namespace + ' ' ) );
			$el
			// use data attribute instead of jQuery data since the head is cloned without including
			// the data/binding
			.attr( 'data-lastSearchTime', new Date().getTime() )
			.unbind( tmp.replace( ts.regex.spaces, ' ' ) )
			.bind( 'keydown' + namespace, function( event ) {
				if ( event.which === tskeyCodes.escape && !table.config.widgetOptions.filter_resetOnEsc ) {
					// prevent keypress event
					return false;
				}
			})
			.bind( 'keyup' + namespace, function( event ) {
				wo = table.config.widgetOptions; // make sure "wo" isn't cached
				var column = parseInt( $( this ).attr( 'data-column' ), 10 ),
					liveSearch = typeof wo.filter_liveSearch === 'boolean' ? wo.filter_liveSearch :
						ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( typeof liveSearch === 'undefined' ) {
					liveSearch = wo.filter_liveSearch.fallback || false;
				}
				$( this ).attr( 'data-lastSearchTime', new Date().getTime() );
				// emulate what webkit does.... escape clears the filter
				if ( event.which === tskeyCodes.escape ) {
					// make sure to restore the last value on escape
					this.value = wo.filter_resetOnEsc ? '' : c.lastSearch[column];
					// don't return if the search value is empty ( all rows need to be revealed )
				} else if ( this.value !== '' && (
					// liveSearch can contain a min value length; ignore arrow and meta keys, but allow backspace
					( typeof liveSearch === 'number' && this.value.length < liveSearch ) ||
					// let return & backspace continue on, but ignore arrows & non-valid characters
					( event.which !== tskeyCodes.enter && event.which !== tskeyCodes.backSpace &&
						( event.which < tskeyCodes.space || ( event.which >= tskeyCodes.left && event.which <= tskeyCodes.down ) ) ) ) ) {
					return;
					// live search
				} else if ( liveSearch === false ) {
					if ( this.value !== '' && event.which !== tskeyCodes.enter ) {
						return;
					}
				}
				// change event = no delay; last true flag tells getFilters to skip newest timed input
				tsf.searching( table, true, true, column );
			})
			// include change for select - fixes #473
			.bind( 'search change keypress input blur '.split( ' ' ).join( namespace + ' ' ), function( event ) {
				// don't get cached data, in case data-column changes dynamically
				var column = parseInt( $( this ).attr( 'data-column' ), 10 ),
					eventType = event.type,
					liveSearch = typeof wo.filter_liveSearch === 'boolean' ?
						wo.filter_liveSearch :
						ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( table.config.widgetOptions.filter_initialized &&
					// immediate search if user presses enter
					( event.which === tskeyCodes.enter ||
						// immediate search if a "search" or "blur" is triggered on the input
						( eventType === 'search' || eventType === 'blur' ) ||
						// change & input events must be ignored if liveSearch !== true
						( eventType === 'change' || eventType === 'input' ) &&
						// prevent search if liveSearch is a number
						( liveSearch === true || liveSearch !== true && event.target.nodeName !== 'INPUT' ) &&
						// don't allow 'change' or 'input' event to process if the input value
						// is the same - fixes #685
						this.value !== c.lastSearch[column]
					)
				) {
					event.preventDefault();
					// init search with no delay
					$( this ).attr( 'data-lastSearchTime', new Date().getTime() );
					tsf.searching( table, eventType !== 'keypress' || event.which === tskeyCodes.enter, true, column );
				}
			});
		},
		searching: function( table, filter, skipFirst, column ) {
			var liveSearch,
				wo = table.config.widgetOptions;
			if (typeof column === 'undefined') {
				// no delay
				liveSearch = false;
			} else {
				liveSearch = typeof wo.filter_liveSearch === 'boolean' ?
					wo.filter_liveSearch :
					// get column setting, or set to fallback value, or default to false
					ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( typeof liveSearch === 'undefined' ) {
					liveSearch = wo.filter_liveSearch.fallback || false;
				}
			}
			clearTimeout( wo.filter_searchTimer );
			if ( typeof filter === 'undefined' || filter === true ) {
				// delay filtering
				wo.filter_searchTimer = setTimeout( function() {
					tsf.checkFilters( table, filter, skipFirst );
				}, liveSearch ? wo.filter_searchDelay : 10 );
			} else {
				// skip delay
				tsf.checkFilters( table, filter, skipFirst );
			}
		},
		equalFilters: function (c, filter1, filter2) {
			var indx,
				f1 = [],
				f2 = [],
				len = c.columns + 1; // add one to include anyMatch filter
			filter1 = $.isArray(filter1) ? filter1 : [];
			filter2 = $.isArray(filter2) ? filter2 : [];
			for (indx = 0; indx < len; indx++) {
				f1[indx] = filter1[indx] || '';
				f2[indx] = filter2[indx] || '';
			}
			return f1.join(',') === f2.join(',');
		},
		checkFilters: function( table, filter, skipFirst ) {
			var c = table.config,
				wo = c.widgetOptions,
				filterArray = $.isArray( filter ),
				filters = ( filterArray ) ? filter : ts.getFilters( table, true ),
				currentFilters = filters || []; // current filter values
			// prevent errors if delay init is set
			if ( $.isEmptyObject( c.cache ) ) {
				// update cache if delayInit set & pager has initialized ( after user initiates a search )
				if ( c.delayInit && ( !c.pager || c.pager && c.pager.initialized ) ) {
					ts.updateCache( c, function() {
						tsf.checkFilters( table, false, skipFirst );
					});
				}
				return;
			}
			// add filter array back into inputs
			if ( filterArray ) {
				ts.setFilters( table, filters, false, skipFirst !== true );
				if ( !wo.filter_initialized ) {
					c.lastSearch = [];
					c.lastCombinedFilter = '';
				}
			}
			if ( wo.filter_hideFilters ) {
				// show/hide filter row as needed
				c.$table
					.find( '.' + tscss.filterRow )
					.triggerHandler( tsf.hideFiltersCheck( c ) ? 'mouseleave' : 'mouseenter' );
			}
			// return if the last search is the same; but filter === false when updating the search
			// see example-widget-filter.html filter toggle buttons
			if ( tsf.equalFilters(c, c.lastSearch, currentFilters) ) {
				if ( filter !== false ) {
					return;
				} else {
					// force filter refresh
					c.lastCombinedFilter = '';
					c.lastSearch = [];
				}
			}
			// define filter inside it is false
			filters = filters || [];
			// convert filters to strings - see #1070
			filters = Array.prototype.map ?
				filters.map( String ) :
				// for IE8 & older browsers - maybe not the best method
				filters.join( '\ufffd' ).split( '\ufffd' );

			if ( wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterStart', [ filters ] );
			}
			if ( c.showProcessing ) {
				// give it time for the processing icon to kick in
				setTimeout( function() {
					tsf.findRows( table, filters, currentFilters );
					return false;
				}, 30 );
			} else {
				tsf.findRows( table, filters, currentFilters );
				return false;
			}
		},
		hideFiltersCheck: function( c ) {
			if (typeof c.widgetOptions.filter_hideFilters === 'function') {
				var val = c.widgetOptions.filter_hideFilters( c );
				if (typeof val === 'boolean') {
					return val;
				}
			}
			return ts.getFilters( c.$table ).join( '' ) === '';
		},
		hideFilters: function( c, $table ) {
			var timer;
			( $table || c.$table )
				.find( '.' + tscss.filterRow )
				.addClass( tscss.filterRowHide )
				.bind( 'mouseenter mouseleave', function( e ) {
					// save event object - http://bugs.jquery.com/ticket/12140
					var event = e,
						$row = $( this );
					clearTimeout( timer );
					timer = setTimeout( function() {
						if ( /enter|over/.test( event.type ) ) {
							$row.removeClass( tscss.filterRowHide );
						} else {
							// don't hide if input has focus
							// $( ':focus' ) needs jQuery 1.6+
							if ( $( document.activeElement ).closest( 'tr' )[0] !== $row[0] ) {
								// don't hide row if any filter has a value
								$row.toggleClass( tscss.filterRowHide, tsf.hideFiltersCheck( c ) );
							}
						}
					}, 200 );
				})
				.find( 'input, select' ).bind( 'focus blur', function( e ) {
					var event = e,
						$row = $( this ).closest( 'tr' );
					clearTimeout( timer );
					timer = setTimeout( function() {
						clearTimeout( timer );
						// don't hide row if any filter has a value
						$row.toggleClass( tscss.filterRowHide, tsf.hideFiltersCheck( c ) && event.type !== 'focus' );
					}, 200 );
				});
		},
		defaultFilter: function( filter, mask ) {
			if ( filter === '' ) { return filter; }
			var regex = tsfRegex.iQuery,
				maskLen = mask.match( tsfRegex.igQuery ).length,
				query = maskLen > 1 ? $.trim( filter ).split( /\s/ ) : [ $.trim( filter ) ],
				len = query.length - 1,
				indx = 0,
				val = mask;
			if ( len < 1 && maskLen > 1 ) {
				// only one 'word' in query but mask has >1 slots
				query[1] = query[0];
			}
			// replace all {query} with query words...
			// if query = 'Bob', then convert mask from '!{query}' to '!Bob'
			// if query = 'Bob Joe Frank', then convert mask '{q} OR {q}' to 'Bob OR Joe OR Frank'
			while ( regex.test( val ) ) {
				val = val.replace( regex, query[indx++] || '' );
				if ( regex.test( val ) && indx < len && ( query[indx] || '' ) !== '' ) {
					val = mask.replace( regex, val );
				}
			}
			return val;
		},
		getLatestSearch: function( $input ) {
			if ( $input ) {
				return $input.sort( function( a, b ) {
					return $( b ).attr( 'data-lastSearchTime' ) - $( a ).attr( 'data-lastSearchTime' );
				});
			}
			return $input || $();
		},
		findRange: function( c, val, ignoreRanges ) {
			// look for multiple columns '1-3,4-6,8' in data-column
			var temp, ranges, range, start, end, singles, i, indx, len,
				columns = [];
			if ( /^[0-9]+$/.test( val ) ) {
				// always return an array
				return [ parseInt( val, 10 ) ];
			}
			// process column range
			if ( !ignoreRanges && /-/.test( val ) ) {
				ranges = val.match( /(\d+)\s*-\s*(\d+)/g );
				len = ranges ? ranges.length : 0;
				for ( indx = 0; indx < len; indx++ ) {
					range = ranges[indx].split( /\s*-\s*/ );
					start = parseInt( range[0], 10 ) || 0;
					end = parseInt( range[1], 10 ) || ( c.columns - 1 );
					if ( start > end ) {
						temp = start; start = end; end = temp; // swap
					}
					if ( end >= c.columns ) {
						end = c.columns - 1;
					}
					for ( ; start <= end; start++ ) {
						columns[ columns.length ] = start;
					}
					// remove processed range from val
					val = val.replace( ranges[ indx ], '' );
				}
			}
			// process single columns
			if ( !ignoreRanges && /,/.test( val ) ) {
				singles = val.split( /\s*,\s*/ );
				len = singles.length;
				for ( i = 0; i < len; i++ ) {
					if ( singles[ i ] !== '' ) {
						indx = parseInt( singles[ i ], 10 );
						if ( indx < c.columns ) {
							columns[ columns.length ] = indx;
						}
					}
				}
			}
			// return all columns
			if ( !columns.length ) {
				for ( indx = 0; indx < c.columns; indx++ ) {
					columns[ columns.length ] = indx;
				}
			}
			return columns;
		},
		getColumnElm: function( c, $elements, column ) {
			// data-column may contain multiple columns '1-3,5-6,8'
			// replaces: c.$filters.filter( '[data-column="' + column + '"]' );
			return $elements.filter( function() {
				var cols = tsf.findRange( c, $( this ).attr( 'data-column' ) );
				return $.inArray( column, cols ) > -1;
			});
		},
		multipleColumns: function( c, $input ) {
			// look for multiple columns '1-3,4-6,8' in data-column
			var wo = c.widgetOptions,
				// only target 'all' column inputs on initialization
				// & don't target 'all' column inputs if they don't exist
				targets = wo.filter_initialized || !$input.filter( wo.filter_anyColumnSelector ).length,
				val = $.trim( tsf.getLatestSearch( $input ).attr( 'data-column' ) || '' );
			return tsf.findRange( c, val, !targets );
		},
		processTypes: function( c, data, vars ) {
			var ffxn,
				filterMatched = null,
				matches = null;
			for ( ffxn in tsf.types ) {
				if ( $.inArray( ffxn, vars.excludeMatch ) < 0 && matches === null ) {
					matches = tsf.types[ffxn]( c, data, vars );
					if ( matches !== null ) {
						data.matchedOn = ffxn;
						filterMatched = matches;
					}
				}
			}
			return filterMatched;
		},
		matchType: function( c, columnIndex ) {
			var isMatch,
				wo = c.widgetOptions,
				$el = c.$headerIndexed[ columnIndex ];
			// filter-exact > filter-match > filter_matchType for type
			if ( $el.hasClass( 'filter-exact' ) ) {
				isMatch = false;
			} else if ( $el.hasClass( 'filter-match' ) ) {
				isMatch = true;
			} else {
				// filter-select is not applied when filter_functions are used, so look for a select
				if ( wo.filter_columnFilters ) {
					$el = c.$filters
						.find( '.' + tscss.filter )
						.add( wo.filter_$externalFilters )
						.filter( '[data-column="' + columnIndex + '"]' );
				} else if ( wo.filter_$externalFilters ) {
					$el = wo.filter_$externalFilters.filter( '[data-column="' + columnIndex + '"]' );
				}
				isMatch = $el.length ?
					c.widgetOptions.filter_matchType[ ( $el[ 0 ].nodeName || '' ).toLowerCase() ] === 'match' :
					// default to exact, if no inputs found
					false;
			}
			return isMatch;
		},
		processRow: function( c, data, vars ) {
			var result, filterMatched,
				fxn, ffxn, txt,
				wo = c.widgetOptions,
				showRow = true,
				hasAnyMatchInput = wo.filter_$anyMatch && wo.filter_$anyMatch.length,

				// if wo.filter_$anyMatch data-column attribute is changed dynamically
				// we don't want to do an "anyMatch" search on one column using data
				// for the entire row - see #998
				columnIndex = wo.filter_$anyMatch && wo.filter_$anyMatch.length ?
					// look for multiple columns '1-3,4-6,8'
					tsf.multipleColumns( c, wo.filter_$anyMatch ) :
					[];
			data.$cells = data.$row.children();
			data.matchedOn = null;
			if ( data.anyMatchFlag && columnIndex.length > 1 || ( data.anyMatchFilter && !hasAnyMatchInput ) ) {
				data.anyMatch = true;
				data.isMatch = true;
				data.rowArray = data.$cells.map( function( i ) {
					if ( $.inArray( i, columnIndex ) > -1 || ( data.anyMatchFilter && !hasAnyMatchInput ) ) {
						if ( data.parsed[ i ] ) {
							txt = data.cacheArray[ i ];
						} else {
							txt = data.rawArray[ i ];
							txt = $.trim( wo.filter_ignoreCase ? txt.toLowerCase() : txt );
							if ( c.sortLocaleCompare ) {
								txt = ts.replaceAccents( txt );
							}
						}
						return txt;
					}
				}).get();
				data.filter = data.anyMatchFilter;
				data.iFilter = data.iAnyMatchFilter;
				data.exact = data.rowArray.join( ' ' );
				data.iExact = wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
				data.cache = data.cacheArray.slice( 0, -1 ).join( ' ' );
				vars.excludeMatch = vars.noAnyMatch;
				filterMatched = tsf.processTypes( c, data, vars );
				if ( filterMatched !== null ) {
					showRow = filterMatched;
				} else {
					if ( wo.filter_startsWith ) {
						showRow = false;
						// data.rowArray may not contain all columns
						columnIndex = Math.min( c.columns, data.rowArray.length );
						while ( !showRow && columnIndex > 0 ) {
							columnIndex--;
							showRow = showRow || data.rowArray[ columnIndex ].indexOf( data.iFilter ) === 0;
						}
					} else {
						showRow = ( data.iExact + data.childRowText ).indexOf( data.iFilter ) >= 0;
					}
				}
				data.anyMatch = false;
				// no other filters to process
				if ( data.filters.join( '' ) === data.filter ) {
					return showRow;
				}
			}

			for ( columnIndex = 0; columnIndex < c.columns; columnIndex++ ) {
				data.filter = data.filters[ columnIndex ];
				data.index = columnIndex;

				// filter types to exclude, per column
				vars.excludeMatch = vars.excludeFilter[ columnIndex ];

				// ignore if filter is empty or disabled
				if ( data.filter ) {
					data.cache = data.cacheArray[ columnIndex ];
					result = data.parsed[ columnIndex ] ? data.cache : data.rawArray[ columnIndex ] || '';
					data.exact = c.sortLocaleCompare ? ts.replaceAccents( result ) : result; // issue #405
					data.iExact = !tsfRegex.type.test( typeof data.exact ) && wo.filter_ignoreCase ?
						data.exact.toLowerCase() : data.exact;
					data.isMatch = tsf.matchType( c, columnIndex );

					result = showRow; // if showRow is true, show that row

					// in case select filter option has a different value vs text 'a - z|A through Z'
					ffxn = wo.filter_columnFilters ?
						c.$filters.add( wo.filter_$externalFilters )
							.filter( '[data-column="' + columnIndex + '"]' )
							.find( 'select option:selected' )
							.attr( 'data-function-name' ) || '' : '';
					// replace accents - see #357
					if ( c.sortLocaleCompare ) {
						data.filter = ts.replaceAccents( data.filter );
					}

					// replace column specific default filters - see #1088
					if ( wo.filter_defaultFilter && tsfRegex.iQuery.test( vars.defaultColFilter[ columnIndex ] ) ) {
						data.filter = tsf.defaultFilter( data.filter, vars.defaultColFilter[ columnIndex ] );
					}

					// data.iFilter = case insensitive ( if wo.filter_ignoreCase is true ),
					// data.filter = case sensitive
					data.iFilter = wo.filter_ignoreCase ? ( data.filter || '' ).toLowerCase() : data.filter;
					fxn = vars.functions[ columnIndex ];
					filterMatched = null;
					if ( fxn ) {
						if ( typeof fxn === 'function' ) {
							// filter callback( exact cell content, parser normalized content,
							// filter input value, column index, jQuery row object )
							filterMatched = fxn( data.exact, data.cache, data.filter, columnIndex, data.$row, c, data );
						} else if ( typeof fxn[ ffxn || data.filter ] === 'function' ) {
							// selector option function
							txt = ffxn || data.filter;
							filterMatched =
								fxn[ txt ]( data.exact, data.cache, data.filter, columnIndex, data.$row, c, data );
						}
					}
					if ( filterMatched === null ) {
						// cycle through the different filters
						// filters return a boolean or null if nothing matches
						filterMatched = tsf.processTypes( c, data, vars );
						// select with exact match; ignore "and" or "or" within the text; fixes #1486
						txt = fxn === true && (data.matchedOn === 'and' || data.matchedOn === 'or');
						if ( filterMatched !== null && !txt) {
							result = filterMatched;
						// Look for match, and add child row data for matching
						} else {
							// check fxn (filter-select in header) after filter types are checked
							// without this, the filter + jQuery UI selectmenu demo was breaking
							if ( fxn === true ) {
								// default selector uses exact match unless 'filter-match' class is found
								result = data.isMatch ?
									// data.iExact may be a number
									( '' + data.iExact ).search( data.iFilter ) >= 0 :
									data.filter === data.exact;
							} else {
								txt = ( data.iExact + data.childRowText ).indexOf( tsf.parseFilter( c, data.iFilter, data ) );
								result = ( ( !wo.filter_startsWith && txt >= 0 ) || ( wo.filter_startsWith && txt === 0 ) );
							}
						}
					} else {
						result = filterMatched;
					}
					showRow = ( result ) ? showRow : false;
				}
			}
			return showRow;
		},
		findRows: function( table, filters, currentFilters ) {
			if (
				tsf.equalFilters(table.config, table.config.lastSearch, currentFilters) ||
				!table.config.widgetOptions.filter_initialized
			) {
				return;
			}
			var len, norm_rows, rowData, $rows, $row, rowIndex, tbodyIndex, $tbody, columnIndex,
				isChild, childRow, lastSearch, showRow, showParent, time, val, indx,
				notFiltered, searchFiltered, query, injected, res, id, txt,
				storedFilters = $.extend( [], filters ),
				c = table.config,
				wo = c.widgetOptions,
				debug = ts.debug(c, 'filter'),
				// data object passed to filters; anyMatch is a flag for the filters
				data = {
					anyMatch: false,
					filters: filters,
					// regex filter type cache
					filter_regexCache : []
				},
				vars = {
					// anyMatch really screws up with these types of filters
					noAnyMatch: [ 'range',  'operators' ],
					// cache filter variables that use ts.getColumnData in the main loop
					functions : [],
					excludeFilter : [],
					defaultColFilter : [],
					defaultAnyFilter : ts.getColumnData( table, wo.filter_defaultFilter, c.columns, true ) || ''
				};
			// parse columns after formatter, in case the class is added at that point
			data.parsed = [];
			for ( columnIndex = 0; columnIndex < c.columns; columnIndex++ ) {
				data.parsed[ columnIndex ] = wo.filter_useParsedData ||
					// parser has a "parsed" parameter
					( c.parsers && c.parsers[ columnIndex ] && c.parsers[ columnIndex ].parsed ||
					// getData may not return 'parsed' if other 'filter-' class names exist
					// ( e.g. <th class="filter-select filter-parsed"> )
					ts.getData && ts.getData( c.$headerIndexed[ columnIndex ],
						ts.getColumnData( table, c.headers, columnIndex ), 'filter' ) === 'parsed' ||
					c.$headerIndexed[ columnIndex ].hasClass( 'filter-parsed' ) );

				vars.functions[ columnIndex ] =
					ts.getColumnData( table, wo.filter_functions, columnIndex ) ||
					c.$headerIndexed[ columnIndex ].hasClass( 'filter-select' );
				vars.defaultColFilter[ columnIndex ] =
					ts.getColumnData( table, wo.filter_defaultFilter, columnIndex ) || '';
				vars.excludeFilter[ columnIndex ] =
					( ts.getColumnData( table, wo.filter_excludeFilter, columnIndex, true ) || '' ).split( /\s+/ );
			}

			if ( debug ) {
				console.log( 'Filter >> Starting filter widget search', filters );
				time = new Date();
			}
			// filtered rows count
			c.filteredRows = 0;
			c.totalRows = 0;
			currentFilters = ( storedFilters || [] );

			for ( tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, c.$tbodies.eq( tbodyIndex ), true );
				// skip child rows & widget added ( removable ) rows - fixes #448 thanks to @hempel!
				// $rows = $tbody.children( 'tr' ).not( c.selectorRemove );
				columnIndex = c.columns;
				// convert stored rows into a jQuery object
				norm_rows = c.cache[ tbodyIndex ].normalized;
				$rows = $( $.map( norm_rows, function( el ) {
					return el[ columnIndex ].$row.get();
				}) );

				if ( currentFilters.join('') === '' || wo.filter_serversideFiltering ) {
					$rows
						.removeClass( wo.filter_filteredRow )
						.not( '.' + c.cssChildRow )
						.css( 'display', '' );
				} else {
					// filter out child rows
					$rows = $rows.not( '.' + c.cssChildRow );
					len = $rows.length;

					if ( ( wo.filter_$anyMatch && wo.filter_$anyMatch.length ) ||
						typeof filters[c.columns] !== 'undefined' ) {
						data.anyMatchFlag = true;
						data.anyMatchFilter = '' + (
							filters[ c.columns ] ||
							wo.filter_$anyMatch && tsf.getLatestSearch( wo.filter_$anyMatch ).val() ||
							''
						);
						if ( wo.filter_columnAnyMatch ) {
							// specific columns search
							query = data.anyMatchFilter.split( tsfRegex.andSplit );
							injected = false;
							for ( indx = 0; indx < query.length; indx++ ) {
								res = query[ indx ].split( ':' );
								if ( res.length > 1 ) {
									// make the column a one-based index ( non-developers start counting from one :P )
									if ( isNaN( res[0] ) ) {
										$.each( c.headerContent, function( i, txt ) {
											// multiple matches are possible
											if ( txt.toLowerCase().indexOf( res[0] ) > -1 ) {
												id = i;
												filters[ id ] = res[1];
											}
										});
									} else {
										id = parseInt( res[0], 10 ) - 1;
									}
									if ( id >= 0 && id < c.columns ) { // if id is an integer
										filters[ id ] = res[1];
										query.splice( indx, 1 );
										indx--;
										injected = true;
									}
								}
							}
							if ( injected ) {
								data.anyMatchFilter = query.join( ' && ' );
							}
						}
					}

					// optimize searching only through already filtered rows - see #313
					searchFiltered = wo.filter_searchFiltered;
					lastSearch = c.lastSearch || c.$table.data( 'lastSearch' ) || [];
					if ( searchFiltered ) {
						// cycle through all filters; include last ( columnIndex + 1 = match any column ). Fixes #669
						for ( indx = 0; indx < columnIndex + 1; indx++ ) {
							val = filters[indx] || '';
							// break out of loop if we've already determined not to search filtered rows
							if ( !searchFiltered ) { indx = columnIndex; }
							// search already filtered rows if...
							searchFiltered = searchFiltered && lastSearch.length &&
								// there are no changes from beginning of filter
								val.indexOf( lastSearch[indx] || '' ) === 0 &&
								// if there is NOT a logical 'or', or range ( 'to' or '-' ) in the string
								!tsfRegex.alreadyFiltered.test( val ) &&
								// if we are not doing exact matches, using '|' ( logical or ) or not '!'
								!tsfRegex.exactTest.test( val ) &&
								// don't search only filtered if the value is negative
								// ( '> -10' => '> -100' will ignore hidden rows )
								!( tsfRegex.isNeg1.test( val ) || tsfRegex.isNeg2.test( val ) ) &&
								// if filtering using a select without a 'filter-match' class ( exact match ) - fixes #593
								!( val !== '' && c.$filters && c.$filters.filter( '[data-column="' + indx + '"]' ).find( 'select' ).length &&
									!tsf.matchType( c, indx ) );
						}
					}
					notFiltered = $rows.not( '.' + wo.filter_filteredRow ).length;
					// can't search when all rows are hidden - this happens when looking for exact matches
					if ( searchFiltered && notFiltered === 0 ) { searchFiltered = false; }
					if ( debug ) {
						console.log( 'Filter >> Searching through ' +
							( searchFiltered && notFiltered < len ? notFiltered : 'all' ) + ' rows' );
					}
					if ( data.anyMatchFlag ) {
						if ( c.sortLocaleCompare ) {
							// replace accents
							data.anyMatchFilter = ts.replaceAccents( data.anyMatchFilter );
						}
						if ( wo.filter_defaultFilter && tsfRegex.iQuery.test( vars.defaultAnyFilter ) ) {
							data.anyMatchFilter = tsf.defaultFilter( data.anyMatchFilter, vars.defaultAnyFilter );
							// clear search filtered flag because default filters are not saved to the last search
							searchFiltered = false;
						}
						// make iAnyMatchFilter lowercase unless both filter widget & core ignoreCase options are true
						// when c.ignoreCase is true, the cache contains all lower case data
						data.iAnyMatchFilter = !( wo.filter_ignoreCase && c.ignoreCase ) ?
							data.anyMatchFilter :
							data.anyMatchFilter.toLowerCase();
					}

					// loop through the rows
					for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {

						txt = $rows[ rowIndex ].className;
						// the first row can never be a child row
						isChild = rowIndex && tsfRegex.child.test( txt );
						// skip child rows & already filtered rows
						if ( isChild || ( searchFiltered && tsfRegex.filtered.test( txt ) ) ) {
							continue;
						}

						data.$row = $rows.eq( rowIndex );
						data.rowIndex = rowIndex;
						data.cacheArray = norm_rows[ rowIndex ];
						rowData = data.cacheArray[ c.columns ];
						data.rawArray = rowData.raw;
						data.childRowText = '';

						if ( !wo.filter_childByColumn ) {
							txt = '';
							// child row cached text
							childRow = rowData.child;
							// so, if 'table.config.widgetOptions.filter_childRows' is true and there is
							// a match anywhere in the child row, then it will make the row visible
							// checked here so the option can be changed dynamically
							for ( indx = 0; indx < childRow.length; indx++ ) {
								txt += ' ' + childRow[indx].join( ' ' ) || 0;
							}
							data.childRowText = wo.filter_childRows ?
								( wo.filter_ignoreCase ? txt.toLowerCase() : txt ) :
								'';
						}

						showRow = false;
						showParent = tsf.processRow( c, data, vars );
						$row = rowData.$row;

						// don't pass reference to val
						val = showParent ? true : false;
						childRow = rowData.$row.filter( ':gt(0)' );
						if ( wo.filter_childRows && childRow.length ) {
							if ( wo.filter_childByColumn ) {
								if ( !wo.filter_childWithSibs ) {
									// hide all child rows
									childRow.addClass( wo.filter_filteredRow );
									// if only showing resulting child row, only include parent
									$row = $row.eq( 0 );
								}
								// cycle through each child row
								for ( indx = 0; indx < childRow.length; indx++ ) {
									data.$row = childRow.eq( indx );
									data.cacheArray = rowData.child[ indx ];
									data.rawArray = data.cacheArray;
									val = tsf.processRow( c, data, vars );
									// use OR comparison on child rows
									showRow = showRow || val;
									if ( !wo.filter_childWithSibs && val ) {
										childRow.eq( indx ).removeClass( wo.filter_filteredRow );
									}
								}
							}
							// keep parent row match even if no child matches... see #1020
							showRow = showRow || showParent;
						} else {
							showRow = val;
						}
						$row
							.toggleClass( wo.filter_filteredRow, !showRow )[0]
							.display = showRow ? '' : 'none';
					}
				}
				c.filteredRows += $rows.not( '.' + wo.filter_filteredRow ).length;
				c.totalRows += $rows.length;
				ts.processTbody( table, $tbody, false );
			}
			// lastCombinedFilter is no longer used internally
			c.lastCombinedFilter = storedFilters.join(''); // save last search
			// don't save 'filters' directly since it may have altered ( AnyMatch column searches )
			c.lastSearch = storedFilters;
			c.$table.data( 'lastSearch', storedFilters );
			if ( wo.filter_saveFilters && ts.storage ) {
				ts.storage( table, 'tablesorter-filters', tsf.processFilters( storedFilters, true ) );
			}
			if ( debug ) {
				console.log( 'Filter >> Completed search' + ts.benchmark(time) );
			}
			if ( wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterBeforeEnd', c );
				c.$table.triggerHandler( 'filterEnd', c );
			}
			setTimeout( function() {
				ts.applyWidget( c.table ); // make sure zebra widget is applied
			}, 0 );
		},
		getOptionSource: function( table, column, onlyAvail ) {
			table = $( table )[0];
			var c = table.config,
				wo = c.widgetOptions,
				arry = false,
				source = wo.filter_selectSource,
				last = c.$table.data( 'lastSearch' ) || [],
				fxn = typeof source === 'function' ? true : ts.getColumnData( table, source, column );

			if ( onlyAvail && last[column] !== '' ) {
				onlyAvail = false;
			}

			// filter select source option
			if ( fxn === true ) {
				// OVERALL source
				arry = source( table, column, onlyAvail );
			} else if ( fxn instanceof $ || ( $.type( fxn ) === 'string' && fxn.indexOf( '</option>' ) >= 0 ) ) {
				// selectSource is a jQuery object or string of options
				return fxn;
			} else if ( $.isArray( fxn ) ) {
				arry = fxn;
			} else if ( $.type( source ) === 'object' && fxn ) {
				// custom select source function for a SPECIFIC COLUMN
				arry = fxn( table, column, onlyAvail );
				// abort - updating the selects from an external method
				if (arry === null) {
					return null;
				}
			}
			if ( arry === false ) {
				// fall back to original method
				arry = tsf.getOptions( table, column, onlyAvail );
			}

			return tsf.processOptions( table, column, arry );

		},
		processOptions: function( table, column, arry ) {
			if ( !$.isArray( arry ) ) {
				return false;
			}
			table = $( table )[0];
			var cts, txt, indx, len, parsedTxt, str,
				c = table.config,
				validColumn = typeof column !== 'undefined' && column !== null && column >= 0 && column < c.columns,
				direction = validColumn ? c.$headerIndexed[ column ].hasClass( 'filter-select-sort-desc' ) : false,
				parsed = [];
			// get unique elements and sort the list
			// if $.tablesorter.sortText exists ( not in the original tablesorter ),
			// then natural sort the list otherwise use a basic sort
			arry = $.grep( arry, function( value, indx ) {
				if ( value.text ) {
					return true;
				}
				return $.inArray( value, arry ) === indx;
			});
			if ( validColumn && c.$headerIndexed[ column ].hasClass( 'filter-select-nosort' ) ) {
				// unsorted select options
				return arry;
			} else {
				len = arry.length;
				// parse select option values
				for ( indx = 0; indx < len; indx++ ) {
					txt = arry[ indx ];
					// check for object
					str = txt.text ? txt.text : txt;
					// sortNatural breaks if you don't pass it strings
					parsedTxt = ( validColumn && c.parsers && c.parsers.length &&
						c.parsers[ column ].format( str, table, [], column ) || str ).toString();
					parsedTxt = c.widgetOptions.filter_ignoreCase ? parsedTxt.toLowerCase() : parsedTxt;
					// parse array data using set column parser; this DOES NOT pass the original
					// table cell to the parser format function
					if ( txt.text ) {
						txt.parsed = parsedTxt;
						parsed[ parsed.length ] = txt;
					} else {
						parsed[ parsed.length ] = {
							text : txt,
							// check parser length - fixes #934
							parsed : parsedTxt
						};
					}
				}
				// sort parsed select options
				cts = c.textSorter || '';
				parsed.sort( function( a, b ) {
					var x = direction ? b.parsed : a.parsed,
						y = direction ? a.parsed : b.parsed;
					if ( validColumn && typeof cts === 'function' ) {
						// custom OVERALL text sorter
						return cts( x, y, true, column, table );
					} else if ( validColumn && typeof cts === 'object' && cts.hasOwnProperty( column ) ) {
						// custom text sorter for a SPECIFIC COLUMN
						return cts[column]( x, y, true, column, table );
					} else if ( ts.sortNatural ) {
						// fall back to natural sort
						return ts.sortNatural( x, y );
					}
					// using an older version! do a basic sort
					return true;
				});
				// rebuild arry from sorted parsed data
				arry = [];
				len = parsed.length;
				for ( indx = 0; indx < len; indx++ ) {
					arry[ arry.length ] = parsed[indx];
				}
				return arry;
			}
		},
		getOptions: function( table, column, onlyAvail ) {
			table = $( table )[0];
			var rowIndex, tbodyIndex, len, row, cache, indx, child, childLen,
				c = table.config,
				wo = c.widgetOptions,
				arry = [];
			for ( tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++ ) {
				cache = c.cache[tbodyIndex];
				len = c.cache[tbodyIndex].normalized.length;
				// loop through the rows
				for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {
					// get cached row from cache.row ( old ) or row data object
					// ( new; last item in normalized array )
					row = cache.row ?
						cache.row[ rowIndex ] :
						cache.normalized[ rowIndex ][ c.columns ].$row[0];
					// check if has class filtered
					if ( onlyAvail && row.className.match( wo.filter_filteredRow ) ) {
						continue;
					}
					// get non-normalized cell content
					if ( wo.filter_useParsedData ||
						c.parsers[column].parsed ||
						c.$headerIndexed[column].hasClass( 'filter-parsed' ) ) {
						arry[ arry.length ] = '' + cache.normalized[ rowIndex ][ column ];
						// child row parsed data
						if ( wo.filter_childRows && wo.filter_childByColumn ) {
							childLen = cache.normalized[ rowIndex ][ c.columns ].$row.length - 1;
							for ( indx = 0; indx < childLen; indx++ ) {
								arry[ arry.length ] = '' + cache.normalized[ rowIndex ][ c.columns ].child[ indx ][ column ];
							}
						}
					} else {
						// get raw cached data instead of content directly from the cells
						arry[ arry.length ] = cache.normalized[ rowIndex ][ c.columns ].raw[ column ];
						// child row unparsed data
						if ( wo.filter_childRows && wo.filter_childByColumn ) {
							childLen = cache.normalized[ rowIndex ][ c.columns ].$row.length;
							for ( indx = 1; indx < childLen; indx++ ) {
								child =  cache.normalized[ rowIndex ][ c.columns ].$row.eq( indx ).children().eq( column );
								arry[ arry.length ] = '' + ts.getElementText( c, child, column );
							}
						}
					}
				}
			}
			return arry;
		},
		buildSelect: function( table, column, arry, updating, onlyAvail ) {
			table = $( table )[0];
			column = parseInt( column, 10 );
			if ( !table.config.cache || $.isEmptyObject( table.config.cache ) ) {
				return;
			}

			var indx, val, txt, t, $filters, $filter, option,
				c = table.config,
				wo = c.widgetOptions,
				node = c.$headerIndexed[ column ],
				// t.data( 'placeholder' ) won't work in jQuery older than 1.4.3
				options = '<option value="">' +
					( node.data( 'placeholder' ) ||
						node.attr( 'data-placeholder' ) ||
						wo.filter_placeholder.select || ''
					) + '</option>',
				// Get curent filter value
				currentValue = c.$table
					.find( 'thead' )
					.find( 'select.' + tscss.filter + '[data-column="' + column + '"]' )
					.val();

			// nothing included in arry ( external source ), so get the options from
			// filter_selectSource or column data
			if ( typeof arry === 'undefined' || arry === '' ) {
				arry = tsf.getOptionSource( table, column, onlyAvail );
				// abort, selects are updated by an external method
				if (arry === null) {
					return;
				}
			}

			if ( $.isArray( arry ) ) {
				// build option list
				for ( indx = 0; indx < arry.length; indx++ ) {
					option = arry[ indx ];
					if ( option.text ) {
						// OBJECT!! add data-function-name in case the value is set in filter_functions
						option['data-function-name'] = typeof option.value === 'undefined' ? option.text : option.value;

						// support jQuery < v1.8, otherwise the below code could be shortened to
						// options += $( '<option>', option )[ 0 ].outerHTML;
						options += '<option';
						for ( val in option ) {
							if ( option.hasOwnProperty( val ) && val !== 'text' ) {
								options += ' ' + val + '="' + option[ val ].replace( tsfRegex.quote, '&quot;' ) + '"';
							}
						}
						if ( !option.value ) {
							options += ' value="' + option.text.replace( tsfRegex.quote, '&quot;' ) + '"';
						}
						options += '>' + option.text.replace( tsfRegex.quote, '&quot;' ) + '</option>';
						// above code is needed in jQuery < v1.8

						// make sure we don't turn an object into a string (objects without a "text" property)
					} else if ( '' + option !== '[object Object]' ) {
						txt = option = ( '' + option ).replace( tsfRegex.quote, '&quot;' );
						val = txt;
						// allow including a symbol in the selectSource array
						// 'a-z|A through Z' so that 'a-z' becomes the option value
						// and 'A through Z' becomes the option text
						if ( txt.indexOf( wo.filter_selectSourceSeparator ) >= 0 ) {
							t = txt.split( wo.filter_selectSourceSeparator );
							val = t[0];
							txt = t[1];
						}
						// replace quotes - fixes #242 & ignore empty strings
						// see http://stackoverflow.com/q/14990971/145346
						options += option !== '' ?
							'<option ' +
								( val === txt ? '' : 'data-function-name="' + option + '" ' ) +
								'value="' + val + '">' + txt +
							'</option>' : '';
					}
				}
				// clear arry so it doesn't get appended twice
				arry = [];
			}

			// update all selects in the same column ( clone thead in sticky headers &
			// any external selects ) - fixes 473
			$filters = ( c.$filters ? c.$filters : c.$table.children( 'thead' ) )
				.find( '.' + tscss.filter );
			if ( wo.filter_$externalFilters ) {
				$filters = $filters && $filters.length ?
					$filters.add( wo.filter_$externalFilters ) :
					wo.filter_$externalFilters;
			}
			$filter = $filters.filter( 'select[data-column="' + column + '"]' );

			// make sure there is a select there!
			if ( $filter.length ) {
				$filter[ updating ? 'html' : 'append' ]( options );
				if ( !$.isArray( arry ) ) {
					// append options if arry is provided externally as a string or jQuery object
					// options ( default value ) was already added
					$filter.append( arry ).val( currentValue );
				}
				$filter.val( currentValue );
			}
		},
		buildDefault: function( table, updating ) {
			var columnIndex, $header, noSelect,
				c = table.config,
				wo = c.widgetOptions,
				columns = c.columns;
			// build default select dropdown
			for ( columnIndex = 0; columnIndex < columns; columnIndex++ ) {
				$header = c.$headerIndexed[columnIndex];
				noSelect = !( $header.hasClass( 'filter-false' ) || $header.hasClass( 'parser-false' ) );
				// look for the filter-select class; build/update it if found
				if ( ( $header.hasClass( 'filter-select' ) ||
					ts.getColumnData( table, wo.filter_functions, columnIndex ) === true ) && noSelect ) {
					tsf.buildSelect( table, columnIndex, '', updating, $header.hasClass( wo.filter_onlyAvail ) );
				}
			}
		}
	};

	// filter regex variable
	tsfRegex = tsf.regex;

	ts.getFilters = function( table, getRaw, setFilters, skipFirst ) {
		var i, $filters, $column, cols,
			filters = [],
			c = table ? $( table )[0].config : '',
			wo = c ? c.widgetOptions : '';
		if ( ( getRaw !== true && wo && !wo.filter_columnFilters ) ||
			// setFilters called, but last search is exactly the same as the current
			// fixes issue #733 & #903 where calling update causes the input values to reset
			( $.isArray(setFilters) && tsf.equalFilters(c, setFilters, c.lastSearch) )
		) {
			return $( table ).data( 'lastSearch' ) || [];
		}
		if ( c ) {
			if ( c.$filters ) {
				$filters = c.$filters.find( '.' + tscss.filter );
			}
			if ( wo.filter_$externalFilters ) {
				$filters = $filters && $filters.length ?
					$filters.add( wo.filter_$externalFilters ) :
					wo.filter_$externalFilters;
			}
			if ( $filters && $filters.length ) {
				filters = setFilters || [];
				for ( i = 0; i < c.columns + 1; i++ ) {
					cols = ( i === c.columns ?
						// 'all' columns can now include a range or set of columms ( data-column='0-2,4,6-7' )
						wo.filter_anyColumnSelector + ',' + wo.filter_multipleColumnSelector :
						'[data-column="' + i + '"]' );
					$column = $filters.filter( cols );
					if ( $column.length ) {
						// move the latest search to the first slot in the array
						$column = tsf.getLatestSearch( $column );
						if ( $.isArray( setFilters ) ) {
							// skip first ( latest input ) to maintain cursor position while typing
							if ( skipFirst && $column.length > 1 ) {
								$column = $column.slice( 1 );
							}
							if ( i === c.columns ) {
								// prevent data-column='all' from filling data-column='0,1' ( etc )
								cols = $column.filter( wo.filter_anyColumnSelector );
								$column = cols.length ? cols : $column;
							}
							$column
								.val( setFilters[ i ] )
								// must include a namespace here; but not c.namespace + 'filter'?
								.trigger( 'change' + c.namespace );
						} else {
							filters[i] = $column.val() || '';
							// don't change the first... it will move the cursor
							if ( i === c.columns ) {
								// don't update range columns from 'all' setting
								$column
									.slice( 1 )
									.filter( '[data-column*="' + $column.attr( 'data-column' ) + '"]' )
									.val( filters[ i ] );
							} else {
								$column
									.slice( 1 )
									.val( filters[ i ] );
							}
						}
						// save any match input dynamically
						if ( i === c.columns && $column.length ) {
							wo.filter_$anyMatch = $column;
						}
					}
				}
			}
		}
		return filters;
	};

	ts.setFilters = function( table, filter, apply, skipFirst ) {
		var c = table ? $( table )[0].config : '',
			valid = ts.getFilters( table, true, filter, skipFirst );
		// default apply to "true"
		if ( typeof apply === 'undefined' ) {
			apply = true;
		}
		if ( c && apply ) {
			// ensure new set filters are applied, even if the search is the same
			c.lastCombinedFilter = null;
			c.lastSearch = [];
			tsf.searching( c.table, filter, skipFirst );
			c.$table.triggerHandler( 'filterFomatterUpdate' );
		}
		return valid.length !== 0;
	};

})( jQuery );

/*! Widget: stickyHeaders - updated 9/27/2017 (v2.29.0) *//*
 * Requires tablesorter v2.8+ and jQuery 1.4.3+
 * by Rob Garrison
 */
;(function ($, window) {
	'use strict';
	var ts = $.tablesorter || {};

	$.extend(ts.css, {
		sticky    : 'tablesorter-stickyHeader', // stickyHeader
		stickyVis : 'tablesorter-sticky-visible',
		stickyHide: 'tablesorter-sticky-hidden',
		stickyWrap: 'tablesorter-sticky-wrapper'
	});

	// Add a resize event to table headers
	ts.addHeaderResizeEvent = function(table, disable, settings) {
		table = $(table)[0]; // make sure we're using a dom element
		if ( !table.config ) { return; }
		var defaults = {
				timer : 250
			},
			options = $.extend({}, defaults, settings),
			c = table.config,
			wo = c.widgetOptions,
			checkSizes = function( triggerEvent ) {
				var index, headers, $header, sizes, width, height,
					len = c.$headers.length;
				wo.resize_flag = true;
				headers = [];
				for ( index = 0; index < len; index++ ) {
					$header = c.$headers.eq( index );
					sizes = $header.data( 'savedSizes' ) || [ 0, 0 ]; // fixes #394
					width = $header[0].offsetWidth;
					height = $header[0].offsetHeight;
					if ( width !== sizes[0] || height !== sizes[1] ) {
						$header.data( 'savedSizes', [ width, height ] );
						headers.push( $header[0] );
					}
				}
				if ( headers.length && triggerEvent !== false ) {
					c.$table.triggerHandler( 'resize', [ headers ] );
				}
				wo.resize_flag = false;
			};
		clearInterval(wo.resize_timer);
		if (disable) {
			wo.resize_flag = false;
			return false;
		}
		checkSizes( false );
		wo.resize_timer = setInterval(function() {
			if (wo.resize_flag) { return; }
			checkSizes();
		}, options.timer);
	};

	function getStickyOffset(c, wo) {
		var $el = isNaN(wo.stickyHeaders_offset) ? $(wo.stickyHeaders_offset) : [];
		return $el.length ?
			$el.height() || 0 :
			parseInt(wo.stickyHeaders_offset, 10) || 0;
	}

	// Sticky headers based on this awesome article:
	// http://css-tricks.com/13465-persistent-headers/
	// and https://github.com/jmosbech/StickyTableHeaders by Jonas Mosbech
	// **************************
	ts.addWidget({
		id: 'stickyHeaders',
		priority: 54, // sticky widget must be initialized after the filter & before pager widget!
		options: {
			stickyHeaders : '',       // extra class name added to the sticky header row
			stickyHeaders_appendTo : null, // jQuery selector or object to phycially attach the sticky headers
			stickyHeaders_attachTo : null, // jQuery selector or object to attach scroll listener to (overridden by xScroll & yScroll settings)
			stickyHeaders_xScroll : null, // jQuery selector or object to monitor horizontal scroll position (defaults: xScroll > attachTo > window)
			stickyHeaders_yScroll : null, // jQuery selector or object to monitor vertical scroll position (defaults: yScroll > attachTo > window)
			stickyHeaders_offset : 0, // number or jquery selector targeting the position:fixed element
			stickyHeaders_filteredToTop: true, // scroll table top into view after filtering
			stickyHeaders_cloneId : '-sticky', // added to table ID, if it exists
			stickyHeaders_addResizeEvent : true, // trigger 'resize' event on headers
			stickyHeaders_includeCaption : true, // if false and a caption exist, it won't be included in the sticky header
			stickyHeaders_zIndex : 2 // The zIndex of the stickyHeaders, allows the user to adjust this to their needs
		},
		format: function(table, c, wo) {
			// filter widget doesn't initialize on an empty table. Fixes #449
			if ( c.$table.hasClass('hasStickyHeaders') || ($.inArray('filter', c.widgets) >= 0 && !c.$table.hasClass('hasFilters')) ) {
				return;
			}
			var index, len, $t,
				$table = c.$table,
				// add position: relative to attach element, hopefully it won't cause trouble.
				$attach = $(wo.stickyHeaders_attachTo || wo.stickyHeaders_appendTo),
				namespace = c.namespace + 'stickyheaders ',
				// element to watch for the scroll event
				$yScroll = $(wo.stickyHeaders_yScroll || wo.stickyHeaders_attachTo || window),
				$xScroll = $(wo.stickyHeaders_xScroll || wo.stickyHeaders_attachTo || window),
				$thead = $table.children('thead:first'),
				$header = $thead.children('tr').not('.sticky-false').children(),
				$tfoot = $table.children('tfoot'),
				stickyOffset = getStickyOffset(c, wo),
				// is this table nested? If so, find parent sticky header wrapper (div, not table)
				$nestedSticky = $table.parent().closest('.' + ts.css.table).hasClass('hasStickyHeaders') ?
					$table.parent().closest('table.tablesorter')[0].config.widgetOptions.$sticky.parent() : [],
				nestedStickyTop = $nestedSticky.length ? $nestedSticky.height() : 0,
				// clone table, then wrap to make sticky header
				$stickyTable = wo.$sticky = $table.clone()
					.addClass('containsStickyHeaders ' + ts.css.sticky + ' ' + wo.stickyHeaders + ' ' + c.namespace.slice(1) + '_extra_table' )
					.wrap('<div class="' + ts.css.stickyWrap + '">'),
				$stickyWrap = $stickyTable.parent()
					.addClass(ts.css.stickyHide)
					.css({
						position   : $attach.length ? 'absolute' : 'fixed',
						padding    : parseInt( $stickyTable.parent().parent().css('padding-left'), 10 ),
						top        : stickyOffset + nestedStickyTop,
						left       : 0,
						visibility : 'hidden',
						zIndex     : wo.stickyHeaders_zIndex || 2
					}),
				$stickyThead = $stickyTable.children('thead:first'),
				$stickyCells,
				laststate = '',
				setWidth = function($orig, $clone) {
					var index, width, border, $cell, $this,
						$cells = $orig.filter(':visible'),
						len = $cells.length;
					for ( index = 0; index < len; index++ ) {
						$cell = $clone.filter(':visible').eq(index);
						$this = $cells.eq(index);
						// code from https://github.com/jmosbech/StickyTableHeaders
						if ($this.css('box-sizing') === 'border-box') {
							width = $this.outerWidth();
						} else {
							if ($cell.css('border-collapse') === 'collapse') {
								if (window.getComputedStyle) {
									width = parseFloat( window.getComputedStyle($this[0], null).width );
								} else {
									// ie8 only
									border = parseFloat( $this.css('border-width') );
									width = $this.outerWidth() - parseFloat( $this.css('padding-left') ) - parseFloat( $this.css('padding-right') ) - border;
								}
							} else {
								width = $this.width();
							}
						}
						$cell.css({
							'width': width,
							'min-width': width,
							'max-width': width
						});
					}
				},
				getLeftPosition = function(yWindow) {
					if (yWindow === false && $nestedSticky.length) {
						return $table.position().left;
					}
					return $attach.length ?
						parseInt($attach.css('padding-left'), 10) || 0 :
						$table.offset().left - parseInt($table.css('margin-left'), 10) - $(window).scrollLeft();
				},
				resizeHeader = function() {
					$stickyWrap.css({
						left : getLeftPosition(),
						width: $table.outerWidth()
					});
					setWidth( $table, $stickyTable );
					setWidth( $header, $stickyCells );
				},
				scrollSticky = function( resizing ) {
					if (!$table.is(':visible')) { return; } // fixes #278
					// Detect nested tables - fixes #724
					nestedStickyTop = $nestedSticky.length ? $nestedSticky.offset().top - $yScroll.scrollTop() + $nestedSticky.height() : 0;
					var tmp,
						offset = $table.offset(),
						stickyOffset = getStickyOffset(c, wo),
						yWindow = $.isWindow( $yScroll[0] ), // $.isWindow needs jQuery 1.4.3
						yScroll = yWindow ?
							$yScroll.scrollTop() :
							// use parent sticky position if nested AND inside of a scrollable element - see #1512
							$nestedSticky.length ? parseInt($nestedSticky[0].style.top, 10) : $yScroll.offset().top,
						attachTop = $attach.length ? yScroll : $yScroll.scrollTop(),
						captionHeight = wo.stickyHeaders_includeCaption ? 0 : $table.children( 'caption' ).height() || 0,
						scrollTop = attachTop + stickyOffset + nestedStickyTop - captionHeight,
						tableHeight = $table.height() - ($stickyWrap.height() + ($tfoot.height() || 0)) - captionHeight,
						isVisible = ( scrollTop > offset.top ) && ( scrollTop < offset.top + tableHeight ) ? 'visible' : 'hidden',
						state = isVisible === 'visible' ? ts.css.stickyVis : ts.css.stickyHide,
						needsUpdating = !$stickyWrap.hasClass( state ),
						cssSettings = { visibility : isVisible };
					if ($attach.length) {
						// attached sticky headers always need updating
						needsUpdating = true;
						cssSettings.top = yWindow ? scrollTop - $attach.offset().top : $attach.scrollTop();
					}
					// adjust when scrolling horizontally - fixes issue #143
					tmp = getLeftPosition(yWindow);
					if (tmp !== parseInt($stickyWrap.css('left'), 10)) {
						needsUpdating = true;
						cssSettings.left = tmp;
					}
					cssSettings.top = ( cssSettings.top || 0 ) +
						// If nested AND inside of a scrollable element, only add parent sticky height
						(!yWindow && $nestedSticky.length ? $nestedSticky.height() : stickyOffset + nestedStickyTop);
					if (needsUpdating) {
						$stickyWrap
							.removeClass( ts.css.stickyVis + ' ' + ts.css.stickyHide )
							.addClass( state )
							.css(cssSettings);
					}
					if (isVisible !== laststate || resizing) {
						// make sure the column widths match
						resizeHeader();
						laststate = isVisible;
					}
				};
			// only add a position relative if a position isn't already defined
			if ($attach.length && !$attach.css('position')) {
				$attach.css('position', 'relative');
			}
			// fix clone ID, if it exists - fixes #271
			if ($stickyTable.attr('id')) { $stickyTable[0].id += wo.stickyHeaders_cloneId; }
			// clear out cloned table, except for sticky header
			// include caption & filter row (fixes #126 & #249) - don't remove cells to get correct cell indexing
			$stickyTable.find('> thead:gt(0), tr.sticky-false').hide();
			$stickyTable.find('> tbody, > tfoot').remove();
			$stickyTable.find('caption').toggle(wo.stickyHeaders_includeCaption);
			// issue #172 - find td/th in sticky header
			$stickyCells = $stickyThead.children().children();
			$stickyTable.css({ height:0, width:0, margin: 0 });
			// remove resizable block
			$stickyCells.find('.' + ts.css.resizer).remove();
			// update sticky header class names to match real header after sorting
			$table
				.addClass('hasStickyHeaders')
				.bind('pagerComplete' + namespace, function() {
					resizeHeader();
				});

			ts.bindEvents(table, $stickyThead.children().children('.' + ts.css.header));

			if (wo.stickyHeaders_appendTo) {
				$(wo.stickyHeaders_appendTo).append( $stickyWrap );
			} else {
				// add stickyheaders AFTER the table. If the table is selected by ID, the original one (first) will be returned.
				$table.after( $stickyWrap );
			}

			// onRenderHeader is defined, we need to do something about it (fixes #641)
			if (c.onRenderHeader) {
				$t = $stickyThead.children('tr').children();
				len = $t.length;
				for ( index = 0; index < len; index++ ) {
					// send second parameter
					c.onRenderHeader.apply( $t.eq( index ), [ index, c, $stickyTable ] );
				}
			}
			// make it sticky!
			$xScroll.add($yScroll)
				.unbind( ('scroll resize '.split(' ').join( namespace )).replace(/\s+/g, ' ') )
				.bind('scroll resize '.split(' ').join( namespace ), function( event ) {
					scrollSticky( event.type === 'resize' );
				});
			c.$table
				.unbind('stickyHeadersUpdate' + namespace)
				.bind('stickyHeadersUpdate' + namespace, function() {
					scrollSticky( true );
				});

			if (wo.stickyHeaders_addResizeEvent) {
				ts.addHeaderResizeEvent(table);
			}

			// look for filter widget
			if ($table.hasClass('hasFilters') && wo.filter_columnFilters) {
				// scroll table into view after filtering, if sticky header is active - #482
				$table.bind('filterEnd' + namespace, function() {
					// $(':focus') needs jQuery 1.6+
					var $td = $(document.activeElement).closest('td'),
						column = $td.parent().children().index($td);
					// only scroll if sticky header is active
					if ($stickyWrap.hasClass(ts.css.stickyVis) && wo.stickyHeaders_filteredToTop) {
						// scroll to original table (not sticky clone)
						window.scrollTo(0, $table.position().top);
						// give same input/select focus; check if c.$filters exists; fixes #594
						if (column >= 0 && c.$filters) {
							c.$filters.eq(column).find('a, select, input').filter(':visible').focus();
						}
					}
				});
				ts.filter.bindSearch( $table, $stickyCells.find('.' + ts.css.filter) );
				// support hideFilters
				if (wo.filter_hideFilters) {
					ts.filter.hideFilters(c, $stickyTable);
				}
			}

			// resize table (Firefox)
			if (wo.stickyHeaders_addResizeEvent) {
				$table.bind('resize' + c.namespace + 'stickyheaders', function() {
					resizeHeader();
				});
			}

			// make sure sticky is visible if page is partially scrolled
			scrollSticky( true );
			$table.triggerHandler('stickyHeadersInit');

		},
		remove: function(table, c, wo) {
			var namespace = c.namespace + 'stickyheaders ';
			c.$table
				.removeClass('hasStickyHeaders')
				.unbind( ('pagerComplete resize filterEnd stickyHeadersUpdate '.split(' ').join(namespace)).replace(/\s+/g, ' ') )
				.next('.' + ts.css.stickyWrap).remove();
			if (wo.$sticky && wo.$sticky.length) { wo.$sticky.remove(); } // remove cloned table
			$(window)
				.add(wo.stickyHeaders_xScroll)
				.add(wo.stickyHeaders_yScroll)
				.add(wo.stickyHeaders_attachTo)
				.unbind( ('scroll resize '.split(' ').join(namespace)).replace(/\s+/g, ' ') );
			ts.addHeaderResizeEvent(table, true);
		}
	});

})(jQuery, window);

/*! Widget: resizable - updated 2018-03-26 (v2.30.2) */
/*jshint browser:true, jquery:true, unused:false */
;(function ($, window) {
	'use strict';
	var ts = $.tablesorter || {};

	$.extend(ts.css, {
		resizableContainer : 'tablesorter-resizable-container',
		resizableHandle    : 'tablesorter-resizable-handle',
		resizableNoSelect  : 'tablesorter-disableSelection',
		resizableStorage   : 'tablesorter-resizable'
	});

	// Add extra scroller css
	$(function() {
		var s = '<style>' +
			'body.' + ts.css.resizableNoSelect + ' { -ms-user-select: none; -moz-user-select: -moz-none;' +
				'-khtml-user-select: none; -webkit-user-select: none; user-select: none; }' +
			'.' + ts.css.resizableContainer + ' { position: relative; height: 1px; }' +
			// make handle z-index > than stickyHeader z-index, so the handle stays above sticky header
			'.' + ts.css.resizableHandle + ' { position: absolute; display: inline-block; width: 8px;' +
				'top: 1px; cursor: ew-resize; z-index: 3; user-select: none; -moz-user-select: none; }' +
			'</style>';
		$('head').append(s);
	});

	ts.resizable = {
		init : function( c, wo ) {
			if ( c.$table.hasClass( 'hasResizable' ) ) { return; }
			c.$table.addClass( 'hasResizable' );

			var noResize, $header, column, storedSizes, tmp,
				$table = c.$table,
				$parent = $table.parent(),
				marginTop = parseInt( $table.css( 'margin-top' ), 10 ),

			// internal variables
			vars = wo.resizable_vars = {
				useStorage : ts.storage && wo.resizable !== false,
				$wrap : $parent,
				mouseXPosition : 0,
				$target : null,
				$next : null,
				overflow : $parent.css('overflow') === 'auto' ||
					$parent.css('overflow') === 'scroll' ||
					$parent.css('overflow-x') === 'auto' ||
					$parent.css('overflow-x') === 'scroll',
				storedSizes : []
			};

			// set default widths
			ts.resizableReset( c.table, true );

			// now get measurements!
			vars.tableWidth = $table.width();
			// attempt to autodetect
			vars.fullWidth = Math.abs( $parent.width() - vars.tableWidth ) < 20;

			/*
			// Hacky method to determine if table width is set to 'auto'
			// http://stackoverflow.com/a/20892048/145346
			if ( !vars.fullWidth ) {
				tmp = $table.width();
				$header = $table.wrap('<span>').parent(); // temp variable
				storedSizes = parseInt( $table.css( 'margin-left' ), 10 ) || 0;
				$table.css( 'margin-left', storedSizes + 50 );
				vars.tableWidth = $header.width() > tmp ? 'auto' : tmp;
				$table.css( 'margin-left', storedSizes ? storedSizes : '' );
				$header = null;
				$table.unwrap('<span>');
			}
			*/

			if ( vars.useStorage && vars.overflow ) {
				// save table width
				ts.storage( c.table, 'tablesorter-table-original-css-width', vars.tableWidth );
				tmp = ts.storage( c.table, 'tablesorter-table-resized-width' ) || 'auto';
				ts.resizable.setWidth( $table, tmp, true );
			}
			wo.resizable_vars.storedSizes = storedSizes = ( vars.useStorage ?
				ts.storage( c.table, ts.css.resizableStorage ) :
				[] ) || [];
			ts.resizable.setWidths( c, wo, storedSizes );
			ts.resizable.updateStoredSizes( c, wo );

			wo.$resizable_container = $( '<div class="' + ts.css.resizableContainer + '">' )
				.css({ top : marginTop })
				.insertBefore( $table );
			// add container
			for ( column = 0; column < c.columns; column++ ) {
				$header = c.$headerIndexed[ column ];
				tmp = ts.getColumnData( c.table, c.headers, column );
				noResize = ts.getData( $header, tmp, 'resizable' ) === 'false';
				if ( !noResize ) {
					$( '<div class="' + ts.css.resizableHandle + '">' )
						.appendTo( wo.$resizable_container )
						.attr({
							'data-column' : column,
							'unselectable' : 'on'
						})
						.data( 'header', $header )
						.bind( 'selectstart', false );
				}
			}
			ts.resizable.bindings( c, wo );
		},

		updateStoredSizes : function( c, wo ) {
			var column, $header,
				len = c.columns,
				vars = wo.resizable_vars;
			vars.storedSizes = [];
			for ( column = 0; column < len; column++ ) {
				$header = c.$headerIndexed[ column ];
				vars.storedSizes[ column ] = $header.is(':visible') ? $header.width() : 0;
			}
		},

		setWidth : function( $el, width, overflow ) {
			// overflow tables need min & max width set as well
			$el.css({
				'width' : width,
				'min-width' : overflow ? width : '',
				'max-width' : overflow ? width : ''
			});
		},

		setWidths : function( c, wo, storedSizes ) {
			var column, $temp,
				vars = wo.resizable_vars,
				$extra = $( c.namespace + '_extra_headers' ),
				$col = c.$table.children( 'colgroup' ).children( 'col' );
			storedSizes = storedSizes || vars.storedSizes || [];
			// process only if table ID or url match
			if ( storedSizes.length ) {
				for ( column = 0; column < c.columns; column++ ) {
					// set saved resizable widths
					ts.resizable.setWidth( c.$headerIndexed[ column ], storedSizes[ column ], vars.overflow );
					if ( $extra.length ) {
						// stickyHeaders needs to modify min & max width as well
						$temp = $extra.eq( column ).add( $col.eq( column ) );
						ts.resizable.setWidth( $temp, storedSizes[ column ], vars.overflow );
					}
				}
				$temp = $( c.namespace + '_extra_table' );
				if ( $temp.length && !ts.hasWidget( c.table, 'scroller' ) ) {
					ts.resizable.setWidth( $temp, c.$table.outerWidth(), vars.overflow );
				}
			}
		},

		setHandlePosition : function( c, wo ) {
			var startPosition,
				tableHeight = c.$table.height(),
				$handles = wo.$resizable_container.children(),
				handleCenter = Math.floor( $handles.width() / 2 );

			if ( ts.hasWidget( c.table, 'scroller' ) ) {
				tableHeight = 0;
				c.$table.closest( '.' + ts.css.scrollerWrap ).children().each(function() {
					var $this = $(this);
					// center table has a max-height set
					tableHeight += $this.filter('[style*="height"]').length ? $this.height() : $this.children('table').height();
				});
			}

			if ( !wo.resizable_includeFooter && c.$table.children('tfoot').length ) {
				tableHeight -= c.$table.children('tfoot').height();
			}
			// subtract out table left position from resizable handles. Fixes #864
			// jQuery v3.3.0+ appears to include the start position with the $header.position().left; see #1544
			startPosition = parseFloat($.fn.jquery) >= 3.3 ? 0 : c.$table.position().left;
			$handles.each( function() {
				var $this = $(this),
					column = parseInt( $this.attr( 'data-column' ), 10 ),
					columns = c.columns - 1,
					$header = $this.data( 'header' );
				if ( !$header ) { return; } // see #859
				if (
					!$header.is(':visible') ||
					( !wo.resizable_addLastColumn && ts.resizable.checkVisibleColumns(c, column) )
				) {
					$this.hide();
				} else if ( column < columns || column === columns && wo.resizable_addLastColumn ) {
					$this.css({
						display: 'inline-block',
						height : tableHeight,
						left : $header.position().left - startPosition + $header.outerWidth() - handleCenter
					});
				}
			});
		},

		// Fixes #1485
		checkVisibleColumns: function( c, column ) {
			var i,
				len = 0;
			for ( i = column + 1; i < c.columns; i++ ) {
				len += c.$headerIndexed[i].is( ':visible' ) ? 1 : 0;
			}
			return len === 0;
		},

		// prevent text selection while dragging resize bar
		toggleTextSelection : function( c, wo, toggle ) {
			var namespace = c.namespace + 'tsresize';
			wo.resizable_vars.disabled = toggle;
			$( 'body' ).toggleClass( ts.css.resizableNoSelect, toggle );
			if ( toggle ) {
				$( 'body' )
					.attr( 'unselectable', 'on' )
					.bind( 'selectstart' + namespace, false );
			} else {
				$( 'body' )
					.removeAttr( 'unselectable' )
					.unbind( 'selectstart' + namespace );
			}
		},

		bindings : function( c, wo ) {
			var namespace = c.namespace + 'tsresize';
			wo.$resizable_container.children().bind( 'mousedown', function( event ) {
				// save header cell and mouse position
				var column,
					vars = wo.resizable_vars,
					$extras = $( c.namespace + '_extra_headers' ),
					$header = $( event.target ).data( 'header' );

				column = parseInt( $header.attr( 'data-column' ), 10 );
				vars.$target = $header = $header.add( $extras.filter('[data-column="' + column + '"]') );
				vars.target = column;

				// if table is not as wide as it's parent, then resize the table
				vars.$next = event.shiftKey || wo.resizable_targetLast ?
					$header.parent().children().not( '.resizable-false' ).filter( ':last' ) :
					$header.nextAll( ':not(.resizable-false)' ).eq( 0 );

				column = parseInt( vars.$next.attr( 'data-column' ), 10 );
				vars.$next = vars.$next.add( $extras.filter('[data-column="' + column + '"]') );
				vars.next = column;

				vars.mouseXPosition = event.pageX;
				ts.resizable.updateStoredSizes( c, wo );
				ts.resizable.toggleTextSelection(c, wo, true );
			});

			$( document )
				.bind( 'mousemove' + namespace, function( event ) {
					var vars = wo.resizable_vars;
					// ignore mousemove if no mousedown
					if ( !vars.disabled || vars.mouseXPosition === 0 || !vars.$target ) { return; }
					if ( wo.resizable_throttle ) {
						clearTimeout( vars.timer );
						vars.timer = setTimeout( function() {
							ts.resizable.mouseMove( c, wo, event );
						}, isNaN( wo.resizable_throttle ) ? 5 : wo.resizable_throttle );
					} else {
						ts.resizable.mouseMove( c, wo, event );
					}
				})
				.bind( 'mouseup' + namespace, function() {
					if (!wo.resizable_vars.disabled) { return; }
					ts.resizable.toggleTextSelection( c, wo, false );
					ts.resizable.stopResize( c, wo );
					ts.resizable.setHandlePosition( c, wo );
				});

			// resizeEnd event triggered by scroller widget
			$( window ).bind( 'resize' + namespace + ' resizeEnd' + namespace, function() {
				ts.resizable.setHandlePosition( c, wo );
			});

			// right click to reset columns to default widths
			c.$table
				.bind( 'columnUpdate pagerComplete resizableUpdate '.split( ' ' ).join( namespace + ' ' ), function() {
					ts.resizable.setHandlePosition( c, wo );
				})
				.bind( 'resizableReset' + namespace, function() {
					ts.resizableReset( c.table );
				})
				.find( 'thead:first' )
				.add( $( c.namespace + '_extra_table' ).find( 'thead:first' ) )
				.bind( 'contextmenu' + namespace, function() {
					// $.isEmptyObject() needs jQuery 1.4+; allow right click if already reset
					var allowClick = wo.resizable_vars.storedSizes.length === 0;
					ts.resizableReset( c.table );
					ts.resizable.setHandlePosition( c, wo );
					wo.resizable_vars.storedSizes = [];
					return allowClick;
				});

		},

		mouseMove : function( c, wo, event ) {
			if ( wo.resizable_vars.mouseXPosition === 0 || !wo.resizable_vars.$target ) { return; }
			// resize columns
			var column,
				total = 0,
				vars = wo.resizable_vars,
				$next = vars.$next,
				tar = vars.storedSizes[ vars.target ],
				leftEdge = event.pageX - vars.mouseXPosition;
			if ( vars.overflow ) {
				if ( tar + leftEdge > 0 ) {
					vars.storedSizes[ vars.target ] += leftEdge;
					ts.resizable.setWidth( vars.$target, vars.storedSizes[ vars.target ], true );
					// update the entire table width
					for ( column = 0; column < c.columns; column++ ) {
						total += vars.storedSizes[ column ];
					}
					ts.resizable.setWidth( c.$table.add( $( c.namespace + '_extra_table' ) ), total );
				}
				if ( !$next.length ) {
					// if expanding right-most column, scroll the wrapper
					vars.$wrap[0].scrollLeft = c.$table.width();
				}
			} else if ( vars.fullWidth ) {
				vars.storedSizes[ vars.target ] += leftEdge;
				vars.storedSizes[ vars.next ] -= leftEdge;
				ts.resizable.setWidths( c, wo );
			} else {
				vars.storedSizes[ vars.target ] += leftEdge;
				ts.resizable.setWidths( c, wo );
			}
			vars.mouseXPosition = event.pageX;
			// dynamically update sticky header widths
			c.$table.triggerHandler('stickyHeadersUpdate');
		},

		stopResize : function( c, wo ) {
			var vars = wo.resizable_vars;
			ts.resizable.updateStoredSizes( c, wo );
			if ( vars.useStorage ) {
				// save all column widths
				ts.storage( c.table, ts.css.resizableStorage, vars.storedSizes );
				ts.storage( c.table, 'tablesorter-table-resized-width', c.$table.width() );
			}
			vars.mouseXPosition = 0;
			vars.$target = vars.$next = null;
			// will update stickyHeaders, just in case, see #912
			c.$table.triggerHandler('stickyHeadersUpdate');
			c.$table.triggerHandler('resizableComplete');
		}
	};

	// this widget saves the column widths if
	// $.tablesorter.storage function is included
	// **************************
	ts.addWidget({
		id: 'resizable',
		priority: 40,
		options: {
			resizable : true, // save column widths to storage
			resizable_addLastColumn : false,
			resizable_includeFooter: true,
			resizable_widths : [],
			resizable_throttle : false, // set to true (5ms) or any number 0-10 range
			resizable_targetLast : false
		},
		init: function(table, thisWidget, c, wo) {
			ts.resizable.init( c, wo );
		},
		format: function( table, c, wo ) {
			ts.resizable.setHandlePosition( c, wo );
		},
		remove: function( table, c, wo, refreshing ) {
			if (wo.$resizable_container) {
				var namespace = c.namespace + 'tsresize';
				c.$table.add( $( c.namespace + '_extra_table' ) )
					.removeClass('hasResizable')
					.children( 'thead' )
					.unbind( 'contextmenu' + namespace );

				wo.$resizable_container.remove();
				ts.resizable.toggleTextSelection( c, wo, false );
				ts.resizableReset( table, refreshing );
				$( document ).unbind( 'mousemove' + namespace + ' mouseup' + namespace );
			}
		}
	});

	ts.resizableReset = function( table, refreshing ) {
		$( table ).each(function() {
			var index, $t,
				c = this.config,
				wo = c && c.widgetOptions,
				vars = wo.resizable_vars;
			if ( table && c && c.$headerIndexed.length ) {
				// restore the initial table width
				if ( vars.overflow && vars.tableWidth ) {
					ts.resizable.setWidth( c.$table, vars.tableWidth, true );
					if ( vars.useStorage ) {
						ts.storage( table, 'tablesorter-table-resized-width', vars.tableWidth );
					}
				}
				for ( index = 0; index < c.columns; index++ ) {
					$t = c.$headerIndexed[ index ];
					if ( wo.resizable_widths && wo.resizable_widths[ index ] ) {
						ts.resizable.setWidth( $t, wo.resizable_widths[ index ], vars.overflow );
					} else if ( !$t.hasClass( 'resizable-false' ) ) {
						// don't clear the width of any column that is not resizable
						ts.resizable.setWidth( $t, '', vars.overflow );
					}
				}

				// reset stickyHeader widths
				c.$table.triggerHandler( 'stickyHeadersUpdate' );
				if ( ts.storage && !refreshing ) {
					ts.storage( this, ts.css.resizableStorage, [] );
				}
			}
		});
	};

})( jQuery, window );

/*! Widget: saveSort - updated 2018-03-19 (v2.30.1) *//*
* Requires tablesorter v2.16+
* by Rob Garrison
*/
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	function getStoredSortList(c) {
		var stored = ts.storage( c.table, 'tablesorter-savesort' );
		return (stored && stored.hasOwnProperty('sortList') && $.isArray(stored.sortList)) ? stored.sortList : [];
	}

	function sortListChanged(c, sortList) {
		return (sortList || getStoredSortList(c)).join(',') !== c.sortList.join(',');
	}

	// this widget saves the last sort only if the
	// saveSort widget option is true AND the
	// $.tablesorter.storage function is included
	// **************************
	ts.addWidget({
		id: 'saveSort',
		priority: 20,
		options: {
			saveSort : true
		},
		init: function(table, thisWidget, c, wo) {
			// run widget format before all other widgets are applied to the table
			thisWidget.format(table, c, wo, true);
		},
		format: function(table, c, wo, init) {
			var time,
				$table = c.$table,
				saveSort = wo.saveSort !== false, // make saveSort active/inactive; default to true
				sortList = { 'sortList' : c.sortList },
				debug = ts.debug(c, 'saveSort');
			if (debug) {
				time = new Date();
			}
			if ($table.hasClass('hasSaveSort')) {
				if (saveSort && table.hasInitialized && ts.storage && sortListChanged(c)) {
					ts.storage( table, 'tablesorter-savesort', sortList );
					if (debug) {
						console.log('saveSort >> Saving last sort: ' + c.sortList + ts.benchmark(time));
					}
				}
			} else {
				// set table sort on initial run of the widget
				$table.addClass('hasSaveSort');
				sortList = '';
				// get data
				if (ts.storage) {
					sortList = getStoredSortList(c);
					if (debug) {
						console.log('saveSort >> Last sort loaded: "' + sortList + '"' + ts.benchmark(time));
					}
					$table.bind('saveSortReset', function(event) {
						event.stopPropagation();
						ts.storage( table, 'tablesorter-savesort', '' );
					});
				}
				// init is true when widget init is run, this will run this widget before all other widgets have initialized
				// this method allows using this widget in the original tablesorter plugin; but then it will run all widgets twice.
				if (init && sortList && sortList.length > 0) {
					c.sortList = sortList;
				} else if (table.hasInitialized && sortList && sortList.length > 0) {
					// update sort change
					if (sortListChanged(c, sortList)) {
						ts.sortOn(c, sortList);
					}
				}
			}
		},
		remove: function(table, c) {
			c.$table.removeClass('hasSaveSort');
			// clear storage
			if (ts.storage) { ts.storage( table, 'tablesorter-savesort', '' ); }
		}
	});

})(jQuery);
return jQuery.tablesorter;}));


/***/ }),

/***/ "./node_modules/tablesorter/dist/js/widgets/widget-columnSelector.min.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/tablesorter/dist/js/widgets/widget-columnSelector.min.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory){if (true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));} else {}}(function(jQuery){

!function(h){"use strict";var f=h.tablesorter,c=".tscolsel",S=f.columnSelector={queryAll:"@media only all { [columns] { display: none; } } ",queryBreak:"@media all and (min-width: [size]) { [columns] { display: table-cell; } } ",init:function(e,t,o){var l,a,n=f.debug(t,"columnSelector");(l=h(o.columnSelector_layout)).find("input").add(l.filter("input")).length?(t.$table.addClass(t.namespace.slice(1)+"columnselector"),(a=t.selector={$container:h(o.columnSelector_container||"<div>")}).$style=h("<style></style>").prop("disabled",!0).appendTo("head"),a.$breakpoints=h("<style></style>").prop("disabled",!0).appendTo("head"),a.isInitializing=!0,S.setUpColspan(t,o),S.setupSelector(t,o),o.columnSelector_mediaquery&&S.setupBreakpoints(t,o),a.isInitializing=!1,a.$container.length?S.updateCols(t,o):n&&console.warn("ColumnSelector >> container not found"),t.$table.off("refreshColumnSelector"+c).on("refreshColumnSelector"+c,function(e,t,o){S.refreshColumns(this.config,t,o)}),n&&console.log("ColumnSelector >> Widget initialized")):n&&console.error("ColumnSelector >> ERROR: Column Selector aborting, no input found in the layout! ***")},refreshColumns:function(e,t,o){var l,a,n,c,r=e.selector,s=h.isArray(o||t),i=e.widgetOptions;if(null!=t&&r.$container.length){if("selectors"===t&&(r.$container.empty(),S.setupSelector(e,i),S.setupBreakpoints(e,i),void 0===o&&null!==o&&(o=r.auto)),s)for(a=o||t,h.each(a,function(e,t){a[e]=parseInt(t,10)}),l=0;l<e.columns;l++)c=0<=h.inArray(l,a),(n=r.$container.find("input[data-column="+l+"]")).length&&(n.prop("checked",c),r.states[l]=c);c=!0===o||!0===t||"auto"===t&&!1!==o,n=r.$container.find('input[data-column="auto"]').prop("checked",c),S.updateAuto(e,i,n)}else S.updateBreakpoints(e,i),S.updateCols(e,i);S.saveValues(e,i),S.adjustColspans(e,i)},setupSelector:function(t,o){var e,l,a,n,c,r,s,i=t.selector,u=i.$container,d=o.columnSelector_saveColumns&&f.storage,p=d?f.storage(t.table,"tablesorter-columnSelector"):[],m=d?f.storage(t.table,"tablesorter-columnSelector-auto"):{};for(i.auto=h.isEmptyObject(m)||"boolean"!==h.type(m.auto)?o.columnSelector_mediaqueryState:m.auto,i.states=[],i.$column=[],i.$wrapper=[],i.$checkbox=[],e=0;e<t.columns;e++)n=(a=t.$headerIndexed[e]).attr(o.columnSelector_priority)||1,r=a.attr("data-column"),c=f.getColumnData(t.table,t.headers,r),m=f.getData(a,c,"columnSelector"),isNaN(n)&&0<n.length||"disable"===m||o.columnSelector_columns[r]&&"disable"===o.columnSelector_columns[r]?i.states[r]=null:(i.states[r]=p&&void 0!==p[r]&&null!==p[r]?p[r]:void 0!==o.columnSelector_columns[r]&&null!==o.columnSelector_columns[r]?o.columnSelector_columns[r]:"true"===m||"false"!==m,i.$column[r]=h(this),u.length&&(l=a.attr(o.columnSelector_name)||a.text().trim(),"function"==typeof o.columnSelector_layoutCustomizer&&(s=a.find("."+f.css.headerIn),l=o.columnSelector_layoutCustomizer(s.length?s:a,l,parseInt(r,10))),i.$wrapper[r]=h(o.columnSelector_layout.replace(/\{name\}/g,l)).appendTo(u),i.$checkbox[r]=i.$wrapper[r].find("input").add(i.$wrapper[r].filter("input")).attr("data-column",r).toggleClass(o.columnSelector_cssChecked,i.states[r]).prop("checked",i.states[r]).on("change",function(){if(!i.isInitializing){var e=h(this).attr("data-column");if(!S.checkChange(t,this.checked))return this.checked=!this.checked,!1;t.selector.states[e]=this.checked,S.updateCols(t,o)}}).change()))},checkChange:function(e,t){for(var o=e.widgetOptions,l=o.columnSelector_maxVisible,a=o.columnSelector_minVisible,n=e.selector.states,c=n.length,r=0;0<=c--;)n[c]&&r++;return!(t&null!==l&&l<=r||!t&&null!==a&&r<=a)},setupBreakpoints:function(e,t){var o=e.selector;t.columnSelector_mediaquery&&(o.lastIndex=-1,S.updateBreakpoints(e,t),e.$table.off("updateAll"+c).on("updateAll"+c,function(){S.setupSelector(e,t),S.setupBreakpoints(e,t),S.updateBreakpoints(e,t),S.updateCols(e,t)})),o.$container.length&&(t.columnSelector_mediaquery&&(o.$auto=h(t.columnSelector_layout.replace(/\{name\}/g,t.columnSelector_mediaqueryName)).prependTo(o.$container),o.$auto.find("input").add(o.$auto.filter("input")).attr("data-column","auto").prop("checked",o.auto).toggleClass(t.columnSelector_cssChecked,o.auto).on("change",function(){S.updateAuto(e,t,h(this))}).change()),e.$table.off("update"+c).on("update"+c,function(){S.updateCols(e,t)}))},updateAuto:function(e,t,o){var l=e.selector;l.auto=o.prop("checked")||!1,h.each(l.$checkbox,function(e,t){t&&(t[0].disabled=l.auto,l.$wrapper[e].toggleClass("disabled",l.auto))}),t.columnSelector_mediaquery&&S.updateBreakpoints(e,t),S.updateCols(e,t),e.selector.$popup&&e.selector.$popup.find(".tablesorter-column-selector").html(l.$container.html()).find("input").each(function(){var e=h(this).attr("data-column");h(this).prop("checked","auto"===e?l.auto:l.states[e])}),S.saveValues(e,t),S.adjustColspans(e,t),l.auto&&e.$table.triggerHandler(t.columnSelector_updated)},addSelectors:function(e,t,o){var l=[],a=" col:nth-child("+o+")";return l.push(t+a+","+t+"_extra_table"+a),a=" tr:not(."+e.columnSelector_classHasSpan+') th[data-column="'+(o-1)+'"]',l.push(t+a+","+t+"_extra_table"+a),a=" tr:not(."+e.columnSelector_classHasSpan+") td:nth-child("+o+")",l.push(t+a+","+t+"_extra_table"+a),a=" tr td:not("+t+e.columnSelector_classHasSpan+')[data-column="'+(o-1)+'"]',l.push(t+a+","+t+"_extra_table"+a),l},updateBreakpoints:function(e,t){var o,l,a,n,c=[],r=e.selector,s=e.namespace+"columnselector",i=[],u="";if(t.columnSelector_mediaquery&&!r.auto)return r.$breakpoints.prop("disabled",!0),void r.$style.prop("disabled",!1);if(t.columnSelector_mediaqueryHidden)for(a=0;a<e.columns;a++)l=f.getColumnData(e.table,e.headers,a),c[a+1]="false"===f.getData(e.$headerIndexed[a],l,"columnSelector"),c[a+1]&&(i=i.concat(S.addSelectors(t,s,a+1)));for(o=0;o<t.columnSelector_maxPriorities;o++)n=[],e.$headers.filter("["+t.columnSelector_priority+"="+(o+1)+"]").each(function(){a=parseInt(h(this).attr("data-column"),10)+1,c[a]||(n=n.concat(S.addSelectors(t,s,a)))}),n.length&&(i=i.concat(n),u+=S.queryBreak.replace(/\[size\]/g,t.columnSelector_breakpoints[o]).replace(/\[columns\]/g,n.join(",")));r.$style&&r.$style.prop("disabled",!0),i.length&&r.$breakpoints.prop("disabled",!1).text(S.queryAll.replace(/\[columns\]/g,i.join(","))+u)},updateCols:function(e,t){if(!(t.columnSelector_mediaquery&&e.selector.auto||e.selector.isInitializing)){var o,l=e.selector,a=[],n=e.namespace+"columnselector";l.$container.find("input[data-column]").filter('[data-column!="auto"]').each(function(){this.checked||(o=parseInt(h(this).attr("data-column"),10)+1,a=a.concat(S.addSelectors(t,n,o))),h(this).toggleClass(t.columnSelector_cssChecked,this.checked)}),t.columnSelector_mediaquery&&l.$breakpoints.prop("disabled",!0),l.$style&&l.$style.prop("disabled",!1).text(a.length?a.join(",")+" { display: none; }":""),S.saveValues(e,t),S.adjustColspans(e,t),e.$table.triggerHandler(t.columnSelector_updated)}},setUpColspan:function(e,t){var o,l,a,n=h(window),c=!1,r=e.$table.add(h(e.namespace+"_extra_table")).children().children("tr").children("th, td"),s=r.length;for(o=0;o<s;o++)1<(l=r[o].colSpan)&&(c=!0,r.eq(o).addClass(e.namespace.slice(1)+"columnselector"+t.columnSelector_classHasSpan).attr("data-col-span",l),f.computeColumnIndex(r.eq(o).parent().addClass(t.columnSelector_classHasSpan)));c&&t.columnSelector_mediaquery&&(a=e.namespace+"columnselector",n.off(a).on("resize"+a,f.window_resize).on("resizeEnd"+a,function(){n.off("resize"+a,f.window_resize),S.adjustColspans(e,t),n.on("resize"+a,f.window_resize)}))},findHeaders:function(e){var t,o,l="."+f.css.scrollerHeader+" thead > tr > ",a=h(l+"th,"+l+"td"),n=[];for(t=0;t<e.columns;t++)o=a.filter('[data-column="'+t+'"]'),n[t]=o.length?o.not(".sorter-false").length?o.not(".sorter-false").filter(":last"):o.filter(":last"):h();return n},adjustColspans:function(e,t){var o,l,a,n,c,r,s=e.selector,i=t.filter_filteredRow||"filtered",u=t.columnSelector_mediaquery&&s.auto,d=e.$table.children("thead, tfoot").children().children().add(h(e.namespace+"_extra_table").children("thead, tfoot").children().children()).add(e.$table.find(".group-header").children()),p=d.length,m=f.hasWidget(e.table,"scroller")?S.findHeaders(e):e.$headerIndexed;for(o=0;o<p;o++)if(r=d.eq(o),c=(a=parseInt(r.attr("data-column"),10)||r[0].cellIndex)+(n=parseInt(r.attr("data-col-span"),10)||1),1<n){for(l=a;l<c;l++)(!u&&!1===s.states[l]||u&&m[l]&&!m[l].is(":visible"))&&n--;n?r.removeClass(i)[0].colSpan=n:r.addClass(i)}else void 0!==s.states[a]&&null!==s.states[a]&&r.toggleClass(i,!u&&!s.states[a])},saveValues:function(e,t){if(t.columnSelector_saveColumns&&f.storage){var o=e.selector;f.storage(e.$table[0],"tablesorter-columnSelector-auto",{auto:o.auto}),f.storage(e.$table[0],"tablesorter-columnSelector",o.states)}},attachTo:function(e,t){var o,l,a,n=(e=h(e)[0]).config,c=h(t);c.length&&n&&(c.find(".tablesorter-column-selector").length||c.append('<span class="tablesorter-column-selector"></span>'),o=n.selector,l=n.widgetOptions,c.find(".tablesorter-column-selector").html(o.$container.html()).find("input").each(function(){var e=h(this).attr("data-column"),t="auto"===e?o.auto:o.states[e];h(this).toggleClass(l.columnSelector_cssChecked,t).prop("checked",t)}),o.$popup=c.on("change","input",function(){if(!o.isInitializing){if(!S.checkChange(n,this.checked))return this.checked=!this.checked,!1;a=h(this).toggleClass(l.columnSelector_cssChecked,this.checked).attr("data-column"),o.$container.find('input[data-column="'+a+'"]').prop("checked",this.checked).trigger("change")}}))}};f.window_resize=function(){f.timer_resize&&clearTimeout(f.timer_resize),f.timer_resize=setTimeout(function(){h(window).trigger("resizeEnd")},250)},f.addWidget({id:"columnSelector",priority:10,options:{columnSelector_container:null,columnSelector_columns:{},columnSelector_saveColumns:!0,columnSelector_layout:'<label><input type="checkbox">{name}</label>',columnSelector_layoutCustomizer:null,columnSelector_name:"data-selector-name",columnSelector_mediaquery:!0,columnSelector_mediaqueryName:"Auto: ",columnSelector_mediaqueryState:!0,columnSelector_mediaqueryHidden:!1,columnSelector_maxVisible:null,columnSelector_minVisible:null,columnSelector_breakpoints:["20em","30em","40em","50em","60em","70em"],columnSelector_maxPriorities:6,columnSelector_priority:"data-priority",columnSelector_cssChecked:"checked",columnSelector_classHasSpan:"hasSpan",columnSelector_updated:"columnUpdate"},init:function(e,t,o,l){S.init(e,o,l)},remove:function(e,t,o,l){var a=t.selector;!l&&a&&(a&&a.$container.empty(),a.$popup&&a.$popup.empty(),a.$style.remove(),a.$breakpoints.remove(),h(t.namespace+"columnselector"+o.columnSelector_classHasSpan).removeClass(o.filter_filteredRow||"filtered"),t.$table.find("[data-col-span]").each(function(e,t){var o=h(t);o.attr("colspan",o.attr("data-col-span"))}),t.$table.off("updateAll"+c+" update"+c))}})}(jQuery);return jQuery;}));


/***/ }),

/***/ "./node_modules/tablesorter/dist/js/widgets/widget-pager.min.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tablesorter/dist/js/widgets/widget-pager.min.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory){if (true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));} else {}}(function(jQuery){

/*! Widget: Pager - updated 2020-03-03 (v2.31.3) */
!function(S){"use strict";var C,$=S.tablesorter;$.addWidget({id:"pager",priority:55,options:{pager_output:"{startRow} to {endRow} of {totalRows} rows",pager_updateArrows:!0,pager_startPage:0,pager_pageReset:0,pager_size:10,pager_maxOptionSize:20,pager_savePages:!0,pager_storageKey:"tablesorter-pager",pager_fixedHeight:!1,pager_countChildRows:!1,pager_removeRows:!1,pager_ajaxUrl:null,pager_customAjaxUrl:function(e,a){return a},pager_ajaxError:null,pager_ajaxObject:{dataType:"json"},pager_processAjaxOnInit:!0,pager_ajaxProcessing:function(e){return e},pager_css:{container:"tablesorter-pager",errorRow:"tablesorter-errorRow",disabled:"disabled"},pager_selectors:{container:".pager",first:".first",prev:".prev",next:".next",last:".last",gotoPage:".gotoPage",pageDisplay:".pagedisplay",pageSize:".pagesize"}},init:function(e){C.init(e)},format:function(e,a){if(!a.pager||!a.pager.initialized)return C.initComplete(a);C.moveToPage(a,a.pager,!1)},remove:function(e,a,t,r){C.destroyPager(a,r)}}),C=$.pager={init:function(e){if(!(e.hasInitialized&&e.config.pager&&e.config.pager.initialized)){var a,t=e.config,r=t.widgetOptions,i=r.pager_selectors,s=t.pager=S.extend({totalPages:0,filteredRows:0,filteredPages:0,currentFilters:[],page:r.pager_startPage,startRow:0,endRow:0,ajaxCounter:0,$size:null,last:{},setSize:r.pager_size,setPage:r.pager_startPage},t.pager);s.removeRows=r.pager_removeRows,s.isInitializing||(s.isInitializing=!0,$.debug(t,"pager")&&console.log("Pager >> Initializing"),s.size=S.data(e,"pagerLastSize")||r.pager_size,s.$container=S(i.container).addClass(r.pager_css.container).show(),s.totalRows=t.$tbodies.eq(0).children("tr").not(r.pager_countChildRows?"":"."+t.cssChildRow).length,s.oldAjaxSuccess=s.oldAjaxSuccess||r.pager_ajaxObject.success,t.appender=C.appender,s.initializing=!0,r.pager_savePages&&$.storage&&(a=$.storage(e,r.pager_storageKey)||{},s.page=(isNaN(a.page)?s.page:a.page)||s.setPage||0,s.size="all"===a.size?a.size:(isNaN(a.size)?s.size:a.size)||s.setSize||10,C.setPageSize(t,s.size)),s.regexRows=new RegExp("("+(r.filter_filteredRow||"filtered")+"|"+t.selectorRemove.slice(1)+"|"+t.cssChildRow+")"),s.regexFiltered=new RegExp(r.filter_filteredRow||"filtered"),s.initialized=!1,t.$table.triggerHandler("pagerBeforeInitialized",t),C.enablePager(t,!1),s.ajaxObject=r.pager_ajaxObject,s.ajaxObject.url=r.pager_ajaxUrl,"string"==typeof r.pager_ajaxUrl?(s.ajax=!0,r.filter_serversideFiltering=!0,t.serverSideSorting=!0,C.moveToPage(t,s)):(s.ajax=!1,$.appendCache(t,!0)))}},initComplete:function(e){var a=e.pager;C.bindEvents(e),a.ajax||C.hideRowsSetup(e),a.initialized=!0,a.initializing=!1,a.isInitializing=!1,C.setPageSize(e,a.size),$.debug(e,"pager")&&console.log("Pager >> Triggering pagerInitialized"),e.$table.triggerHandler("pagerInitialized",e),e.widgetOptions.filter_initialized&&$.hasWidget(e.table,"filter")||C.updatePageDisplay(e,!a.ajax)},bindEvents:function(i){var s,o,e,g=i.pager,n=i.widgetOptions,a=i.namespace+"pager",t=n.pager_selectors,r=$.debug(i,"pager");i.$table.off(a).on("filterInit filterStart ".split(" ").join(a+" "),function(e,a){var t;if(g.currentFilters=S.isArray(a)?a:i.$table.data("lastSearch"),g.ajax&&"filterInit"===e.type)return C.moveToPage(i,g,!1);t=$.filter.equalFilters?$.filter.equalFilters(i,i.lastSearch,g.currentFilters):(i.lastSearch||[]).join("")!==(g.currentFilters||[]).join(""),"filterStart"!==e.type||!1===n.pager_pageReset||t||(g.page=n.pager_pageReset)}).on("filterEnd sortEnd ".split(" ").join(a+" "),function(){g.currentFilters=i.$table.data("lastSearch"),(g.initialized||g.initializing)&&(i.delayInit&&i.rowsCopy&&0===i.rowsCopy.length&&C.updateCache(i),C.updatePageDisplay(i,!1),$.applyWidget(i.table))}).on("disablePager"+a,function(e){e.stopPropagation(),C.showAllRows(i)}).on("enablePager"+a,function(e){e.stopPropagation(),C.enablePager(i,!0)}).on("destroyPager"+a,function(e){e.stopPropagation(),$.removeWidget(i.table,"pager",!1)}).on("updateComplete"+a,function(e,a,t){if(e.stopPropagation(),a&&!t&&!g.ajax){var r=i.$tbodies.eq(0).children("tr").not(i.selectorRemove);g.totalRows=r.length-(n.pager_countChildRows?0:r.filter("."+i.cssChildRow).length),g.totalPages="all"===g.size?1:Math.ceil(g.totalRows/g.size),r.length&&i.rowsCopy&&0===i.rowsCopy.length&&C.updateCache(i),g.page>=g.totalPages&&C.moveToLastPage(i,g),C.hideRows(i),C.changeHeight(i),C.updatePageDisplay(i,!1),$.applyWidget(a),C.updatePageDisplay(i)}}).on("pageSize refreshComplete ".split(" ").join(a+" "),function(e,a){e.stopPropagation(),C.setPageSize(i,C.parsePageSize(i,a,"get")),C.moveToPage(i,g,!0),C.hideRows(i),C.updatePageDisplay(i,!1)}).on("pageSet pagerUpdate ".split(" ").join(a+" "),function(e,a){e.stopPropagation(),"pagerUpdate"===e.type&&(a=void 0===a?g.page+1:a,g.last.page=!0),g.page=(parseInt(a,10)||1)-1,C.moveToPage(i,g,!0),C.updatePageDisplay(i,!1)}).on("pageAndSize"+a,function(e,a,t){e.stopPropagation(),g.page=(parseInt(a,10)||1)-1,C.setPageSize(i,C.parsePageSize(i,t,"get")),C.moveToPage(i,g,!0),C.hideRows(i),C.updatePageDisplay(i,!1)}),s=[t.first,t.prev,t.next,t.last],o=["moveToFirstPage","moveToPrevPage","moveToNextPage","moveToLastPage"],r&&!g.$container.length&&console.warn('Pager >> "container" not found'),g.$container.find(s.join(",")).attr("tabindex",0).off("click"+a).on("click"+a,function(e){e.stopPropagation();var a,t=S(this),r=s.length;if(!t.hasClass(n.pager_css.disabled))for(a=0;a<r;a++)if(t.is(s[a])){C[o[a]](i,g);break}}),(e=g.$container.find(n.pager_selectors.gotoPage)).length?e.off("change"+a).on("change"+a,function(){g.page=S(this).val()-1,C.moveToPage(i,g,!0),C.updatePageDisplay(i,!1)}):r&&console.warn('Pager >> "goto" selector not found'),(e=g.$container.find(n.pager_selectors.pageSize)).length?(e.find("option").removeAttr("selected"),e.off("change"+a).on("change"+a,function(){if(!S(this).hasClass(n.pager_css.disabled)){var e=S(this).val();g.$container.find(n.pager_selectors.pageSize).val(e),C.setPageSize(i,e),C.moveToPage(i,g,!0),C.changeHeight(i)}return!1})):r&&console.warn('Pager >> "size" selector not found')},pagerArrows:function(e,a){var t=e.pager,r=!!a,i=r||0===t.page,s=C.getTotalPages(e,t),o=r||t.page===s-1||0===s,g=e.widgetOptions,n=g.pager_selectors;g.pager_updateArrows&&(t.$container.find(n.first+","+n.prev).toggleClass(g.pager_css.disabled,i).prop("aria-disabled",i),t.$container.find(n.next+","+n.last).toggleClass(g.pager_css.disabled,o).prop("aria-disabled",o))},calcFilters:function(e){var a,t,r,i=e.widgetOptions,s=e.pager,o=e.$table.hasClass("hasFilters");if(o&&!s.ajax)if(S.isEmptyObject(e.cache))s.filteredRows=s.totalRows=e.$tbodies.eq(0).children("tr").not(i.pager_countChildRows?"":"."+e.cssChildRow).length;else for(s.filteredRows=0,r=(a=e.cache[0].normalized).length,t=0;t<r;t++)s.filteredRows+=s.regexRows.test(a[t][e.columns].$row[0].className)?0:1;else o||(s.filteredRows=s.totalRows)},updatePageDisplay:function(t,e){if(!t.pager||!t.pager.initializing){var a,r,i,s,o,g,n,l=t.table,p=t.widgetOptions,d=t.pager,c=t.namespace+"pager",f=C.parsePageSize(t,d.size,"get");if("all"===f&&(f=d.totalRows),p.pager_countChildRows&&(r[r.length]=t.cssChildRow),d.$container.find(p.pager_selectors.pageSize+","+p.pager_selectors.gotoPage).removeClass(p.pager_css.disabled).removeAttr("disabled").prop("aria-disabled","false"),d.totalPages=Math.ceil(d.totalRows/f),t.totalRows=d.totalRows,C.parsePageNumber(t,d),C.calcFilters(t),t.filteredRows=d.filteredRows,d.filteredPages=Math.ceil(d.filteredRows/f)||0,0<=C.getTotalPages(t,d)){if(r=f*d.page>d.filteredRows&&e,d.page=r?p.pager_pageReset||0:d.page,d.startRow=r?f*d.page+1:0===d.filteredRows?0:f*d.page+1,d.endRow=Math.min(d.filteredRows,d.totalRows,f*(d.page+1)),i=d.$container.find(p.pager_selectors.pageDisplay),a="function"==typeof p.pager_output?p.pager_output(l,d):(n=i.attr("data-pager-output"+(d.filteredRows<d.totalRows?"-filtered":""))||p.pager_output,(d.ajaxData&&d.ajaxData.output&&d.ajaxData.output||n).replace(/\{page([\-+]\d+)?\}/gi,function(e,a){return d.totalPages?d.page+(a?parseInt(a,10):1):0}).replace(/\{\w+(\s*:\s*\w+)?\}/gi,function(e){var a,t,r=e.replace(/[{}\s]/g,""),i=r.split(":"),s=d.ajaxData,o=/(rows?|pages?)$/i.test(r)?0:"";return/(startRow|page)/.test(i[0])&&"input"===i[1]?(a=(""+("page"===i[0]?d.totalPages:d.totalRows)).length,t="page"===i[0]?d.page+1:d.startRow,'<input type="text" class="ts-'+i[0]+'" style="max-width:'+a+'em" value="'+t+'"/>'):1<i.length&&s&&s[i[0]]?s[i[0]][i[1]]:d[r]||(s?s[r]:o)||o})),d.$container.find(p.pager_selectors.gotoPage).length){for(r="",g=(s=C.buildPageSelect(t,d)).length,o=0;o<g;o++)r+='<option value="'+s[o]+'">'+s[o]+"</option>";d.$container.find(p.pager_selectors.gotoPage).html(r).val(d.page+1)}i.length&&(i["INPUT"===i[0].nodeName?"val":"html"](a),i.find(".ts-startRow, .ts-page").off("change"+c).on("change"+c,function(){var e=S(this).val(),a=S(this).hasClass("ts-startRow")?Math.floor(e/f)+1:e;t.$table.triggerHandler("pageSet"+c,[a])}))}C.pagerArrows(t),C.fixHeight(t),d.initialized&&!1!==e&&($.debug(t,"pager")&&console.log("Pager >> Triggering pagerComplete"),t.$table.triggerHandler("pagerComplete",t),p.pager_savePages&&$.storage&&$.storage(l,p.pager_storageKey,{page:d.page,size:f===d.totalRows?"all":f}))}},buildPageSelect:function(e,a){var t,r,i,s,o,g,n=e.widgetOptions,l=C.getTotalPages(e,a)||1,p=5*Math.ceil(l/n.pager_maxOptionSize/5),d=l>n.pager_maxOptionSize,c=a.page+1,f=p,u=l-p,h=[1];for(t=d?p:1;t<=l;)h[h.length]=t,t+=d?p:1;if(h[h.length]=l,d){for(i=[],(f=c-(r=Math.max(Math.floor(n.pager_maxOptionSize/p)-1,5)))<1&&(f=1),l<(u=c+r)&&(u=l),t=f;t<=u;t++)i[i.length]=t;p/2<(o=(h=S.grep(h,function(e,a){return S.inArray(e,h)===a})).length)-(g=i.length)&&o+g>n.pager_maxOptionSize&&(s=Math.floor(o/2)-Math.floor(g/2),Array.prototype.splice.apply(h,[s,g])),h=h.concat(i)}return h=S.grep(h,function(e,a){return S.inArray(e,h)===a}).sort(function(e,a){return e-a})},fixHeight:function(e){var a,t,r,i=e.table,s=e.pager,o=e.widgetOptions,g=e.$tbodies.eq(0);g.find("tr.pagerSavedHeightSpacer").remove(),o.pager_fixedHeight&&!s.isDisabled&&(t=S.data(i,"pagerSavedHeight"))&&(r=0,1<S(i).css("border-spacing").split(" ").length&&(r=S(i).css("border-spacing").split(" ")[1].replace(/[^-\d\.]/g,"")),5<(a=t-g.height()+r*s.size-r)&&S.data(i,"pagerLastSize")===s.size&&g.children("tr:visible").length<("all"===s.size?s.totalRows:s.size)&&g.append('<tr class="pagerSavedHeightSpacer '+e.selectorRemove.slice(1)+'" style="height:'+a+'px;"></tr>'))},changeHeight:function(e){var a,t=e.table,r=e.pager,i="all"===r.size?r.totalRows:r.size,s=e.$tbodies.eq(0);s.find("tr.pagerSavedHeightSpacer").remove(),s.children("tr:visible").length||s.append('<tr class="pagerSavedHeightSpacer '+e.selectorRemove.slice(1)+'"><td>&nbsp</td></tr>'),a=s.children("tr").eq(0).height()*i,S.data(t,"pagerSavedHeight",a),C.fixHeight(e),S.data(t,"pagerLastSize",r.size)},hideRows:function(e){if(!e.widgetOptions.pager_ajaxUrl){var a,t,r,i,s,o=e.pager,g=e.widgetOptions,n=e.$tbodies.length,l="all"===o.size?o.totalRows:o.size,p=o.page*l,d=p+l,c=-1,f=0;for(o.cacheIndex=[],a=0;a<n;a++){for(i=(r=e.$tbodies.eq(a).children("tr")).length,c=-1,t=f=s=0;t<i;t++)o.regexFiltered.test(r[t].className)||(f===p&&r[t].className.match(e.cssChildRow)?r[t].style.display="none":(r[t].style.display=p<=f&&f<d?"":"none",c!==f&&p<=f&&f<d&&(o.cacheIndex[o.cacheIndex.length]=t,c=f),(f+=r[t].className.match(e.cssChildRow+"|"+e.selectorRemove.slice(1))&&!g.pager_countChildRows?0:1)===d&&"none"!==r[t].style.display&&r[t].className.match($.css.cssHasChild)&&(s=t)));if(0<s&&r[s].className.match($.css.cssHasChild))for(;++s<i&&r[s].className.match(e.cssChildRow);)r[s].style.display=""}}},hideRowsSetup:function(e){var a=e.pager,t=e.namespace+"pager",r=a.$container.find(e.widgetOptions.pager_selectors.pageSize).val();a.size=C.parsePageSize(e,r,"get"),C.setPageSize(e,a.size),C.pagerArrows(e),e.widgetOptions.pager_removeRows||(C.hideRows(e),e.$table.on("sortEnd filterEnd ".split(" ").join(t+" "),function(){C.hideRows(e)}))},renderAjax:function(e,a,t,r,i){var s=a.table,o=a.pager,g=a.widgetOptions,n=$.debug(a,"pager");if(S.isFunction(g.pager_ajaxProcessing)){a.$tbodies.eq(0).empty();var l,p,d,c,f,u,h,w,P,b,z,R,v,m,x,j=a.$table,_="",y=g.pager_ajaxProcessing(e,s,t)||[0,[]];if($.showError(s),i)n&&console.error("Pager >> Ajax Error",t,r,i),$.showError(s,t,r,i),a.$tbodies.eq(0).children("tr").detach(),o.totalRows=0;else{if(S.isArray(y)?(v=y[(d=isNaN(y[0])&&!isNaN(y[1]))?1:0],o.totalRows=isNaN(v)?o.totalRows||0:v,a.totalRows=a.filteredRows=o.filteredRows=o.totalRows,z=0===o.totalRows?[]:y[d?0:1]||[],b=y[2]):(o.ajaxData=y,a.totalRows=o.totalRows=y.total,a.filteredRows=o.filteredRows=void 0!==y.filteredRows?y.filteredRows:y.total,b=y.headers,z=y.rows||[]),R=z&&z.length,z instanceof S)g.pager_processAjaxOnInit&&(a.$tbodies.eq(0).empty(),a.$tbodies.eq(0).append(z));else if(R){for(l=0;l<R;l++){for(_+="<tr>",p=0;p<z[l].length;p++)_+=/^\s*<td/.test(z[l][p])?S.trim(z[l][p]):"<td>"+z[l][p]+"</td>";_+="</tr>"}g.pager_processAjaxOnInit&&a.$tbodies.eq(0).html(_)}if(g.pager_processAjaxOnInit=!0,b){for(u=(c=j.hasClass("hasStickyHeaders"))?g.$sticky.children("thead:first").children("tr:not(."+a.cssIgnoreRow+")").children():"",f=j.find("tfoot tr:first").children(),m=(h=a.$headers.filter("th")).length,p=0;p<m;p++)(w=h.eq(p)).find("."+$.css.icon).length?(P=w.find("."+$.css.icon).clone(!0),w.find("."+$.css.headerIn).html(b[p]).append(P),c&&u.length&&(P=u.eq(p).find("."+$.css.icon).clone(!0),u.eq(p).find("."+$.css.headerIn).html(b[p]).append(P))):(w.find("."+$.css.headerIn).html(b[p]),c&&u.length&&(o.$container=o.$container.add(g.$sticky),u.eq(p).find("."+$.css.headerIn).html(b[p]))),f.eq(p).html(b[p]);c&&C.bindEvents(a)}}a.showProcessing&&$.isProcessing(s),x=C.parsePageSize(a,o.size,"get"),o.totalPages="all"===x?1:Math.ceil(o.totalRows/x),o.last.totalRows=o.totalRows,o.last.currentFilters=o.currentFilters,o.last.sortList=(a.sortList||[]).join(","),o.initializing=!1,C.updatePageDisplay(a,!1),$.updateCache(a,function(){o.initialized&&setTimeout(function(){n&&console.log("Pager >> Triggering pagerChange"),j.triggerHandler("pagerChange",o),$.applyWidget(s),C.updatePageDisplay(a)},0)})}o.initialized||$.applyWidget(s)},getAjax:function(i){var r,e=C.getAjaxUrl(i),s=S(document),o=i.namespace+"pager",g=i.pager;""!==e&&(i.showProcessing&&$.isProcessing(i.table,!0),s.on("ajaxError"+o,function(e,a,t,r){C.renderAjax(null,i,a,t,r),s.off("ajaxError"+o)}),r=++g.ajaxCounter,g.last.ajaxUrl=e,g.ajaxObject.url=e,g.ajaxObject.success=function(e,a,t){r<g.ajaxCounter||(C.renderAjax(e,i,t),s.off("ajaxError"+o),"function"==typeof g.oldAjaxSuccess&&g.oldAjaxSuccess(e))},$.debug(i,"pager")&&console.log("Pager >> Ajax initialized",g.ajaxObject),S.ajax(g.ajaxObject))},getAjaxUrl:function(e){var a,t,r=e.pager,i=e.widgetOptions,s=i.pager_ajaxUrl?i.pager_ajaxUrl.replace(/\{page([\-+]\d+)?\}/,function(e,a){return r.page+(a?parseInt(a,10):0)}).replace(/\{size\}/g,r.size):"",o=e.sortList,g=r.currentFilters||e.$table.data("lastSearch")||[],n=s.match(/\{\s*sort(?:List)?\s*:\s*(\w*)\s*\}/),l=s.match(/\{\s*filter(?:List)?\s*:\s*(\w*)\s*\}/),p=[];if(n){for(n=n[1],t=o.length,a=0;a<t;a++)p[p.length]=n+"["+o[a][0]+"]="+o[a][1];s=s.replace(/\{\s*sort(?:List)?\s*:\s*(\w*)\s*\}/g,p.length?p.join("&"):n),p=[]}if(l){for(l=l[1],t=g.length,a=0;a<t;a++)g[a]&&(p[p.length]=l+"["+a+"]="+encodeURIComponent(g[a]));s=s.replace(/\{\s*filter(?:List)?\s*:\s*(\w*)\s*\}/g,p.length?p.join("&"):l),r.currentFilters=g}return S.isFunction(i.pager_customAjaxUrl)&&(s=i.pager_customAjaxUrl(e.table,s)),$.debug(e,"pager")&&console.log("Pager >> Ajax url = "+s),s},renderTable:function(e,a){var t,r,i,s,o=e.table,g=e.pager,n=e.widgetOptions,l=$.debug(e,"pager"),p=e.$table.hasClass("hasFilters"),d=a&&a.length||0,c="all"===g.size?g.totalRows:g.size,f=g.page*c;if(d<1)l&&console.warn("Pager >> No rows for pager to render");else{if(g.page>=g.totalPages)return C.moveToLastPage(e,g);if(g.cacheIndex=[],g.isDisabled=!1,g.initialized&&(l&&console.log("Pager >> Triggering pagerChange"),e.$table.triggerHandler("pagerChange",e)),n.pager_removeRows){for($.clearTableBody(o),t=$.processTbody(o,e.$tbodies.eq(0),!0),i=r=p?0:f,s=0;s<c&&r<a.length;)p&&g.regexFiltered.test(a[r][0].className)||f<++i&&s<=c&&(s++,g.cacheIndex[g.cacheIndex.length]=r,t.append(a[r])),r++;$.processTbody(o,t,!1)}else C.hideRows(e);C.updatePageDisplay(e),n.pager_startPage=g.page,n.pager_size=g.size,o.isUpdating&&(l&&console.log("Pager >> Triggering updateComplete"),e.$table.triggerHandler("updateComplete",[o,!0]))}},showAllRows:function(e){var a,t,r,i=e.table,s=e.pager,o=e.widgetOptions;for(s.ajax?C.pagerArrows(e,!0):(S.data(i,"pagerLastPage",s.page),S.data(i,"pagerLastSize",s.size),s.page=0,s.size=s.totalRows,s.totalPages=1,e.$table.addClass("pagerDisabled").removeAttr("aria-describedby").find("tr.pagerSavedHeightSpacer").remove(),C.renderTable(e,e.rowsCopy),s.isDisabled=!0,$.applyWidget(i),$.debug(e,"pager")&&console.log("Pager >> Disabled")),r=(t=s.$container.find(o.pager_selectors.pageSize+","+o.pager_selectors.gotoPage+",.ts-startRow, .ts-page")).length,a=0;a<r;a++)t.eq(a).prop("aria-disabled","true").addClass(o.pager_css.disabled)[0].disabled=!0},updateCache:function(r){var i=r.pager;$.updateCache(r,function(){if(!S.isEmptyObject(r.cache)){var e,a=[],t=r.cache[0].normalized;for(i.totalRows=t.length,e=0;e<i.totalRows;e++)a[a.length]=t[e][r.columns].$row;r.rowsCopy=a,C.moveToPage(r,i,!0),i.last.currentFilters=[" "]}})},moveToPage:function(e,a,t){if(!a.isDisabled){if(!1!==t&&a.initialized&&S.isEmptyObject(e.cache))return C.updateCache(e);var r,i=e.table,s=e.widgetOptions,o=a.last,g=$.debug(e,"pager");a.ajax&&!s.filter_initialized&&$.hasWidget(i,"filter")||(C.parsePageNumber(e,a),C.calcFilters(e),o.currentFilters=""===(o.currentFilters||[]).join("")?[]:o.currentFilters,a.currentFilters=""===(a.currentFilters||[]).join("")?[]:a.currentFilters,o.page===a.page&&o.size===a.size&&o.totalRows===a.totalRows&&(o.currentFilters||[]).join(",")===(a.currentFilters||[]).join(",")&&(o.ajaxUrl||"")===(a.ajaxObject.url||"")&&(o.optAjaxUrl||"")===(s.pager_ajaxUrl||"")&&o.sortList===(e.sortList||[]).join(",")||(g&&console.log("Pager >> Changing to page "+a.page),a.last={page:a.page,size:a.size,sortList:(e.sortList||[]).join(","),totalRows:a.totalRows,currentFilters:a.currentFilters||[],ajaxUrl:a.ajaxObject.url||"",optAjaxUrl:s.pager_ajaxUrl},a.ajax?s.pager_processAjaxOnInit||S.isEmptyObject(s.pager_initialRows)?C.getAjax(e):(s.pager_processAjaxOnInit=!0,r=s.pager_initialRows,a.totalRows=void 0!==r.total?r.total:g&&console.error("Pager >> No initial total page set!")||0,a.filteredRows=void 0!==r.filtered?r.filtered:g&&console.error("Pager >> No initial filtered page set!")||0,C.updatePageDisplay(e,!1)):a.ajax||C.renderTable(e,e.rowsCopy),S.data(i,"pagerLastPage",a.page),a.initialized&&!1!==t&&(g&&console.log("Pager >> Triggering pageMoved"),e.$table.triggerHandler("pageMoved",e),$.applyWidget(i),!a.ajax&&i.isUpdating&&(g&&console.log("Pager >> Triggering updateComplete"),e.$table.triggerHandler("updateComplete",[i,!0])))))}},getTotalPages:function(e,a){return $.hasWidget(e.table,"filter")?Math.min(a.totalPages,a.filteredPages):a.totalPages},parsePageNumber:function(e,a){var t=C.getTotalPages(e,a)-1;return a.page=parseInt(a.page,10),(a.page<0||isNaN(a.page))&&(a.page=0),a.page>t&&0<=t&&(a.page=t),a.page},parsePageSize:function(e,a,t){var r=e.pager,i=e.widgetOptions,s=parseInt(a,10)||r.size||i.pager_size||10;return r.initialized&&(/all/i.test(s+" "+a)||s===r.totalRows)?r.$container.find(i.pager_selectors.pageSize+' option[value="all"]').length?"all":r.totalRows:"get"===t?s:r.size},setPageSize:function(e,a){var t=e.pager,r=e.table;t.size=C.parsePageSize(e,a,"get"),t.$container.find(e.widgetOptions.pager_selectors.pageSize).val(t.size),S.data(r,"pagerLastPage",C.parsePageNumber(e,t)),S.data(r,"pagerLastSize",t.size),t.totalPages="all"===t.size?1:Math.ceil(t.totalRows/t.size),t.filteredPages="all"===t.size?1:Math.ceil(t.filteredRows/t.size)},moveToFirstPage:function(e,a){a.page=0,C.moveToPage(e,a,!0)},moveToLastPage:function(e,a){a.page=C.getTotalPages(e,a)-1,C.moveToPage(e,a,!0)},moveToNextPage:function(e,a){a.page++;var t=C.getTotalPages(e,a)-1;a.page>=t&&(a.page=t),C.moveToPage(e,a,!0)},moveToPrevPage:function(e,a){a.page--,a.page<=0&&(a.page=0),C.moveToPage(e,a,!0)},destroyPager:function(e,a){var t=e.table,r=e.pager,i=e.widgetOptions.pager_selectors||{},s=[i.first,i.prev,i.next,i.last,i.gotoPage,i.pageSize].join(","),o=e.namespace+"pager";if(r){if(r.initialized=!1,e.$table.off(o),r.$container.hide().find(s).off(o),a)return;e.appender=null,C.showAllRows(e),$.storage&&$.storage(t,e.widgetOptions.pager_storageKey,""),r.$container=null,e.pager=null,e.rowsCopy=null}},enablePager:function(e,a){var t,r,i=e.table,s=e.pager,o=e.widgetOptions,g=s.$container.find(o.pager_selectors.pageSize);s.isDisabled=!1,s.page=S.data(i,"pagerLastPage")||s.page||0,r=g.find("option[selected]").val(),s.size=S.data(i,"pagerLastSize")||C.parsePageSize(e,r,"get"),C.setPageSize(e,s.size),s.totalPages="all"===s.size?1:Math.ceil(C.getTotalPages(e,s)/s.size),e.$table.removeClass("pagerDisabled"),i.id&&!e.$table.attr("aria-describedby")&&((t=(g=s.$container.find(o.pager_selectors.pageDisplay)).attr("id"))||(t=i.id+"_pager_info",g.attr("id",t)),e.$table.attr("aria-describedby",t)),C.changeHeight(e),a&&($.update(e),C.setPageSize(e,s.size),C.moveToPage(e,s,!0),C.hideRowsSetup(e),$.debug(e,"pager")&&console.log("Pager >> Enabled"))},appender:function(e,a){var t=e.config,r=t.widgetOptions,i=t.pager;i.ajax?C.moveToPage(t,i,!0):(t.rowsCopy=a,i.totalRows=r.pager_countChildRows?t.$tbodies.eq(0).children("tr").length:a.length,i.size=S.data(e,"pagerLastSize")||i.size||r.pager_size||i.setSize||10,i.totalPages="all"===i.size?1:Math.ceil(i.totalRows/i.size),C.moveToPage(t,i),C.updatePageDisplay(t,!1))}},$.showError=function(e,a,t,r){function i(){o.$table.find("thead").find(o.selectorRemove).remove()}var s=S(e),o=s[0].config,g=o&&o.widgetOptions,n=o.pager&&o.pager.cssErrorRow||g&&g.pager_css&&g.pager_css.errorRow||"tablesorter-errorRow",l=typeof a,p=!0,d="";if(s.length){if("function"==typeof o.pager.ajaxError){if(!1===(p=o.pager.ajaxError(o,a,t,r)))return i();d=p}else if("function"==typeof g.pager_ajaxError){if(!1===(p=g.pager_ajaxError(o,a,t,r)))return i();d=p}if(""===d)if("object"==l)d=0===a.status?"Not connected, verify Network":404===a.status?"Requested page not found [404]":500===a.status?"Internal Server Error [500]":"parsererror"===r?"Requested JSON parse failed":"timeout"===r?"Time out error":"abort"===r?"Ajax Request aborted":"Uncaught error: "+a.statusText+" ["+a.status+"]";else{if("string"!=l)return i();d=a}S(/tr\>/.test(d)?d:'<tr><td colspan="'+o.columns+'">'+d+"</td></tr>").click(function(){S(this).remove()}).appendTo(o.$table.find("thead:first")).addClass(n+" "+o.selectorRemove.slice(1)).attr({role:"alert","aria-live":"assertive"})}else console.error("tablesorter showError: no table parameter passed")}}(jQuery);return jQuery;}));


/***/ }),

/***/ "./node_modules/tablesorter/dist/js/widgets/widget-reflow.min.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tablesorter/dist/js/widgets/widget-reflow.min.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory){if (true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));} else {}}(function(jQuery){

!function(u){"use strict";var h=u.tablesorter,w={init:function(e,t,l){var o,r=l.reflow_dataAttrib,a=l.reflow_headerAttrib,s=[];t.$table.addClass(l.reflow_className).off("refresh.tsreflow updateComplete.tsreflow2").on("refresh.tsreflow updateComplete.tsreflow2",function(){w.init(e,t,l)}),t.$headers.each(function(){o=u(this),s.push(u.trim(o.attr(a)||o.text()))}),t.$tbodies.children().each(function(){u(this).children().each(function(e){u(this).attr(r,s[e])})})},init2:function(e,t,l){var o,r,a,s,i,n,f=t.columns,c=l.reflow2_headerAttrib,d=[];for(t.$table.addClass(l.reflow2_className).off("refresh.tsreflow2 updateComplete.tsreflow2").on("refresh.tsreflow2 updateComplete.tsreflow2",function(){w.init2(e,t,l)}),a=0;a<f;a++)1<(s=t.$headers.filter('[data-column="'+a+'"]')).length?(i=[],s.each(function(){(o=u(this)).hasClass(l.reflow2_classIgnore)||i.push(o.attr(c)||o.text())})):i=[s.attr(c)||s.text()],d.push(i);i='<b class="'+t.selectorRemove.slice(1)+" "+l.reflow2_labelClass,t.$tbodies.children().each(function(){(r=h.processTbody(e,u(this),!0)).children().each(function(e){for(o=u(this),n=d[e].length,a=n-1;0<=a;)o.prepend(i+(0===a&&1<n?" "+l.reflow2_labelTop:"")+'">'+d[e][a]+"</b>"),a--}),h.processTbody(e,r,!1)})},remove:function(e,t,l){t.$table.removeClass(l.reflow_className)},remove2:function(e,t,l){t.$table.removeClass(l.reflow2_className)}};h.addWidget({id:"reflow",options:{reflow_className:"ui-table-reflow",reflow_headerAttrib:"data-name",reflow_dataAttrib:"data-title"},init:function(e,t,l,o){w.init(e,l,o)},remove:function(e,t,l){w.remove(e,t,l)}}),h.addWidget({id:"reflow2",options:{reflow2_className:"ui-table-reflow",reflow2_classIgnore:"ui-table-reflow-ignore",reflow2_headerAttrib:"data-name",reflow2_labelClass:"ui-table-cell-label",reflow2_labelTop:"ui-table-cell-label-top"},init:function(e,t,l,o){w.init2(e,l,o)},remove:function(e,t,l){w.remove2(e,t,l)}})}(jQuery);return jQuery;}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdXNlcmZyb3N0aW5nX3Nwcmlua2xlLWFkbWluX2FwcF9hc3NldHNfZGFzaGJvYXJkX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxtQkFBTyxDQUFDLDZJQUF5QztBQUNqRCxtQkFBTyxDQUFDLCtDQUFRO0FBQ2hCLG1CQUFPLENBQUMsc0ZBQWE7QUFDckIsbUJBQU8sQ0FBQyx5SUFBMEQ7QUFDbEUsbUJBQU8sQ0FBQyx5SEFBa0Q7QUFDMUQsbUJBQU8sQ0FBQyx1SEFBaUQ7QUFDekQsbUJBQU8sQ0FBQyx1S0FBeUU7QUFDakYsbUJBQU8sQ0FBQyx1TUFBeUY7QUFDakcsbUJBQU8sQ0FBQyw0SkFBa0U7O0FBRTFFLG1CQUFPLENBQUMsNklBQXlDO0FBQ2pELG1CQUFPLENBQUMsaUhBQThDO0FBQ3RELG1CQUFPLENBQUMsbUlBQXVEO0FBQy9ELG1CQUFPLENBQUMsdUxBQWlGO0FBQ3pGLG1CQUFPLENBQUMsaUpBQTJDOzs7Ozs7Ozs7OztBQ2ZuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QyxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLHdCQUF3QixNQUFNO0FBQzlCLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQSx5QkFBeUIsRUFBRSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRix5Q0FBeUM7QUFDekMsb0NBQW9DLEtBQUssU0FBUyxJQUFJLFNBQVMsRUFBRSxRQUFRLElBQUksSUFBSSxFQUFFLEtBQUssRUFBRTtBQUMxRixpQ0FBaUMsSUFBSSxTQUFTLEtBQUssTUFBTSxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGLCtEQUErRDtBQUMvRCxnQ0FBZ0MsSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLFdBQVcsSUFBSSxXQUFXLEVBQUU7QUFDOUQsOEJBQThCLEVBQUUsV0FBVyxJQUFJLFdBQVcsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELHdFQUF3RTtBQUN4RTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DLHFGQUFxRixvQ0FBb0M7QUFDekg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFlBQVk7QUFDaEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3RELG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQSw4REFBOEQsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDLE1BQU0sa0NBQWtDLEVBQUUsSUFBSSxLQUFLLEdBQUc7QUFDOUgsNEJBQTRCO0FBQzVCO0FBQ0EsdUVBQXVFO0FBQ3ZFLHFDQUFxQyxPQUFPLDZEQUE2RDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDLGlEQUFpRDtBQUNsSDtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDhCQUE4QjtBQUN2RCx3RUFBd0U7QUFDeEU7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIs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LDhCQUE4Qiw4QkFBOEIsbURBQW1ELDhCQUE4QixTQUFTLDZCQUE2QiwyQ0FBMkMsOEJBQThCLG9EQUFvRCw0QkFBNEIsNkRBQTZELHdGQUF3RixNQUFNLGdGQUFnRiw2SUFBNkksMkJBQTJCLDhGQUE4RixpbkJBQWluQix3QkFBd0IsMkNBQTJDLDZTQUE2UywrQkFBK0IsYUFBYSx1REFBdUQsZ0tBQWdLLGFBQWEseUNBQXlDLGtEQUFrRCxJQUFJLDhDQUE4QyxrREFBa0QsSUFBSSx5VUFBeVUsS0FBSywwQkFBMEIsSUFBSSx1RkFBdUYsaUJBQWlCLHlGQUF5RixxQ0FBcUMsRUFBRSx3RUFBd0UsU0FBUyxlQUFlOzs7Ozs7Ozs7OztBQ0hyN3NCLG1IQUFtQixJQUFJLElBQTBDLEVBQUUsaUNBQU8sQ0FBQyx5RUFBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUMsR0FBRyxLQUFLLEVBQTJJLENBQUM7O0FBRWxQLGFBQWEsYUFBYSx1QkFBdUIscUJBQXFCLHlEQUF5RCxpSkFBaUosY0FBYyw2QkFBNkIsOENBQThDLHdDQUF3QyxvQ0FBb0MscUJBQXFCLEVBQUUsRUFBRSx1QkFBdUIsMERBQTBELHdKQUF3SixlQUFlLE1BQU0sSUFBSSxvRkFBb0YseUVBQXlFLHFDQUFxQyx3R0FBd0csNkRBQTZELGtDQUFrQyxLQUFLLDZFQUE2RSx5QkFBeUIsRUFBRSx3QkFBd0IseUNBQXlDLHlCQUF5Qiw0Q0FBNEMsYUFBYSxxQkFBcUIsa0dBQWtHLHdCQUF3QixjQUFjLHdCQUF3QixpQkFBaUIsZUFBZSxzQkFBc0Isc01BQXNNLHdCQUF3QixlQUFlLHdCQUF3QixrQkFBa0IsRUFBRSxTQUFTLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVzZXJmcm9zdGluZy9zcHJpbmtsZS1hZG1pbi9hcHAvYXNzZXRzL2Rhc2hib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVzZXJmcm9zdGluZy9zcHJpbmtsZS1hZG1pbi9hcHAvYXNzZXRzL3VzZXJmcm9zdGluZy9qcy9oYW5kbGViYXJzLWhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1c2VyZnJvc3RpbmcvdGhlbWUtYWRtaW5sdGUvYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvanMvcXVlcnktc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdXNlcmZyb3N0aW5nL3RoZW1lLWFkbWlubHRlL2FwcC9hc3NldHMvdXNlcmZyb3N0aW5nL2pzL3RhYmxlc29ydGVyL3dpZGdldC1zb3J0Mkhhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1c2VyZnJvc3RpbmcvdGhlbWUtYWRtaW5sdGUvYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvanMvdWYtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1c2VyZnJvc3Rpbmcvc3ByaW5rbGUtYWRtaW4vYXBwL2Fzc2V0cy9mb250LXN0YXJjcmFmdC9jc3MvZm9udC1zdGFyY3JhZnQuY3NzP2VlMzYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1c2VyZnJvc3Rpbmcvc3ByaW5rbGUtYWRtaW4vYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvY3NzL3RhYmxlc29ydGVyLWN1c3RvbS5jc3M/ZDc4NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVzZXJmcm9zdGluZy90aGVtZS1hZG1pbmx0ZS9hcHAvYXNzZXRzL3VzZXJmcm9zdGluZy9jc3MvdGFibGVzb3J0ZXItcmVmbG93LmNzcz9jYzE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJsZXNvcnRlci9kaXN0L2Nzcy9qcXVlcnkudGFibGVzb3J0ZXIucGFnZXIubWluLmNzcz9hOWE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJsZXNvcnRlci9kaXN0L2Nzcy90aGVtZS5ib290c3RyYXAubWluLmNzcz9kOTUwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJsZXNvcnRlci9kaXN0L2pzL2pxdWVyeS50YWJsZXNvcnRlci5jb21iaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFibGVzb3J0ZXIvZGlzdC9qcy93aWRnZXRzL3dpZGdldC1jb2x1bW5TZWxlY3Rvci5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RhYmxlc29ydGVyL2Rpc3QvanMvd2lkZ2V0cy93aWRnZXQtcGFnZXIubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJsZXNvcnRlci9kaXN0L2pzL3dpZGdldHMvd2lkZ2V0LXJlZmxvdy5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLS0tLS0tIEltcG9ydCBCYXNlIFRoZW1lIC0tLS0tLVxucmVxdWlyZShcIi4vdXNlcmZyb3N0aW5nL2pzL2hhbmRsZWJhcnMtaGVscGVycy5qc1wiKTtcbnJlcXVpcmUoXCJtb21lbnRcIik7XG5yZXF1aXJlKFwidGFibGVzb3J0ZXJcIik7XG5yZXF1aXJlKFwidGFibGVzb3J0ZXIvZGlzdC9qcy93aWRnZXRzL3dpZGdldC1jb2x1bW5TZWxlY3Rvci5taW4uanNcIik7XG5yZXF1aXJlKFwidGFibGVzb3J0ZXIvZGlzdC9qcy93aWRnZXRzL3dpZGdldC1yZWZsb3cubWluLmpzXCIpO1xucmVxdWlyZShcInRhYmxlc29ydGVyL2Rpc3QvanMvd2lkZ2V0cy93aWRnZXQtcGFnZXIubWluLmpzXCIpO1xucmVxdWlyZShcIkB1c2VyZnJvc3RpbmcvdGhlbWUtYWRtaW5sdGUvYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvanMvcXVlcnktc3RyaW5nLmpzXCIpO1xucmVxdWlyZShcIkB1c2VyZnJvc3RpbmcvdGhlbWUtYWRtaW5sdGUvYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvanMvdGFibGVzb3J0ZXIvd2lkZ2V0LXNvcnQySGFzaC5qc1wiKTtcbnJlcXVpcmUoXCJAdXNlcmZyb3N0aW5nL3RoZW1lLWFkbWlubHRlL2FwcC9hc3NldHMvdXNlcmZyb3N0aW5nL2pzL3VmLXRhYmxlXCIpO1xuXG5yZXF1aXJlKFwiLi9mb250LXN0YXJjcmFmdC9jc3MvZm9udC1zdGFyY3JhZnQuY3NzXCIpO1xucmVxdWlyZShcInRhYmxlc29ydGVyL2Rpc3QvY3NzL3RoZW1lLmJvb3RzdHJhcC5taW4uY3NzXCIpO1xucmVxdWlyZShcInRhYmxlc29ydGVyL2Rpc3QvY3NzL2pxdWVyeS50YWJsZXNvcnRlci5wYWdlci5taW4uY3NzXCIpO1xucmVxdWlyZShcIkB1c2VyZnJvc3RpbmcvdGhlbWUtYWRtaW5sdGUvYXBwL2Fzc2V0cy91c2VyZnJvc3RpbmcvY3NzL3RhYmxlc29ydGVyLXJlZmxvdy5jc3NcIik7XG5yZXF1aXJlKFwiLi91c2VyZnJvc3RpbmcvY3NzL3RhYmxlc29ydGVyLWN1c3RvbS5jc3NcIik7XG4iLCIvKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGZvciBIYW5kbGViYXJzLmpzLlxuICpcbiAqIEBzZWUgaHR0cDovL2hhbmRsZWJhcnNqcy5jb20vI2hlbHBlcnNcbiAqL1xuXG4gLyoqXG4gICogSW1wcm92ZWQgY29tcGFyaXNvbiBvcGVyYXRvclxuICAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYzMTUzNjYvMjk3MDMyMVxuICAqL1xuSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignaWZ4JywgZnVuY3Rpb24gKHYxLCBvcGVyYXRvciwgdjIsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPT0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPT09IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgIT0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgIT09IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICh2MSA8IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPD0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gKHYxID4gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgcmV0dXJuICh2MSA+PSB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICByZXR1cm4gKHYxICYmIHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgfHwgdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAodjEgPT0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQZXJmb3JtIHNpbXBsZSBjYWxjdWxhdGlvbnMuXG4gKlxuICogdXNhZ2U6IHt7Y2FsYyB4ICcrJyAyfX1cbiAqL1xuSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignY2FsYycsIGZ1bmN0aW9uICh2MSwgb3BlcmF0b3IsIHYyLCBvcHRpb25zKSB7XG4gICAgbHZhbHVlID0gcGFyc2VGbG9hdCh2MSk7XG4gICAgcnZhbHVlID0gcGFyc2VGbG9hdCh2Mik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBcIitcIjogbHZhbHVlICsgcnZhbHVlLFxuICAgICAgICBcIi1cIjogbHZhbHVlIC0gcnZhbHVlLFxuICAgICAgICBcIipcIjogbHZhbHVlICogcnZhbHVlLFxuICAgICAgICBcIi9cIjogbHZhbHVlIC8gcnZhbHVlLFxuICAgICAgICBcIiVcIjogbHZhbHVlICUgcnZhbHVlXG4gICAgfVtvcGVyYXRvcl07XG59KTtcblxuLyoqXG4gKiBmb3JtYXQgYW4gSVNPIGRhdGUgdXNpbmcgTW9tZW50LmpzXG4gKlxuICogbW9tZW50IHN5bnRheCBleGFtcGxlOiBtb21lbnQoRGF0ZShcIjIwMTEtMDctMThUMTU6NTA6NTJcIikpLmZvcm1hdChcIk1NTU0gWVlZWVwiKVxuICogdXNhZ2U6IHt7ZGF0ZUZvcm1hdCBjcmVhdGlvbl9kYXRlIGZvcm1hdD1cIk1NTU0gWVlZWVwifX1cbiAqIEByZXF1aXJlcyBtb21lbnRqcyBodHRwOi8vbW9tZW50anMuY29tL1xuICovXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdkYXRlRm9ybWF0JywgZnVuY3Rpb24oY29udGV4dCwgYmxvY2spIHtcbiAgICBpZiAod2luZG93Lm1vbWVudCkge1xuICAgICAgICB2YXIgZiA9IGJsb2NrLmhhc2guZm9ybWF0IHx8IFwiTU1NIERvLCBZWVlZXCI7XG4gICAgICAgIHJldHVybiBtb21lbnQoY29udGV4dCkuZm9ybWF0KGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBtb21lbnQgcGx1Z2luIG5vdCBhdmFpbGFibGUuIHJldHVybiBkYXRhIGFzIGlzLlxuICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBtb21lbnQuanMgcGx1Z2luIGlzIG5vdCBsb2FkZWQuICBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGluY2x1ZGVkIG1vbWVudC5qcyBvbiB0aGlzIHBhZ2UuXCIpO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBGb3JtYXQgYSBwaG9uZSBudW1iZXIuXG4gKi9cbkhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoXCJwaG9uZVVTRm9ybWF0XCIsIGZ1bmN0aW9uKHBob25lTnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgcGhvbmVOdW1iZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci50b1N0cmluZygpO1xuICByZXR1cm4gXCIoXCIgKyBwaG9uZU51bWJlci5zdWJzdHIoMCwzKSArIFwiKSBcIiArIHBob25lTnVtYmVyLnN1YnN0cigzLDMpICsgXCItXCIgKyBwaG9uZU51bWJlci5zdWJzdHIoNiw0KTtcbn0pO1xuXG4vKipcbiAqIEZvcm1hdCBjdXJyZW5jeSAoVVNEKS5cbiAqL1xuSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihcImN1cnJlbmN5VXNkRm9ybWF0XCIsIGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBwYXJzZWRBbW91bnQgPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgaWYgKHBhcnNlZEFtb3VudCA8IDApIHtcbiAgICAgICAgcmV0dXJuIFwiLSRcIiArIE1hdGguYWJzKHBhcnNlZEFtb3VudCkudG9GaXhlZCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCIkXCIgKyBwYXJzZWRBbW91bnQudG9GaXhlZCgyKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgc2x1ZyB1c2luZyBzcGVha2luZ3VybC5qcy5cbiAqXG4gKiBAcmVxdWlyZXMgc3BlYWtpbmd1cmwgaHR0cHM6Ly9waWQuZ2l0aHViLmlvL3NwZWFraW5ndXJsL1xuICovXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdzbHVnJywgZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBnZXRTbHVnKHRleHQpO1xufSk7XG4iLCIvKipcbiAqIEBhZGQgalF1ZXJ5LlN0cmluZ1xuICovXG4kLlN0cmluZyA9ICQuZXh0ZW5kKCQuU3RyaW5nIHx8IHt9LCB7XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGRlcGFyYW1cbiAgICAgKlxuICAgICAqIFRha2VzIGEgc3RyaW5nIG9mIG5hbWUgdmFsdWUgcGFpcnMgYW5kIHJldHVybnMgYSBPYmplY3QgbGl0ZXJhbCB0aGF0IHJlcHJlc2VudHMgdGhvc2UgcGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcyBhIHN0cmluZyBsaWtlIDxjb2RlPlwiZm9vPWJhciZwZXJzb25bYWdlXT0zXCI8L2NvZGU+XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIEphdmFTY3JpcHQgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFyYW1zOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmb286IFwiYmFyXCIsXG4gICAgICogICAgICAgcGVyc29uOiB7XG4gICAgICogICAgICAgICBhZ2U6IFwiM1wiXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgZGVwYXJhbTogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgICAgdmFyIGRpZ2l0VGVzdCA9IC9eXFxkKyQvLFxuICAgICAgICAgICAga2V5QnJlYWtlciA9IC8oW15cXFtcXF1dKyl8KFxcW1xcXSkvZyxcbiAgICAgICAgICAgIHBsdXMgPSAvXFwrL2csXG4gICAgICAgICAgICBwYXJhbVRlc3QgPSAvKFtePyNdKikoIy4qKT8kLztcblxuICAgICAgICBpZighIHBhcmFtcyB8fCAhIHBhcmFtVGVzdC50ZXN0KHBhcmFtcykgKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBkYXRhID0ge30sXG4gICAgICAgICAgICBwYWlycyA9IHBhcmFtcy5zcGxpdCgnJicpLFxuICAgICAgICAgICAgY3VycmVudDtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBkYXRhO1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGZvbz0xKzE9MlxuICAgICAgICAgICAgaWYocGFpci5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgICAgIHBhaXIgPSBbcGFpclswXSwgcGFpci5zbGljZSgxKS5qb2luKFwiPVwiKV1cbiAgICAgICAgICAgIH1cblxuICAgIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclswXS5yZXBsYWNlKHBsdXMsIFwiIFwiKSksXG4gICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdLnJlcGxhY2UocGx1cywgXCIgXCIpKSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGtleS5tYXRjaChrZXlCcmVha2VyKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoIC0gMTsgaisrICkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbal07XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhcnRdICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3aGF0IHdlIGFyZSBwb2ludGluZyB0byBsb29rcyBsaWtlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSBkaWdpdFRlc3QudGVzdChwYXJ0c1tqKzFdKSB8fCBwYXJ0c1tqKzFdID09IFwiW11cIiA/IFtdIDoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYobGFzdFBhcnQgPT0gXCJbXVwiKXtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnB1c2godmFsdWUpXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBjdXJyZW50W2xhc3RQYXJ0XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pO1xuIiwiLyohIFdpZGdldDogc29ydDJIYXNoIChCRVRBKSAtIHVwZGF0ZWQgOC8xMi8yMDE3ICh2Mi4yOC4xNS51ZikgKi9cbi8qIFJlcXVpcmVzIHRhYmxlc29ydGVyIHYyLjgrIGFuZCBqUXVlcnkgMS43K1xuICogYnkgUm9iIEdhcnJpc29uXG4gKlxuICogVGVtcG9yYXJ5IHBhdGNoZWQgdmVyc2lvbiBvZiB3aWRnZXQgdG8gaGFuZGxlIGJyb3dzZXIgaGlzdG9yeSBpc3N1ZXMgKCM3MTIpLlxuICovXG47KCBmdW5jdGlvbiggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgdHMgPSAkLnRhYmxlc29ydGVyIHx8IHt9LFxuXHRzMmggPSB0cy5zb3J0Mkhhc2ggPSB7XG5cdFx0aW5pdCA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciBmaWx0ZXIsIHRlbXAsIHBhZ2UsIHNpemUsXG5cdFx0XHRcdHRhYmxlID0gYy50YWJsZSxcblx0XHRcdFx0cGFnZXIgPSBjLnBhZ2VyLFxuXHRcdFx0XHRoYXNTYXZlU29ydCA9IHRzLmhhc1dpZGdldCggdGFibGUsICdzYXZlU29ydCcgKSxcblx0XHRcdFx0c29ydCA9IHMyaC5kZWNvZGVIYXNoKCBjLCB3bywgJ3NvcnQnICk7XG5cdFx0XHRpZiAoICggc29ydCAmJiAhaGFzU2F2ZVNvcnQgKSB8fCAoIHNvcnQgJiYgaGFzU2F2ZVNvcnQgJiYgd28uc29ydDJIYXNoX292ZXJyaWRlU2F2ZVNvcnQgKSApIHtcblx0XHRcdFx0czJoLmNvbnZlcnRTdHJpbmcyU29ydCggYywgd28sIHNvcnQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMuaGFzV2lkZ2V0KCBjLnRhYmxlLCAncGFnZXInICkgKSB7XG5cdFx0XHRcdHRlbXAgPSBwYXJzZUludCggczJoLmRlY29kZUhhc2goIGMsIHdvLCAncGFnZScgKSwgMTAgKTtcblx0XHRcdFx0cGFnZSA9IHBhZ2VyLnBhZ2UgPSAoIHRlbXAgPCAwID8gMCA6ICggdGVtcCA+IHBhZ2VyLnRvdGFsUGFnZXMgPyBwYWdlci50b3RhbFBhZ2VzIC0gMSA6IHRlbXAgKSApO1xuXHRcdFx0XHRzaXplID0gcGFnZXIuc2l6ZSA9IHBhcnNlSW50KCBzMmguZGVjb2RlSGFzaCggYywgd28sICdzaXplJyApLCAxMCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cy5oYXNXaWRnZXQoIHRhYmxlLCAnZmlsdGVyJyApICkge1xuXHRcdFx0XHRmaWx0ZXIgPSBzMmguZGVjb2RlSGFzaCggYywgd28sICdmaWx0ZXInICk7XG5cdFx0XHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0XHRcdGZpbHRlciA9IGZpbHRlci5zcGxpdCggd28uc29ydDJIYXNoX3NlcGFyYXRvciApO1xuXHRcdFx0XHRcdGMuJHRhYmxlLm9uZSggJ3RhYmxlc29ydGVyLXJlYWR5JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGMuJHRhYmxlLm9uZSggJ2ZpbHRlckVuZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdCQodGhpcykudHJpZ2dlckhhbmRsZXIoICdwYWdlQW5kU2l6ZScsIFsgcGFnZSwgc2l6ZSBdICk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgdGhlIG5ld2VzdCBmaWx0ZXIgY29tcGFyaXNvbiBjb2RlXG5cdFx0XHRcdFx0XHRcdGlmICggdHMuZmlsdGVyLmVxdWFsRmlsdGVycyApIHtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gdHMuZmlsdGVyLmVxdWFsRmlsdGVycyggYywgYy5sYXN0U2VhcmNoLCBmaWx0ZXIgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBxdWljayBuJyBkaXJ0eSBjb21wYXJpc29uLi4uIGl0IHdpbGwgbWlzcyBmaWx0ZXIgY2hhbmdlcyBvZlxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBzYW1lIHZhbHVlIGluIGEgZGlmZmVyZW50IGNvbHVtbiwgc2VlICMxMzYzXG5cdFx0XHRcdFx0XHRcdFx0dGVtcCA9ICggYy5sYXN0U2VhcmNoIHx8IFtdICkuam9pbiggJycgKSAhPT0gKCBmaWx0ZXIgfHwgW10gKS5qb2luKCAnJyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGRvbid0IHNldCBmaWx0ZXJzIGlmIHRoZXkgaGF2ZW4ndCBjaGFuZ2VkXG5cdFx0XHRcdFx0XHRcdGlmICggIXRlbXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0JC50YWJsZXNvcnRlci5zZXRGaWx0ZXJzKCB0YWJsZSwgZmlsdGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIDEwMCApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaWx0ZXIgKSB7XG5cdFx0XHRcdGMuJHRhYmxlLm9uZSggJ3RhYmxlc29ydGVyLXJlYWR5JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdwYWdlQW5kU2l6ZScsIFsgcGFnZSwgc2l6ZSBdICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjLiR0YWJsZS5vbiggJ3NvcnRFbmQuc29ydDJoYXNoIGZpbHRlckVuZC5zb3J0Mmhhc2ggcGFnZXJDb21wbGV0ZS5zb3J0Mkhhc2gnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0luaXRpYWxpemVkICkge1xuXHRcdFx0XHRcdHMyaC5zZXRIYXNoKCB0aGlzLmNvbmZpZywgdGhpcy5jb25maWcud2lkZ2V0T3B0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Z2V0VGFibGVJZCA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdC8vIG9wdGlvbiA+IHRhYmxlIGlkID4gdGFibGUgaW5kZXggb24gcGFnZVxuXHRcdFx0cmV0dXJuIHdvLnNvcnQySGFzaF90YWJsZUlkIHx8XG5cdFx0XHRcdGMudGFibGUuaWQgfHxcblx0XHRcdFx0J3RhYmxlJyArICQoICd0YWJsZScgKS5pbmRleCggYy4kdGFibGUgKTtcblx0XHR9LFxuXHRcdHJlZ2V4RXNjYXBlIDogZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHRyZXR1cm4gdi5yZXBsYWNlKCAvKFtcXC5cXF5cXCRcXCpcXCtcXC1cXD9cXChcXClcXFtcXF1cXHtcXH1cXFxcXFx8XSkvZywgJ1xcXFwkMScpO1xuXHRcdH0sXG5cdFx0Ly8gY29udmVydCAnZmlyc3QlMjBuYW1lLGFzYyxsYXN0JTIwbmFtZSxkZXNjJyBpbnRvIFtbMCwwXSwgWzEsMV1dXG5cdFx0Y29udmVydFN0cmluZzJTb3J0IDogZnVuY3Rpb24oIGMsIHdvLCBzb3J0SGFzaCApIHtcblx0XHRcdHZhciByZWdleCwgY29sdW1uLCBkaXJlY3Rpb24sIHRlbXAsIGluZGV4LCAkY2VsbCxcblx0XHRcdFx0YXJyeSA9IHNvcnRIYXNoLnNwbGl0KCB3by5zb3J0Mkhhc2hfc2VwYXJhdG9yICksXG5cdFx0XHRcdGluZHggPSAwLFxuXHRcdFx0XHRsZW4gPSBhcnJ5Lmxlbmd0aCxcblx0XHRcdFx0c29ydCA9IFtdO1xuXHRcdFx0d2hpbGUgKCBpbmR4IDwgbGVuICkge1xuXHRcdFx0XHQvLyBjb2x1bW4gaW5kZXggb3IgdGV4dFxuXHRcdFx0XHRjb2x1bW4gPSBhcnJ5WyBpbmR4KysgXTtcblx0XHRcdFx0dGVtcCA9IHBhcnNlSW50KCBjb2x1bW4sIDEwICk7XG5cdFx0XHRcdC8vIGlnbm9yZSB3by5zb3J0Mkhhc2hfdXNlSGVhZGVyVGV4dCBzZXR0aW5nICZcblx0XHRcdFx0Ly8ganVzdCBzZWUgaWYgY29sdW1uIGNvbnRhaW5zIGEgbnVtYmVyXG5cdFx0XHRcdGlmICggaXNOYU4oIHRlbXAgKSB8fCB0ZW1wID4gYy5jb2x1bW5zICkge1xuXHRcdFx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggJygnICsgczJoLnJlZ2V4RXNjYXBlKCBjb2x1bW4gKSArICcpJywgJ2knICk7XG5cdFx0XHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGMuY29sdW1uczsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdCRjZWxsID0gYy4kaGVhZGVySW5kZXhlZFsgaW5kZXggXTtcblx0XHRcdFx0XHRcdGlmICggcmVnZXgudGVzdCggJGNlbGwuYXR0ciggd28uc29ydDJIYXNoX2hlYWRlclRleHRBdHRyICkgKSApIHtcblx0XHRcdFx0XHRcdFx0Y29sdW1uID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gYy5jb2x1bW5zO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkaXJlY3Rpb24gPSBhcnJ5WyBpbmR4KysgXTtcblx0XHRcdFx0Ly8gaWdub3JlIHVucGFpcmVkIHZhbHVlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjb2x1bW4gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkaXJlY3Rpb24gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdGV4dCB0byAwLCAxXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggZGlyZWN0aW9uICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBkZWZhdWx0IHRvIGFzY2VuZGluZyBzb3J0XG5cdFx0XHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uaW5kZXhPZiggd28uc29ydDJIYXNoX2RpcmVjdGlvblRleHRbIDEgXSApID4gLTEgPyAxIDogMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c29ydC5wdXNoKCBbIGNvbHVtbiwgZGlyZWN0aW9uIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBzb3J0Lmxlbmd0aCApIHtcblx0XHRcdFx0Yy5zb3J0TGlzdCA9IHNvcnQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGNvbnZlcnQgW1swLDBdLFsxLDFdXSB0byAnZmlyc3QlMjBuYW1lLGFzYyxsYXN0JTIwbmFtZSxkZXNjJ1xuXHRcdGNvbnZlcnRTb3J0MlN0cmluZyA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciBpbmRleCwgdHh0LCBjb2x1bW4sIGRpcmVjdGlvbixcblx0XHRcdFx0c29ydCA9IFtdLFxuXHRcdFx0XHRhcnJ5ID0gYy5zb3J0TGlzdCB8fCBbXSxcblx0XHRcdFx0bGVuID0gYXJyeS5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBhcnJ5WyBpbmRleCBdWyAwIF07XG5cdFx0XHRcdHR4dCA9ICQudHJpbSggYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF0uYXR0ciggd28uc29ydDJIYXNoX2hlYWRlclRleHRBdHRyICkgKTtcblx0XHRcdFx0c29ydC5wdXNoKCB0eHQgIT09ICcnID8gZW5jb2RlVVJJQ29tcG9uZW50KCB0eHQgKSA6IGNvbHVtbiApO1xuXHRcdFx0XHRkaXJlY3Rpb24gPSB3by5zb3J0Mkhhc2hfZGlyZWN0aW9uVGV4dFsgYXJyeVsgaW5kZXggXVsgMSBdIF07XG5cdFx0XHRcdHNvcnQucHVzaCggZGlyZWN0aW9uICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBqb2luIHdpdGggc2VwYXJhdG9yXG5cdFx0XHRyZXR1cm4gc29ydC5qb2luKCB3by5zb3J0Mkhhc2hfc2VwYXJhdG9yICk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnRGaWx0ZXIyU3RyaW5nIDogZnVuY3Rpb24oIGMsIHdvICkge1xuXHRcdFx0dmFyIGluZGV4LCB0eHQsIGNvbHVtbiwgZGlyZWN0aW9uLFxuXHRcdFx0XHRzb3J0ID0gW10sXG5cdFx0XHRcdGFycnkgPSBjLnNvcnRMaXN0IHx8IFtdLFxuXHRcdFx0XHRsZW4gPSBhcnJ5Lmxlbmd0aDtcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdGNvbHVtbiA9IGFycnlbIGluZGV4IF1bIDAgXTtcblx0XHRcdFx0dHh0ID0gJC50cmltKCBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXS5hdHRyKCB3by5zb3J0Mkhhc2hfaGVhZGVyVGV4dEF0dHIgKSApO1xuXHRcdFx0XHRjb2x1bW4gPSB0eXBlb2YgdHh0ICE9PSAndW5kZWZpbmVkJyA/IGVuY29kZVVSSUNvbXBvbmVudCggdHh0ICkgOiBjb2x1bW47XG5cdFx0XHRcdHNvcnQucHVzaCggY29sdW1uICk7XG5cdFx0XHRcdGRpcmVjdGlvbiA9IHdvLnNvcnQySGFzaF9kaXJlY3Rpb25UZXh0WyBhcnJ5WyBpbmRleCBdWyAxIF0gXTtcblx0XHRcdFx0c29ydC5wdXNoKCBkaXJlY3Rpb24gKTtcblx0XHRcdH1cblx0XHRcdC8vIGpvaW4gd2l0aCBzZXBhcmF0b3Jcblx0XHRcdHJldHVybiBzb3J0LmpvaW4oIHdvLnNvcnQySGFzaF9zZXBhcmF0b3IgKTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IFVSTCBQYXJhbWV0ZXJzIChnZXRQYXJhbSlcblx0XHQvLyBtb2RpZmllZCBmcm9tIGh0dHA6Ly93d3cubmV0bG9iby5jb20vdXJsX3F1ZXJ5X3N0cmluZ19qYXZhc2NyaXB0Lmh0bWxcblx0XHRnZXRQYXJhbSA6IGZ1bmN0aW9uICggbmFtZSwgaGFzaCwgcmV0dXJuUmVnZXggKSB7XG5cdFx0XHRpZiAoICFoYXNoICkgeyBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7IH1cblx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAoICdbXFxcXD8mXScgKyBzMmgucmVnZXhFc2NhcGUoIG5hbWUgKSArICc9KFteJiNdKiknICksXG5cdFx0XHRcdG1hdGNoID0gcmVnZXguZXhlYyggaGFzaCApO1xuXHRcdFx0aWYgKCByZXR1cm5SZWdleCApIHsgcmV0dXJuIHJlZ2V4OyB9XG5cdFx0XHRyZXR1cm4gbWF0Y2ggPT09IG51bGwgPyAnJyA6IGRlY29kZVVSSUNvbXBvbmVudCggbWF0Y2hbIDEgXSApO1xuXHRcdH0sXG5cblx0XHQvLyByZW1vdmUgcGFyYW1ldGVyIGZyb20gaGFzaFxuXHRcdHJlbW92ZVBhcmFtIDogZnVuY3Rpb24oIG5hbWUsIGhhc2ggKSB7XG5cdFx0XHRpZiAoICFoYXNoICkgeyBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7IH1cblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0cmVnZXggPSBzMmguZ2V0UGFyYW0oIG5hbWUsIGhhc2gsIHRydWUgKSxcblx0XHRcdFx0cmVzdWx0ID0gW10sXG5cdFx0XHRcdHBhcnRzID0gaGFzaC5zcGxpdCggJyYnICksXG5cdFx0XHRcdGxlbiA9IHBhcnRzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdC8vIHJlZ2V4IGV4cGVjdHMgYSBsZWFkaW5nICcmJy4uLlxuXHRcdFx0XHRpZiAoICFyZWdleC50ZXN0KCAnJicgKyBwYXJ0c1sgaW5kZXggXSApICkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBwYXJ0c1sgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdC5qb2luKCAnJicgKSA6ICcnO1xuXHRcdH0sXG5cblx0XHRlbmNvZGVIYXNoIDogZnVuY3Rpb24oIGMsIHdvLCBjb21wb25lbnQsIHZhbHVlLCByYXdWYWx1ZSApIHtcblx0XHRcdHZhciByZXN1bHQgPSBmYWxzZSxcblx0XHRcdFx0dGFibGVJZCA9IHMyaC5nZXRUYWJsZUlkKCBjLCB3byApO1xuXHRcdFx0aWYgKCB0eXBlb2Ygd28uc29ydDJIYXNoX2VuY29kZUhhc2ggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHdvLnNvcnQySGFzaF9lbmNvZGVIYXNoKCBjLCB0YWJsZUlkLCBjb21wb25lbnQsIHZhbHVlLCByYXdWYWx1ZSB8fCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXN1bHQgPSAnJicgKyBjb21wb25lbnQgKyAnWycgKyB0YWJsZUlkICsgJ109JyArIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0ZGVjb2RlSGFzaCA6IGZ1bmN0aW9uKCBjLCB3bywgY29tcG9uZW50ICkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxuXHRcdFx0XHR0YWJsZUlkID0gczJoLmdldFRhYmxlSWQoIGMsIHdvICk7XG5cdFx0XHRpZiAoIHR5cGVvZiB3by5zb3J0Mkhhc2hfZGVjb2RlSGFzaCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gcmV0dXJuIGEgc3RyaW5nXG5cdFx0XHRcdHJlc3VsdCA9IHdvLnNvcnQySGFzaF9kZWNvZGVIYXNoKCBjLCB0YWJsZUlkLCBjb21wb25lbnQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggcmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmVzdWx0ID0gczJoLmdldFBhcmFtKCBjb21wb25lbnQgKyAnWycgKyB0YWJsZUlkICsgJ10nICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0IHx8ICcnO1xuXHRcdH0sXG5cblx0XHRjbGVhbkhhc2ggOiBmdW5jdGlvbiggYywgd28sIGNvbXBvbmVudCwgaGFzaCApIHtcblx0XHRcdHZhciByZXN1bHQgPSBmYWxzZSxcblx0XHRcdFx0dGFibGVJZCA9IHMyaC5nZXRUYWJsZUlkKCBjLCB3byApO1xuXHRcdFx0aWYgKCB0eXBlb2Ygd28uc29ydDJIYXNoX2NsZWFuSGFzaCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gY2FuIHJldHVybiBhbiBhcnJheSBvciBzdHJpbmdcblx0XHRcdFx0cmVzdWx0ID0gd28uc29ydDJIYXNoX2NsZWFuSGFzaCggYywgdGFibGVJZCwgY29tcG9uZW50LCBoYXNoICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdC8vIHBhcmFtZXRlciBleGFtcGxlOiAnc29ydFt0YWJsZTBdPTAsMCdcblx0XHRcdFx0cmVzdWx0ID0gczJoLnJlbW92ZVBhcmFtKCBjb21wb25lbnQgKyAnWycgKyB0YWJsZUlkICsgJ10nLCBoYXNoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0IHx8ICcnO1xuXHRcdH0sXG5cblx0XHRzZXRIYXNoIDogZnVuY3Rpb24oIGMsIHdvICkge1xuXHRcdFx0dmFyIHN0ciA9ICcnLFxuXHRcdFx0XHRoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2gsXG5cdFx0XHRcdGhhc1BhZ2VyID0gdHMuaGFzV2lkZ2V0KCBjLnRhYmxlLCAncGFnZXInICksXG5cdFx0XHRcdGhhc0ZpbHRlciA9IHRzLmhhc1dpZGdldCggYy50YWJsZSwgJ2ZpbHRlcicgKSxcblx0XHRcdFx0c29ydExpc3QgPSBzMmguY29udmVydFNvcnQyU3RyaW5nKCBjLCB3byApLFxuXHRcdFx0XHRmaWx0ZXJzID0gKCBoYXNGaWx0ZXIgJiYgYy5sYXN0U2VhcmNoLmpvaW4oJycpICE9PSAnJyA/IGMubGFzdFNlYXJjaCA6IFtdICksXG5cdFx0XHRcdGZpbHRlcnNTdHIgPSBlbmNvZGVVUklDb21wb25lbnQoIGZpbHRlcnMuam9pbiggYy53aWRnZXRPcHRpb25zLnNvcnQySGFzaF9zZXBhcmF0b3IgKSApLFxuXHRcdFx0XHRjb21wb25lbnRzID0ge1xuXHRcdFx0XHRcdCdzb3J0JyAgIDogc29ydExpc3QgPyBzMmguZW5jb2RlSGFzaCggYywgd28sICdzb3J0Jywgc29ydExpc3QsIGMuc29ydExpc3QgKSA6ICcnLFxuXHRcdFx0XHRcdCdwYWdlJyAgIDogaGFzUGFnZXIgPyBzMmguZW5jb2RlSGFzaCggYywgd28sICdwYWdlJywgYy5wYWdlci5wYWdlICsgMSApIDogJycsXG5cdFx0XHRcdFx0J3NpemUnICAgOiBoYXNQYWdlciA/IHMyaC5lbmNvZGVIYXNoKCBjLCB3bywgJ3NpemUnLCBjLnBhZ2VyLnNpemUgKSA6ICcnLFxuXHRcdFx0XHRcdCdmaWx0ZXInIDogZmlsdGVyc1N0ciA/IHMyaC5lbmNvZGVIYXNoKCBjLCB3bywgJ2ZpbHRlcicsIGZpbHRlcnNTdHIsIGZpbHRlcnMgKSA6ICcnXG5cdFx0XHRcdH07XG5cdFx0XHQvLyByZW1vdmUgb2xkIGhhc2hcblx0XHRcdCQuZWFjaCggY29tcG9uZW50cywgZnVuY3Rpb24oIGNvbXBvbmVudCwgdmFsdWUgKSB7XG5cdFx0XHRcdGhhc2ggPSBzMmguY2xlYW5IYXNoKCBjLCB3bywgY29tcG9uZW50LCBoYXNoICk7XG5cdFx0XHRcdHN0ciArPSB2YWx1ZTtcblx0XHRcdH0pO1xuXG4gICAgICAgICAgICAvLyBDb21iaW5lIG5ldyBoYXNoIHdpdGggYW55IGV4aXN0aW5nIGhhc2hlc1xuICAgICAgICAgICAgdmFyIGhhc2hDaGFyID0gYy53aWRnZXRPcHRpb25zLnNvcnQySGFzaF9oYXNoO1xuICAgICAgICAgICAgdmFyIG5ld0hhc2ggPSAoICggd2luZG93LmxvY2F0aW9uLmhhc2ggfHwgJycgKS5yZXBsYWNlKCBoYXNoQ2hhciwgJycgKS5sZW5ndGggPyBoYXNoIDogd28uc29ydDJIYXNoX2hhc2ggKSArIHN0cjtcbiAgICAgICAgICAgIHZhciBiYXNlVXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoaGFzaENoYXIpWzBdO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBsZWFkaW5nIGhhc2ggY2hhcmFjdGVyXG4gICAgICAgICAgICB2YXIgZmlyc3RDaGFyID0gbmV3SGFzaFswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgIT0gaGFzaENoYXIpIHtcbiAgICAgICAgICAgICAgICBuZXdIYXNoID0gaGFzaENoYXIgKyBuZXdIYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgVVJMIGluIGJyb3dzZXJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGJhc2VVcmwgKyBuZXdIYXNoKTtcblx0XHR9XG5cdH07XG5cblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3NvcnQySGFzaCcsXG5cdFx0cHJpb3JpdHk6IDYwLCAvLyBhZnRlciBzYXZlU29ydCAmIHBhZ2VyXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0c29ydDJIYXNoX2hhc2ggICAgICAgICAgICAgIDogJyMnLCAgICAgIC8vIGhhc2ggcHJlZml4XG5cdFx0XHRzb3J0Mkhhc2hfc2VwYXJhdG9yICAgICAgICAgOiAnLScsICAgICAgLy8gZG9uJ3QgJyMnIG9yICc9JyBoZXJlXG5cdFx0XHRzb3J0Mkhhc2hfaGVhZGVyVGV4dEF0dHIgICAgOiAnZGF0YS1oZWFkZXInLCAvLyBkYXRhIGF0dHJpYnV0ZSBjb250YWluaW5nIGFsdGVybmF0ZSBoZWFkZXIgdGV4dFxuXHRcdFx0c29ydDJIYXNoX2RpcmVjdGlvblRleHQgICAgIDogWyAwLCAxIF0sIC8vIFsgJ2FzYycsICdkZXNjJyBdLFxuXHRcdFx0c29ydDJIYXNoX292ZXJyaWRlU2F2ZVNvcnQgIDogZmFsc2UsICAgIC8vIGlmIHRydWUsIG92ZXJyaWRlIHNhdmVTb3J0IHdpZGdldCBpZiBzYXZlZCBzb3J0IGF2YWlsYWJsZVxuXG5cdFx0XHQvLyB0aGlzIG9wdGlvbiA+IHRhYmxlIElEID4gdGFibGUgaW5kZXggb24gcGFnZVxuXHRcdFx0c29ydDJIYXNoX3RhYmxlSWQgICAgICAgICAgIDogbnVsbCxcblx0XHRcdC8vIGN1c3RvbSBoYXNoIHByb2Nlc3NpbmcgZnVuY3Rpb25zXG5cdFx0XHRzb3J0Mkhhc2hfZW5jb2RlSGFzaCAgICAgICAgOiBudWxsLFxuXHRcdFx0c29ydDJIYXNoX2RlY29kZUhhc2ggICAgICAgIDogbnVsbCxcblx0XHRcdHNvcnQySGFzaF9jbGVhbkhhc2ggICAgICAgICA6IG51bGxcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhYmxlLCB0aGlzV2lkZ2V0LCBjLCB3bykge1xuXHRcdFx0czJoLmluaXQoIGMsIHdvICk7XG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKHRhYmxlLCBjKSB7XG5cdFx0XHRjLiR0YWJsZS5vZmYoICcuc29ydDJoYXNoJyApO1xuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG4iLCIvKipcbiAqIHVmLXRhYmxlIHBsdWdpbi4gIFNldHMgdXAgYSBUYWJsZXNvcnRlciB0YWJsZSB3aXRoIHNvcnRpbmcsIHBhZ2luYXRpb24sIGFuZCBzZWFyY2gsIGFuZCBmZXRjaGVzIGRhdGEgZnJvbSBhIEpTT04gQVBJLlxuICpcbiAqIFRoaXMgcGx1Z2luIGRlcGVuZHMgb24gcXVlcnktc3RyaW5nLmpzLCB3aGljaCBpcyB1c2VkIHRvIGNvbnZlcnQgYSBxdWVyeSBzdHJpbmcgaW50byBhIEpTT04gb2JqZWN0LlxuICpcbiAqIGpRdWVyeSBwbHVnaW4gdGVtcGxhdGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0Fpci1DcmFmdC8xMzAwODkwXG4gKlxuICogPT09IFVTQUdFID09PVxuICpcbiAqIENyZWF0ZSBhIGNvbnRhaW5lciBlbGVtZW50LCBhbmQgd2l0aGluIGl0IHBsYWNlIHlvdXIgdGFibGUsIHBhZ2luZyBjb250cm9scywgYW5kIEhhbmRsZWJhcnMgdGVtcGxhdGVzIGZvciByZW5kZXJpbmcgdGhlIGNlbGxzLlxuICpcbiAqIC0gWW91ciB0YWJsZSBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBpZCwgYW5kIHlvdXIgcGFnaW5nIGNvbnRyb2xzIHNob3VsZCBiZSB3cmFwcGVkIGluIGFuIGVsZW1lbnQgd2l0aCB0aGUgYC5qcy11Zi10YWJsZS1wYWdlcmAgY2xhc3MuXG4gKiAtIENyZWF0ZSBhIGJ1dHRvbiB3aXRoIHRoZSBgLmpzLXVmLXRhYmxlLWRvd25sb2FkYCBjbGFzcywgYW5kIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBib3VuZCB0byB0cmlnZ2VyIGFuIEFKQVggcmVxdWVzdCBmb3IgZG93bmxvYWRpbmcgdGhlIHRhYmxlIChDU1YsIGV0YykuXG4gKlxuICAgIDxkaXYgaWQ9XCJ3aWRnZXQtdXNlcnNcIj5cbiAgICAgICA8dGFibGUgaWQ9XCJ0YWJsZS11c2Vyc1wiIGNsYXNzPVwidGFibGVzb3J0ZXIgdGFibGUgdGFibGUtYm9yZGVyZWQgdGFibGUtaG92ZXIgdGFibGUtc3RyaXBlZFwiIGRhdGEtc29ydGxpc3Q9XCJbWzAsIDBdXVwiPlxuICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwic29ydGVyLW1ldGF0ZXh0XCIgZGF0YS1jb2x1bW4tbmFtZT1cIm5hbWVcIiBkYXRhLWNvbHVtbi10ZW1wbGF0ZT1cIiN1c2VyLXRhYmxlLWNvbHVtbi1pbmZvXCI+VXNlciA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLXNvcnRcIj48L2k+PC90aD5cbiAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJzb3J0ZXItbWV0YW51bVwiIGRhdGEtY29sdW1uLW5hbWU9XCJsYXN0X2FjdGl2aXR5XCIgZGF0YS1jb2x1bW4tdGVtcGxhdGU9XCIjdXNlci10YWJsZS1jb2x1bW4tbGFzdC1hY3Rpdml0eVwiPkxhc3QgQWN0aXZpdHkgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1zb3J0XCI+PC9pPjwvdGg+XG4gICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgPC90YWJsZT5cblxuICAgICAgIDxzY3JpcHQgaWQ9XCJ1c2VyLXRhYmxlLWNvbHVtbi1pbmZvXCIgdHlwZT1cInRleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlXCI+XG4gICAgICAgICAgIDx0ZCBkYXRhLXRleHQ9XCJ7e3Jvdy5sYXN0X25hbWV9fVwiPlxuICAgICAgICAgICAgICAgPHN0cm9uZz5cbiAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwie3tzaXRlLnVyaS5wdWJsaWN9fS91c2Vycy91L3t7cm93LnVzZXJfbmFtZX19XCI+e3tyb3cuZmlyc3RfbmFtZX19IHt7cm93Lmxhc3RfbmFtZX19ICh7e3Jvdy51c2VyX25hbWV9fSk8L2E+XG4gICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1lbnZlbG9wZVwiPjwvaT4gPGEgaHJlZj1cIm1haWx0bzp7e3Jvdy5lbWFpbH19XCI+e3tyb3cuZW1haWx9fTwvYT5cbiAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8L3RkPlxuICAgICAgIDwvc2NyaXB0PlxuXG4gICAgICAgPHNjcmlwdCBpZD1cInVzZXItdGFibGUtY29sdW1uLWxhc3QtYWN0aXZpdHlcIiB0eXBlPVwidGV4dC94LWhhbmRsZWJhcnMtdGVtcGxhdGVcIj5cbiAgICAgICAgICAge3sjaWYgcm93Lmxhc3RfYWN0aXZpdHlfYXQgfX1cbiAgICAgICAgICAgPHRkIGRhdGEtbnVtPVwie3tkYXRlRm9ybWF0IHJvdy5sYXN0X2FjdGl2aXR5X2F0IGZvcm1hdD0neCd9fVwiPlxuICAgICAgICAgICAgICAge3tkYXRlRm9ybWF0IHJvdy5sYXN0X2FjdGl2aXR5X2F0IGZvcm1hdD1cImRkZGRcIn19PGJyPnt7ZGF0ZUZvcm1hdCByb3cubGFzdF9hY3Rpdml0eV9hdCBmb3JtYXQ9XCJNTU0gRG8sIFlZWVkgaDptbSBhXCJ9fVxuICAgICAgICAgICAgICAgPGJyPlxuICAgICAgICAgICAgICAgPGk+e3tyb3cubGFzdF9hY3Rpdml0eS5kZXNjcmlwdGlvbn19PC9pPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICB7eyBlbHNlIH19XG4gICAgICAgICAgIDx0ZCBkYXRhLW51bT1cIjBcIj5cbiAgICAgICAgICAgICAgICAgICA8aT5Vbmtub3duPC9pPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICB7ey9pZiB9fVxuICAgICAgIDwvc2NyaXB0PlxuXG4gICAgICAgPGRpdiBjbGFzcz1cInBhZ2VyIHBhZ2VyLWxnIHRhYmxlc29ydGVyLXBhZ2VyIGpzLXVmLXRhYmxlLXBhZ2VyXCI+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGFnZXItY29udHJvbCBmaXJzdFwiIHRpdGxlPVwiRmlyc3QgcGFnZVwiPjxpIGNsYXNzPVwiZmEtc29saWQgZmEtYW5nbGUtZG91YmxlLWxlZnRcIj48L2k+PC9zcGFuPlxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBhZ2VyLWNvbnRyb2wgcHJldlwiIHRpdGxlPVwiUHJldmlvdXMgcGFnZVwiPjxpIGNsYXNzPVwiZmEtc29saWQgZmEtYW5nbGUtbGVmdFwiPjwvaT48L3NwYW4+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGFnZWRpc3BsYXlcIj48L3NwYW4+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGFnZXItY29udHJvbCBuZXh0XCIgdGl0bGU9XCJOZXh0IHBhZ2VcIj48aSBjbGFzcz1cImZhLXNvbGlkIGZhLWFuZ2xlLXJpZ2h0XCI+PC9pPjwvc3Bhbj5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYWdlci1jb250cm9sIGxhc3RcIiB0aXRsZT0gXCJMYXN0IHBhZ2VcIj48aSBjbGFzcz1cImZhLXNvbGlkIGZhLWFuZ2xlLWRvdWJsZS1yaWdodFwiPjwvaT48L3NwYW4+XG4gICAgICAgICAgIDxicj48YnI+XG4gICAgICAgICAgIEp1bXAgdG8gUGFnZTogPHNlbGVjdCBjbGFzcz1cImdvdG9QYWdlXCI+PC9zZWxlY3Q+ICZidWxsOyBTaG93OlxuICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwicGFnZXNpemVcIj5cbiAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1XCI+NTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj5cbiAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgPC9kaXY+XG5cbiAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBqcy11Zi10YWJsZS1kb3dubG9hZFwiPkRvd25sb2FkIENTVjwvYnV0dG9uPlxuICAgPC9kaXY+XG4gKlxuICogSW5pdGlhbGl6ZSB1ZlRhYmxlIG9uIHlvdXIgY29udGFpbmVyIG9iamVjdDpcbiAqXG4gKiAkKFwiI3dpZGdldC11c2Vyc1wiKS51ZlRhYmxlKG9wdGlvbnMpO1xuICpcbiAqIGBvcHRpb25zYCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFVcmwgVGhlIGFic29sdXRlIFVSTCBmcm9tIHdoaWNoIHRvIGZldGNoIHRhYmxlIGRhdGEuXG4gKiBAcGFyYW0ge21peGVkfSBhZGRQYXJhbXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW55IGFkZGl0aW9uYWwga2V5LXZhbHVlIHBhaXJzIHRoYXQgeW91IHdhbnQgYXBwZW5kZWQgdG8gdGhlIEFKQVggcmVxdWVzdHMuXG4gKiBAcGFyYW0ge21peGVkfSB0YWJsZXNvcnRlciBBbiBvYmplY3QgY29udGFpbmluZyB0YWJsZXNvcnRlcidzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAoaHR0cHM6Ly9tb3R0aWUuZ2l0aHViLmlvL3RhYmxlc29ydGVyL2RvY3MvI0NvbmZpZ3VyYXRpb24pXG4gKiBAcGFyYW0ge21peGVkfSBwYWdlciBBbiBvYmplY3QgY29udGFpbmluZyB0YWJsZXNvcnRlcidzIHBhZ2luZyBvcHRpb25zIChodHRwczovL21vdHRpZS5naXRodWIuaW8vdGFibGVzb3J0ZXIvZG9jcy8jcGFnZXIpXG4gKlxuICogPT0gRVZFTlRTID09XG4gKlxuICogdWZUYWJsZSB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiBgcGFnZXJDb21wbGV0ZS51ZlRhYmxlYDogdHJpZ2dlcmVkIHdoZW4gdGhlIHRhYmxlc29ydGVyIHBhZ2VyIHBsdWdpbiBoYXMgY29tcGxldGVkIHJlbmRlcmluZyBvZiB0aGUgdGFibGUuXG4gKlxuICogPT0gTUVUSE9EUyA9PVxuICpcbiAqIGBnZXRUYWJsZVN0YXRlVmFycyggdGFibGUgKWA6IGZldGNoZXMgdGhlIGN1cnJlbnQgcGFnZSBzaXplLCBwYWdlIG51bWJlciwgc29ydCBvcmRlciwgc29ydCBmaWVsZCwgYW5kIGNvbHVtbiBmaWx0ZXJzLlxuICogYHJlZnJlc2hgOiByZWxvYWQgdGhlIHRhYmxlIGRhdGFcbiAqXG4gKiBVc2VyRnJvc3RpbmcgaHR0cHM6Ly93d3cudXNlcmZyb3N0aW5nLmNvbVxuICogQGF1dGhvciBBbGV4YW5kZXIgV2Vpc3NtYW4gPGh0dHBzOi8vYWxleGFuZGVyd2Vpc3NtYW4uY29tPlxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIERlZmluZSBwbHVnaW4gbmFtZSBhbmQgZGVmYXVsdHMuXG4gICAgdmFyIHBsdWdpbk5hbWUgPSAndWZUYWJsZScsXG4gICAgICAgIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgREVCVUcgICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHNpdGUgICAgICAgICAgICAgICAgIDogc2l0ZSwgLy8gZ2xvYmFsIHNpdGUgdmFyaWFibGVzXG4gICAgICAgICAgICBkYXRhVXJsICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgbXNnVGFyZ2V0ICAgICAgICAgICAgOiAkKCcjYWxlcnRzLXBhZ2UnKSxcbiAgICAgICAgICAgIGFkZFBhcmFtcyAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBmaWx0ZXJBbGxGaWVsZCAgICAgICA6ICdfYWxsJyxcbiAgICAgICAgICAgIHVzZUxvYWRpbmdUcmFuc2l0aW9uIDogdHJ1ZSxcbiAgICAgICAgICAgIHJvd1RlbXBsYXRlICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGNvbHVtblRlbXBsYXRlcyAgICAgIDoge30sXG4gICAgICAgICAgICB0YWJsZXNvcnRlciAgICAgOiB7XG4gICAgICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRoZW1lICAgICA6ICdib290c3RyYXAnLFxuICAgICAgICAgICAgICAgIHdpZHRoRml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gU2V0IHVwIHBhZ2luYXRpb24gb2YgZGF0YSB2aWEgYW4gQUpBWCBzb3VyY2VcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC9Nb3R0aWUvdXdaYzIvXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBzZWUgaHR0cHM6Ly9tb3R0aWUuZ2l0aHViLmlvL3RhYmxlc29ydGVyL2RvY3MvZXhhbXBsZS1wYWdlci1hamF4Lmh0bWxcbiAgICAgICAgICAgICAgICB3aWRnZXRzOiBbJ3NhdmVTb3J0JywgJ3NvcnQySGFzaCcsICdmaWx0ZXInLCAncGFnZXInLCAnY29sdW1uU2VsZWN0b3InLCAncmVmbG93MiddLFxuICAgICAgICAgICAgICAgIHdpZGdldE9wdGlvbnMgOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdG9yX2xheW91dCA6ICc8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiA8c3Bhbj57bmFtZX08L3NwYW4+PC9sYWJlbD4nLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfY3NzRmlsdGVyOiAnZm9ybS1jb250cm9sJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyX3NhdmVGaWx0ZXJzIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyX3NlcnZlcnNpZGVGaWx0ZXJpbmcgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfc2VsZWN0U291cmNlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJy5maWx0ZXItc2VsZWN0JyA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGRpc2FibGVkIGNsYXNzIG5hbWUgdG8gdGhlIHBhZ2VyIGFycm93cyB3aGVuIHRoZSByb3dzIGF0IGVpdGhlciBleHRyZW1lIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgcGFnZXJfdXBkYXRlQXJyb3dzOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHBhZ2Ugb2YgdGhlIHBhZ2VyICh6ZXJvIGJhc2VkIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBwYWdlcl9zdGFydFBhZ2U6IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIHZpc2libGUgcm93c1xuICAgICAgICAgICAgICAgICAgICBwYWdlcl9zaXplOiAxMCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHBhZ2VyIHBhZ2UgJiBzaXplIGlmIHRoZSBzdG9yYWdlIHNjcmlwdCBpcyBsb2FkZWQgKHJlcXVpcmVzICQudGFibGVzb3J0ZXIuc3RvcmFnZSBpbiBqcXVlcnkudGFibGVzb3J0ZXIud2lkZ2V0cy5qcylcbiAgICAgICAgICAgICAgICAgICAgcGFnZXJfc2F2ZVBhZ2VzOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRydWUsIHRoZSB0YWJsZSB3aWxsIHJlbWFpbiB0aGUgc2FtZSBoZWlnaHQgbm8gbWF0dGVyIGhvdyBtYW55IHJlY29yZHMgYXJlIGRpc3BsYXllZC4gVGhlIHNwYWNlIGlzIG1hZGUgdXAgYnkgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFibGUgcm93IHNldCB0byBhIGhlaWdodCB0byBjb21wZW5zYXRlOyBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VyX2ZpeGVkSGVpZ2h0OiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcm93cyBmcm9tIHRoZSB0YWJsZSB0byBzcGVlZCB1cCB0aGUgc29ydCBvZiBsYXJnZSB0YWJsZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGhpcyB0byBmYWxzZSwgb25seSBoaWRlcyB0aGUgbm9uLXZpc2libGUgcm93czsgbmVlZGVkIGlmIHlvdSBwbGFuIHRvIGFkZC9yZW1vdmUgcm93cyB3aXRoIHRoZSBwYWdlciBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICBwYWdlcl9yZW1vdmVSb3dzOiBmYWxzZSwgLy8gcmVtb3Zpbmcgcm93cyBpbiBsYXJnZXIgdGFibGVzIHNwZWVkcyB1cCB0aGUgc29ydFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCB0aGUgcGFnZXIgbWFya3VwIC0gc2VlIHRoZSBIVE1MIGJsb2NrIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VyX2Nzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSb3cgICAgOiAndWYtdGFibGUtZXJyb3Itcm93JywgLy8gZXJyb3IgaW5mb3JtYXRpb24gcm93XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCAgICA6ICdkaXNhYmxlZCcgLy8gTm90ZSB0aGVyZSBpcyBubyBwZXJpb2QgXCIuXCIgaW4gZnJvbnQgb2YgdGhpcyBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgJ2RhdGEnIGtleVxuICAgICAgICAgICAgICAgICAgICBwYWdlcl9hamF4T2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBoYXNoIHByZWZpeFxuICAgICAgICAgICAgICAgICAgICBzb3J0Mkhhc2hfaGFzaCAgICAgICAgICAgICAgOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0ICcjJyBvciAnPScgaGVyZVxuICAgICAgICAgICAgICAgICAgICBzb3J0Mkhhc2hfc2VwYXJhdG9yICAgICAgICAgOiAnfCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb3B0aW9uID4gdGFibGUgSUQgPiB0YWJsZSBpbmRleCBvbiBwYWdlXG4gICAgICAgICAgICAgICAgICAgIHNvcnQySGFzaF90YWJsZUlkICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRydWUsIHNob3cgaGVhZGVyIGNlbGwgdGV4dCBpbnN0ZWFkIG9mIGEgemVyby1iYXNlZCBjb2x1bW4gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgc29ydDJIYXNoX2hlYWRlclRleHRBdHRyICAgIDogJ2RhdGEtY29sdW1uLW5hbWUnLFxuICAgICAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24gdGV4dCBzaG93biBpbiB0aGUgVVJMIGUuZy4gWyAnYXNjJywgJ2Rlc2MnIF1cbiAgICAgICAgICAgICAgICAgICAgc29ydDJIYXNoX2RpcmVjdGlvblRleHQgICAgIDogWyAnYXNjJywgJ2Rlc2MnIF0sIC8vIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRydWUsIG92ZXJyaWRlIHNhdmVTb3J0IHdpZGdldCBzb3J0LCBpZiB1c2VkICYgc3RvcmVkIHNvcnQgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIHNvcnQySGFzaF9vdmVycmlkZVNhdmVTb3J0ICA6IHRydWUsIC8vIGRlZmF1bHQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIENvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gUGx1Z2luIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRbMF07XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgdmFyIGxhdGVEZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGRvd25sb2FkOiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uOiB0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy11Zi10YWJsZS1kb3dubG9hZCcpLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAkLnByb3h5KHRoaXMuX29uRG93bmxvYWQsIHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy4kZWxlbWVudC5maW5kKCcuanMtdWYtdGFibGUtaW5mbycpLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAkLnByb3h5KHRoaXMuX3JlbmRlckluZm9NZXNzYWdlcywgdGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvdmVybGF5OiB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy11Zi10YWJsZS1vdmVybGF5JylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWJsZUVsZW1lbnQ6IHRoaXMuJGVsZW1lbnQuZmluZCgnLnRhYmxlc29ydGVyJyksXG4gICAgICAgICAgICB0YWJsZXNvcnRlcjoge1xuICAgICAgICAgICAgICAgIHdpZGdldE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uU2VsZWN0b3JfY29udGFpbmVyIDogdGhpcy4kZWxlbWVudC5maW5kKCcuanMtdWYtdGFibGUtY3Mtb3B0aW9ucycpLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfZXh0ZXJuYWwgICAgICAgICAgOiB0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy11Zi10YWJsZS1zZWFyY2ggaW5wdXQnKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBQYWdlciBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgcGFnZXJfc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgICA6IHRoaXMuJGVsZW1lbnQuZmluZCgnLmpzLXVmLXRhYmxlLXBhZ2VyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCAgICAgICA6ICcuZmlyc3QnLCAgICAgICAvLyBnbyB0byBmaXJzdCBwYWdlIGFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ICAgICAgICA6ICcucHJldicsICAgICAgICAvLyBwcmV2aW91cyBwYWdlIGFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICAgICAgICA6ICcubmV4dCcsICAgICAgICAvLyBuZXh0IHBhZ2UgYXJyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgICAgICAgIDogJy5sYXN0JywgICAgICAgIC8vIGdvIHRvIGxhc3QgcGFnZSBhcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgZ290b1BhZ2UgICAgOiAnLmdvdG9QYWdlJywgICAgLy8gZ28gdG8gcGFnZSBzZWxlY3RvciAtIHNlbGVjdCBkcm9wZG93biB0aGF0IHNldHMgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZURpc3BsYXkgOiAnLnBhZ2VkaXNwbGF5JywgLy8gbG9jYXRpb24gb2Ygd2hlcmUgdGhlIFwib3V0cHV0XCIgaXMgZGlzcGxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZSAgICA6ICcucGFnZXNpemUnICAgICAvLyBwYWdlIHNpemUgc2VsZWN0b3IgLSBzZWxlY3QgZHJvcGRvd24gdGhhdCBzZXRzIHRoZSBcInNpemVcIiBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgJC5wcm94eSB0byBwcm9wZXJseSBiaW5kIHRoZSBjb250ZXh0IGZvciBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGNhbGxlZCBieSBUYWJsZXNvcnRlclxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBVUkwgZm9yIHRoZSBBSkFYIHJlcXVlc3QsIHdpdGggdGhlIHJlbGV2YW50IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgcGFnZXJfY3VzdG9tQWpheFVybDogJC5wcm94eSh0aGlzLl9nZW5lcmF0ZVVybCwgdGhpcyksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2sgdG8gcHJvY2VzcyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQUpBWCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VyX2FqYXhQcm9jZXNzaW5nOiAkLnByb3h5KHRoaXMuX3Byb2Nlc3NBamF4LCB0aGlzKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayB0byBkaXNwbGF5IGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBwYWdlcl9hamF4RXJyb3I6ICQucHJveHkodGhpcy5fcGFnZXJBamF4RXJyb3IsIHRoaXMpLFxuXG4gICAgICAgICAgICAgICAgICAgIHNvcnQySGFzaF9lbmNvZGVIYXNoOiAkLnByb3h5KHRoaXMuX2VuY29kZUhhc2gsIHRoaXMpLFxuXG4gICAgICAgICAgICAgICAgICAgIHNvcnQySGFzaF9kZWNvZGVIYXNoOiAkLnByb3h5KHRoaXMuX2RlY29kZUhhc2gsIHRoaXMpLFxuXG4gICAgICAgICAgICAgICAgICAgIHNvcnQySGFzaF9jbGVhbkhhc2g6ICQucHJveHkodGhpcy5fY2xlYW5IYXNoLCB0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgbGF0ZURlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5fbmFtZSA9IHBsdWdpbk5hbWU7XG4gICAgICAgIHRoaXMuX2RlYnVnQWpheCA9ICh0eXBlb2YgdGhpcy5zZXR0aW5ncy5zaXRlICE9PSAndW5kZWZpbmVkJykgJiYgdGhpcy5zZXR0aW5ncy5zaXRlLmRlYnVnLmFqYXg7XG5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGF0dHJpYnV0ZXMgZnJvbSBkYXRhLSosIGRlZmF1bHQgdmFsdWVzIGlmIG5vdCBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuICAgICAgICB2YXIgcGFnZXJDb250YWluZXIgPSB0aGlzLnNldHRpbmdzLnRhYmxlc29ydGVyLndpZGdldE9wdGlvbnMucGFnZXJfc2VsZWN0b3JzLmNvbnRhaW5lcjtcbiAgICAgICAgdmFyIGluZm9Db250YWluZXIgPSB0aGlzLnNldHRpbmdzLmluZm8uY29udGFpbmVyO1xuICAgICAgICB2YXIgZGF0YUF0dHJpYnV0ZURlZmF1bHRzID0ge1xuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbXB0eVJvd3M6IGluZm9Db250YWluZXIuZGF0YSgnbWVzc2FnZS1lbXB0eS1yb3dzJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9Db250YWluZXIuZGF0YSgnbWVzc2FnZS1lbXB0eS1yb3dzJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU29ycnksIHdlJ3ZlIGdvdCBub3RoaW5nIGhlcmUuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWJsZXNvcnRlcjoge1xuICAgICAgICAgICAgICAgIHdpZGdldE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zc2libGUgdmFyaWFibGVzOiB7c2l6ZX0sIHtwYWdlfSwge3RvdGFsUGFnZXN9LCB7ZmlsdGVyZWRQYWdlc30sIHtzdGFydFJvd30sIHtlbmRSb3d9LCB7ZmlsdGVyZWRSb3dzfSBhbmQge3RvdGFsUm93c31cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB7cGFnZTppbnB1dH0gJiB7c3RhcnRSb3c6aW5wdXR9IHdpbGwgYWRkIGEgbW9kaWZpYWJsZSBpbnB1dCBpbiBwbGFjZSBvZiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcGFnZXJfb3V0cHV0OiBwYWdlckNvbnRhaW5lci5kYXRhKCdvdXRwdXQtdGVtcGxhdGUnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXJDb250YWluZXIuZGF0YSgnb3V0cHV0LXRlbXBsYXRlJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7c3RhcnRSb3d9IHRvIHtlbmRSb3d9IG9mIHtmaWx0ZXJlZFJvd3N9ICh7dG90YWxSb3dzfSknIC8vIGRlZmF1bHQgaWYgbm90IHNldCBvbiBkYXRhLSogYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YUF0dHJpYnV0ZURlZmF1bHRzLCB0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IHRhYmxlRWxlbWVudCBleGlzdHNcbiAgICAgICAgdmFyIHRhYmxlRWxlbWVudCA9IHRoaXMuc2V0dGluZ3MudGFibGVFbGVtZW50O1xuICAgICAgICBpZiAoIXRhYmxlRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndWZUYWJsZSBjb3VsZCBub3QgYmUgaW5pdGlhbGl6ZWQ6IHdyYXBwZXIgZWxlbWVudCBkb2VzIG5vdCBleGlzdCwgb3IgZG9lcyBub3QgY29udGFpbiBhIG1hdGNoZWQgdGFibGVFbGVtZW50IChzZWUgaHR0cHM6Ly9sZWFybi51c2VyZnJvc3RpbmcuY29tL2NsaWVudC1zaWRlLWNvZGUvY29tcG9uZW50cy90YWJsZXMgKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29weSBvdmVyIGRhdGFVcmwgdG8gcGFnZXJfYWpheFVybFxuICAgICAgICB0aGlzLnNldHRpbmdzLnRhYmxlc29ydGVyLndpZGdldE9wdGlvbnMucGFnZXJfYWpheFVybCA9IHRoaXMuc2V0dGluZ3MuZGF0YVVybDtcblxuICAgICAgICAvLyBTZXQgdXAgJ2xvYWRpbmcnIG92ZXJsYXlzXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVzZUxvYWRpbmdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxheSA9IHRoaXMuc2V0dGluZ3Mub3ZlcmxheS5jb250YWluZXI7XG4gICAgICAgICAgICB0YWJsZUVsZW1lbnQuYmluZCgnc29ydFN0YXJ0IGZpbHRlclN0YXJ0IHBhZ2VNb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSkuYmluZCgncGFnZXJDb21wbGV0ZSB1cGRhdGVDb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgdGFibGVzb3J0ZXIgYW5kIHBhZ2VyXG4gICAgICAgIHRoaXMudHMgPSB0YWJsZUVsZW1lbnQudGFibGVzb3J0ZXIodGhpcy5zZXR0aW5ncy50YWJsZXNvcnRlcik7XG5cbiAgICAgICAgLy8gTWFwIGRlZmF1bHQgY29sdW1uIHRlbXBsYXRlIHNlbGVjdG9ycyBiYXNlZCBvbiBkYXRhLWNvbHVtbi10ZW1wbGF0ZSBhdHRyaWJ1dGUgaW4gZWFjaCBjb2x1bW4gaGVhZGVyXG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy50c1swXS5jb25maWcuJGhlYWRlckluZGV4ZWQ7XG4gICAgICAgIHZhciBjb2x1bW5UZW1wbGF0ZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sdW1ucy5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTmFtZSA9IGNvbHVtbnNbY29sXS5kYXRhKCdjb2x1bW4tbmFtZScpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5OYW1lICYmIHRoaXMuc2V0dGluZ3MuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb2x1bW4gbnVtYmVyICcgKyBjb2wgKyAnIGlzIG1pc3NpbmcgYSBkYXRhLWNvbHVtbi1uYW1lIGF0dHJpYnV0ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbHVtblRlbXBsYXRlc1tjb2x1bW5OYW1lXSA9IGNvbHVtbnNbY29sXS5kYXRhKCdjb2x1bW4tdGVtcGxhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lcmdlIGluIGFueSBjb2x1bW4gdGVtcGxhdGUgc2VsZWN0b3JzIHRoYXQgd2VyZSBzZXQgaW4gdGhlIGN0b3Igb3B0aW9uc1xuICAgICAgICBjb2x1bW5UZW1wbGF0ZXMgPSAkLmV4dGVuZCh0cnVlLCBjb2x1bW5UZW1wbGF0ZXMsIHRoaXMuc2V0dGluZ3MuY29sdW1uVGVtcGxhdGVzKTtcblxuICAgICAgICAvLyBMb2NhdGUgYW5kIGNvbXBpbGUgdGVtcGxhdGVzIGZvciBhbnkgc3RyaW5nLWlkZW50aWZpZWQgY29sdW1uIHJlbmRlcmVyc1xuICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBidWlsZCBvdXQgYSBudW1lcmljYWxseSBpbmRleGVkIGFycmF5IG9mIHRlbXBsYXRlc1xuICAgICAgICB0aGlzLmNvbHVtblRlbXBsYXRlc0luZGV4ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sdW1ucy5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTmFtZSA9IGNvbHVtbnNbY29sXS5kYXRhKCdjb2x1bW4tbmFtZScpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5UZW1wbGF0ZXNbY29sdW1uTmFtZV0gJiYgdGhpcy5zZXR0aW5ncy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyB0ZW1wbGF0ZSBmb3VuZCBmb3IgY29sdW1uICdcIiArIGNvbHVtbk5hbWUgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbHVtblRlbXBsYXRlID0gY29sdW1uVGVtcGxhdGVzW2NvbHVtbk5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW5UZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblRlbXBsYXRlc0luZGV4ZWQucHVzaChIYW5kbGViYXJzLmNvbXBpbGUoJChjb2x1bW5UZW1wbGF0ZSkuaHRtbCgpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVGVtcGxhdGVzSW5kZXhlZC5wdXNoKGNvbHVtblRlbXBsYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvY2F0ZSBhbmQgY29tcGlsZSByb3cgdGVtcGxhdGVcbiAgICAgICAgdGhpcy5yb3dUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZSgnPHRyPicpO1xuICAgICAgICAvLyBJZiByb3dUZW1wbGF0ZVNlbGVjdG9yIGlzIHNldCwgdGhlbiBmaW5kIHRoZSBET00gZWxlbWVudCB0aGF0IGl0IHJlZmVyZW5jZXMsIHdoaWNoIGNvbnRhaW5zIHRoZSB0ZW1wbGF0ZVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yb3dUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHJvd1RlbXBsYXRlID0gdGhpcy5zZXR0aW5ncy5yb3dUZW1wbGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm93VGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZSgkKHRoaXMuc2V0dGluZ3Mucm93VGVtcGxhdGUpLmh0bWwoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm93VGVtcGxhdGUgPSByb3dUZW1wbGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpbmsgQ1NWIGRvd25sb2FkIGJ1dHRvblxuICAgICAgICB0aGlzLnNldHRpbmdzLmRvd25sb2FkLmJ1dHRvbi5vbignY2xpY2snLCB0aGlzLnNldHRpbmdzLmRvd25sb2FkLmNhbGxiYWNrKTtcblxuICAgICAgICAvLyBBbGxvdyBjbGlja2luZyBvbiB0aGUgbGFiZWxzIGluIHRoZSB0YWJsZSBtZW51IHdpdGhvdXQgY2xvc2luZyB0aGUgbWVudVxuICAgICAgICAkKHRoaXMuc2V0dGluZ3MudGFibGVzb3J0ZXIud2lkZ2V0T3B0aW9ucy5jb2x1bW5TZWxlY3Rvcl9jb250YWluZXIpLmZpbmQoJ2xhYmVsJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvcGFnYXRlIG91ciBvd24gcGFnZXJDb21wbGV0ZSBldmVudFxuICAgICAgICB0aGlzLnRzLm9uKCdwYWdlckNvbXBsZXRlJywgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhZ2VyQ29tcGxldGUudWZUYWJsZScpO1xuICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgLy8gU2hvdyBpbmZvIG1lc3NhZ2VzIHdoZW4gdGhlcmUgYXJlIG5vIHJvd3Mvbm8gcmVzdWx0c1xuICAgICAgICB0aGlzLnRzLm9uKCdmaWx0ZXJFbmQgZmlsdGVyUmVzZXQgcGFnZXJDb21wbGV0ZScsIHRoaXMuc2V0dGluZ3MuaW5mby5jYWxsYmFjayk7XG5cbiAgICAgICAgLy8gRGV0ZWN0IGNoYW5nZXMgdG8gZWxlbWVudCBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cmNoYW5nZSh7XG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzdGF0ZSB2YXJpYWJsZXMgZm9yIHRoaXMgdGFibGUsIGFzIHJlcXVpcmVkIGJ5IHRoZSBBSkFYIGRhdGEgc291cmNlOiBzb3J0cywgZmlsdGVycywgc2l6ZSwgcGFnZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuZ2V0VGFibGVTdGF0ZVZhcnMgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgICAgICB2YXIgYmFzZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gR2V0IHNvcnQgY29sdW1uIGFuZCBvcmRlclxuICAgICAgICB2YXIgc29ydE9yZGVycyA9IHtcbiAgICAgICAgICAgICcwJzogJ2FzYycsXG4gICAgICAgICAgICAnMSc6ICdkZXNjJ1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBzb3J0cyBpbiBVUkwuICBBc3N1bWVzIGVhY2ggdGggaGFzIGEgZGF0YS1jb2x1bW4tbmFtZSBhdHRyaWJ1dGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbmFtZSBpbiB0aGUgQVBJXG4gICAgICAgIHZhciBzb3J0TGlzdCA9IHRhYmxlLmNvbmZpZy5zb3J0TGlzdDtcbiAgICAgICAgdmFyIHNvcnRzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRleCA9IHNvcnRMaXN0W2ldWzBdO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkRpcmVjdGlvbiA9IHNvcnRPcmRlcnNbc29ydExpc3RbaV1bMV1dOyAgIC8vIENvbnZlcnRzIHRvICdhc2MnIG9yICdkZXNjJ1xuICAgICAgICAgICAgaWYgKHNvcnRMaXN0W2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbk5hbWUgPSB0YWJsZS5jb25maWcuJGhlYWRlckluZGV4ZWRbY29sdW1uSW5kZXhdLmRhdGEoJ2NvbHVtbi1uYW1lJyk7XG4gICAgICAgICAgICAgICAgc29ydHNbY29sdW1uTmFtZV0gPSBjb2x1bW5EaXJlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgZmlsdGVycyBpbiBVUkwuICBBc3N1bWVzIGVhY2ggdGggaGFzIGEgZGF0YS1jb2x1bW4tbmFtZSBhdHRyaWJ1dGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbmFtZSBpbiB0aGUgQVBJXG4gICAgICAgIHZhciBmaWx0ZXJMaXN0ID0gYmFzZS5nZXRTYXZlZEZpbHRlcnModGFibGUpO1xuICAgICAgICB2YXIgZmlsdGVycyA9IHt9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpbHRlckxpc3RbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uTmFtZSA9IGJhc2Uuc2V0dGluZ3MuZmlsdGVyQWxsRmllbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFibGUuY29uZmlnLiRoZWFkZXJJbmRleGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSB0YWJsZS5jb25maWcuJGhlYWRlckluZGV4ZWRbaV0uZGF0YSgnY29sdW1uLW5hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzW2NvbHVtbk5hbWVdID0gZmlsdGVyTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHNpemU6IHRhYmxlLmNvbmZpZy5wYWdlci5zaXplLFxuICAgICAgICAgICAgcGFnZTogdGFibGUuY29uZmlnLnBhZ2VyLnBhZ2UsXG4gICAgICAgICAgICBzb3J0czogc29ydHMsXG4gICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2F2ZWQgZmlsdGVycyBmcm9tIHRoZSBicm93c2VyIGxvY2FsIHN0b3JhZ2UuIFRob3NlIHNob3VsZCBhbHdheXMgYmUgdXAgdG8gZGF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuZ2V0U2F2ZWRGaWx0ZXJzID0gZnVuY3Rpb24odGFibGUpIHtcblxuICAgICAgICAvLyBGYWxsYmFjayB0byBgZ2V0RmlsdGVyc2Agb3IgZW1wdHkgaW4gY2FzZSBvZiBmYWlsdXJlXG4gICAgICAgIHZhciBmaWx0ZXJMaXN0ID0gJC50YWJsZXNvcnRlci5nZXRGaWx0ZXJzKHRhYmxlKSB8fCBbXTtcblxuICAgICAgICAvLyBPdmVyd3JpdGUgbGlzdCB3aXRoIHNhdmVkIGZpbHRlciBmb3IgZmlsdGVyLXNlbGVjdCBub3Qgc2V0dXAgYnkgdHNcbiAgICAgICAgdmFyIGlzQXJyYXksIHNhdmVkLFxuICAgICAgICAgICAgd28gPSB0YWJsZS5jb25maWcud2lkZ2V0T3B0aW9ucztcbiAgICAgICAgaWYgKCB3by5maWx0ZXJfc2F2ZUZpbHRlcnMgJiYgJC50YWJsZXNvcnRlci5zdG9yYWdlICkge1xuICAgICAgICAgICAgc2F2ZWQgPSAkLnRhYmxlc29ydGVyLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItZmlsdGVycycgKSB8fCBbXTtcbiAgICAgICAgICAgIGlzQXJyYXkgPSAkLmlzQXJyYXkoIHNhdmVkICk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UncmUgbm90IGp1c3QgZ2V0dGluZyBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgaWYgKCAhKCBpc0FycmF5ICYmIHNhdmVkLmpvaW4oICcnICkgPT09ICcnIHx8ICFpc0FycmF5ICkgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyTGlzdCA9ICQudGFibGVzb3J0ZXIuZmlsdGVyLnByb2Nlc3NGaWx0ZXJzKCBzYXZlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlckxpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIHRhYmxlXG4gICAgICovXG4gICAgUGx1Z2luLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudHMudHJpZ2dlcigncGFnZXJVcGRhdGUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIEFKQVggdXJsLlxuICAgICAqIFVzZWQgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIHBhZ2VyX2N1c3RvbUFqYXhVcmxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuX2dlbmVyYXRlVXJsID0gZnVuY3Rpb24odGFibGUsIHVybCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0VGFibGVTdGF0ZVZhcnModGFibGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0YWJsZVN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuZXh0ZW5kKHRhYmxlLmNvbmZpZy5wYWdlci5hamF4T2JqZWN0LmRhdGEsIHRhYmxlU3RhdGUpO1xuXG4gICAgICAgIC8vIE1lcmdlIGluIGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGFibGUuY29uZmlnLnBhZ2VyLmFqYXhPYmplY3QuZGF0YSwgdGhpcy5zZXR0aW5ncy5hZGRQYXJhbXMpO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBBSkFYIHJlcXVlc3QgYW5kIHJlbmRlcmluZyB0aGUgdGFibGUgY2VsbHMuXG4gICAgICogVXNlZCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgcGFnZXJfYWpheFByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuX3Byb2Nlc3NBamF4ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnRzWzBdO1xuICAgICAgICB2YXIganNvbiA9IHt9LFxuICAgICAgICAgICAgcm93cyA9ICcnO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGRhdGEucm93cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciB0YWJsZSByb3dzIGFuZCBjZWxscyB2aWEgSGFuZGxlYmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd251bTogcm93LFxuICAgICAgICAgICAgICAgICAgICByb3cgICA6IGRhdGEucm93c1tyb3ddLCAgICAgICAvLyBJdCBpcyBzYWZlIHRvIHVzZSB0aGUgZGF0YSBmcm9tIHRoZSBBUEkgYmVjYXVzZSBIYW5kbGViYXJzIGVzY2FwZXMgSFRNTFxuICAgICAgICAgICAgICAgICAgICBzaXRlICA6IHRoaXMuc2V0dGluZ3Muc2l0ZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByb3dzICs9IHRoaXMucm93VGVtcGxhdGUoY2VsbERhdGEpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2x1bW5UZW1wbGF0ZXNJbmRleGVkLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cyArPSB0aGlzLmNvbHVtblRlbXBsYXRlc0luZGV4ZWRbY29sXShjZWxsRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93cyArPSAnPC90cj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGFueSBkcm9wZG93biBmaWx0ZXJzXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRzLmNvbmZpZy4kaGVhZGVySW5kZXhlZDtcbiAgICAgICAgICAgIHRoaXMuX2FqYXhJbml0RmlsdGVyU2VsZWN0cyhjb2x1bW5zLCBkYXRhLmxpc3RhYmxlKTtcblxuICAgICAgICAgICAganNvbi50b3RhbCA9IGRhdGEuY291bnQ7ICAvLyBHZXQgdG90YWwgcm93cyB3aXRob3V0IHBhZ2luYXRpb25cbiAgICAgICAgICAgIGpzb24uZmlsdGVyZWRSb3dzID0gZGF0YS5jb3VudF9maWx0ZXJlZDsgLy8gbm8gZmlsdGVyaW5nXG4gICAgICAgICAgICBqc29uLnJvd3MgPSAkKHJvd3MpO1xuICAgICAgICAgICAganNvbi5vdXRwdXQgPSBkYXRhLm91dHB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpzb24udG90YWwgPSAwO1xuICAgICAgICAgICAganNvbi5maWx0ZXJlZFJvd3MgPSAwO1xuICAgICAgICAgICAganNvbi5yb3dzID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBmaWx0ZXIgc2VsZWN0IG1lbnVzIHVzaW5nIHRoZSBhamF4IGBsaXN0YWJsZWAgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQbHVnaW4ucHJvdG90eXBlLl9hamF4SW5pdEZpbHRlclNlbGVjdHMgPSBmdW5jdGlvbihjb2x1bW5zLCBsaXN0YWJsZSkge1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnRzWzBdO1xuICAgICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZ2V0U2F2ZWRGaWx0ZXJzKHRzKTtcbiAgICAgICAgLy8gRmluZCBjb2x1bW5zIHdpdGggYC5maWx0ZXItc2VsZWN0YCBhbmQgbWF0Y2ggdGhlbSB0byBjb2x1bW4gbnVtYmVycyBiYXNlZCBvbiB0aGVpciBkYXRhLWNvbHVtbi1uYW1lXG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNvbHVtbnMubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbY29sXTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgZGVzaWduYXRlZCBmb3IgZmlsdGVyLXNlbGVjdCwgZ2V0IHRoZSBsaXN0YWJsZXMgZnJvbSB0aGUgZGF0YSBhbmQgcmVjcmVhdGUgaXRcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaGFzQ2xhc3MoJ2ZpbHRlci1zZWxlY3QnKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5OYW1lID0gY29sdW1uLmRhdGEoJ2NvbHVtbi1uYW1lJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RhYmxlW2NvbHVtbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICQudGFibGVzb3J0ZXIuZmlsdGVyLmJ1aWxkU2VsZWN0KHRzLCBjb2wsIGxpc3RhYmxlW2NvbHVtbk5hbWVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmaWx0ZXIgYWN0dWFsbHkgc2V0IGZvciB0aGlzIGNvbHVtbiwgdXBkYXRlIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzW2NvbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RDb250cm9sID0gJCh0cykuZmluZChcIi50YWJsZXNvcnRlci1maWx0ZXJbZGF0YS1jb2x1bW49J1wiICsgY29sICsgXCInXVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdENvbnRyb2wudmFsKGZpbHRlcnNbY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBoYW5kbGVyIGZvciB0aGUgXCJkb3dubG9hZCBDU1ZcIiBidXR0b24uXG4gICAgICogRGVmYXVsdCBjYWxsYmFjayBmb3IgZG93bmxvYWQuY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuX29uRG93bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRUYWJsZVN0YXRlVmFycyh0aGlzLnRzWzBdKTtcbiAgICAgICAgdGFibGVTdGF0ZS5mb3JtYXQgPSAnY3N2JztcbiAgICAgICAgZGVsZXRlIHRhYmxlU3RhdGUucGFnZTtcbiAgICAgICAgZGVsZXRlIHRhYmxlU3RhdGUuc2l6ZTtcblxuICAgICAgICAvLyBNZXJnZSBpbiBhbnkgYWRkaXRpb25hbCByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGFibGVTdGF0ZSwgdGhpcy5zZXR0aW5ncy5hZGRQYXJhbXMpO1xuXG4gICAgICAgIC8vIENhdXNlcyBkb3dubG9hZCB0byBiZWdpblxuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB0aGlzLnNldHRpbmdzLmRhdGFVcmwgKyAnPycgKyAkLnBhcmFtKHRhYmxlU3RhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGFnZXIgYWpheCBlcnJvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQbHVnaW4ucHJvdG90eXBlLl9wYWdlckFqYXhFcnJvciA9IGZ1bmN0aW9uKGMsIGpxWEhSLCBzZXR0aW5ncywgZXhjZXB0aW9uKSB7XG4gICAgICAgIHRoaXMuX2FqYXhFcnJvcihqcVhIUik7XG5cbiAgICAgICAgLy8gTGV0IFRTIGhhbmRsZSB0aGUgaW4tdGFibGUgZXJyb3IgbWVzc2FnZVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhamF4IGVycm9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQbHVnaW4ucHJvdG90eXBlLl9hamF4RXJyb3IgPSBmdW5jdGlvbihqcVhIUikge1xuICAgICAgICBpZiAodHlwZW9mIGpxWEhSID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gRXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0FqYXggJiYganFYSFIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoanFYSFIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5ERUJVRykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgKCcgKyBqcVhIUi5zdGF0dXMgKyAnKTogJyArIGpxWEhSLnJlc3BvbnNlVGV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IGVycm9ycyBvbiBmYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdWZBbGVydHMgd2lkZ2V0IHNob3VsZCBoYXZlIGEgJ2Rlc3Ryb3knIG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5tc2dUYXJnZXQuZGF0YSgndWZBbGVydHMnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1zZ1RhcmdldC51ZkFsZXJ0cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubXNnVGFyZ2V0LnVmQWxlcnRzKCdjbGVhcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubXNnVGFyZ2V0LnVmQWxlcnRzKCdmZXRjaCcpLnVmQWxlcnRzKCdyZW5kZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgaW5mbyBtZXNzYWdlcywgc3VjaCBhcyB3aGVuIHRoZXJlIGFyZSBubyByZXN1bHRzLlxuICAgICAqIERlZmF1bHQgY2FsbGJhY2sgZm9yIGluZm8uY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuX3JlbmRlckluZm9NZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy50c1swXTtcbiAgICAgICAgdmFyIGluZm9NZXNzYWdlcyA9IHRoaXMuc2V0dGluZ3MuaW5mby5jb250YWluZXI7XG4gICAgICAgIGlmICh0YWJsZS5jb25maWcucGFnZXIpIHtcbiAgICAgICAgICAgIGluZm9NZXNzYWdlcy5odG1sKCcnKTtcbiAgICAgICAgICAgIHZhciBmciA9IHRhYmxlLmNvbmZpZy5wYWdlci5maWx0ZXJlZFJvd3M7XG4gICAgICAgICAgICBpZiAoZnIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbmZvTWVzc2FnZXMuaHRtbCh0aGlzLnNldHRpbmdzLmluZm8ubWVzc2FnZUVtcHR5Um93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBjdXJyZW50IHRhYmxlIHN0YXRlIHZhcmlhYmxlcyBpbnRvIGEgVVJMIGhhc2guXG4gICAgICogRGVmYXVsdCBjYWxsYmFjayBmb3Igc29ydDJIYXNoX2VuY29kZUhhc2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBsdWdpbi5wcm90b3R5cGUuX2VuY29kZUhhc2ggPSBmdW5jdGlvbihjb25maWcsIHRhYmxlSWQsIGNvbXBvbmVudCwgdmFsdWUsIHJhd1ZhbHVlKSB7XG4gICAgICAgIHZhciB3byA9IGNvbmZpZy53aWRnZXRPcHRpb25zO1xuICAgICAgICBpZiAoIGNvbXBvbmVudCA9PT0gJ2ZpbHRlcicgKSB7XG4gICAgICAgICAgICAvLyByYXdWYWx1ZSBpcyBhbiBhcnJheSBvZiBmaWx0ZXIgdmFsdWVzLCBudW1lcmljYWxseSBpbmRleGVkXG4gICAgICAgICAgICB2YXIgZW5jb2RlZEZpbHRlcnMgPSAnJztcbiAgICAgICAgICAgIHZhciBsZW4gPSByYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1ZhbHVlW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uTmFtZSA9IHRoaXMuc2V0dGluZ3MuZmlsdGVyQWxsRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuJGhlYWRlckluZGV4ZWRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OYW1lID0gJChjb25maWcuJGhlYWRlckluZGV4ZWRbaW5kZXhdWzBdKS5hdHRyKHdvLnNvcnQySGFzaF9oZWFkZXJUZXh0QXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZEZpbHRlcnMgKz0gJyZmaWx0ZXJbJyArIHRhYmxlSWQgKyAnXVsnICsgY29sdW1uTmFtZSArICddPScgKyBlbmNvZGVVUklDb21wb25lbnQocmF3VmFsdWVbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZEZpbHRlcnM7XG4gICAgICAgIH0gZWxzZSBpZiAoIGNvbXBvbmVudCA9PT0gJ3NvcnQnICkge1xuICAgICAgICAgICAgLy8gcmF3VmFsdWUgaXMgYW4gYXJyYXkgb2Ygc29ydCBwYWlycyBbY29sdW1uTnVtLCBzb3J0RGlyZWN0aW9uXVxuICAgICAgICAgICAgdmFyIGVuY29kZWRGaWx0ZXJzID0gJyc7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5OdW0gPSByYXdWYWx1ZVtpbmRleF1bMF07XG4gICAgICAgICAgICAgICAgdmFyIHNvcnREaXJlY3Rpb24gPSByYXdWYWx1ZVtpbmRleF1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbk5hbWUgPSAkKGNvbmZpZy4kaGVhZGVySW5kZXhlZFtjb2x1bW5OdW1dWzBdKS5hdHRyKHdvLnNvcnQySGFzaF9oZWFkZXJUZXh0QXR0cik7XG4gICAgICAgICAgICAgICAgZW5jb2RlZEZpbHRlcnMgKz0gJyZzb3J0WycgKyB0YWJsZUlkICsgJ11bJyArIGNvbHVtbk5hbWUgKyAnXT0nICsgd28uc29ydDJIYXNoX2RpcmVjdGlvblRleHRbc29ydERpcmVjdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZEZpbHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGN1cnJlbnQgdGFibGUgc3RhdGUgdmFyaWFibGVzIGZyb20gdGhlIFVSTCBoYXNoLlxuICAgICAqIERlZmF1bHQgY2FsbGJhY2sgZm9yIHNvcnQySGFzaF9kZWNvZGVIYXNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQbHVnaW4ucHJvdG90eXBlLl9kZWNvZGVIYXNoID0gZnVuY3Rpb24oY29uZmlnLCB0YWJsZUlkLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHdvID0gY29uZmlnLndpZGdldE9wdGlvbnM7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIENvbnZlcnQgaGFzaCBpbnRvIEpTT04gb2JqZWN0XG4gICAgICAgIHZhciB1cmxPYmplY3QgPSAkLlN0cmluZy5kZXBhcmFtKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcbiAgICAgICAgZGVsZXRlIHVybE9iamVjdFt3by5zb3J0Mkhhc2hfaGFzaF07ICAvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2ZpbHRlcicpIHtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkRmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBmaWx0ZXIgbmFtZXMgYW5kIHZhbHVlcyBmb3IgdGhlIHNwZWNpZmllZCB0YWJsZVxuICAgICAgICAgICAgdmFyIHBhZ2VGaWx0ZXJzID0gdXJsT2JqZWN0LmZpbHRlciA/IHVybE9iamVjdC5maWx0ZXIgOiBbXTtcbiAgICAgICAgICAgIGlmIChwYWdlRmlsdGVyc1t0YWJsZUlkXSkge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZUZpbHRlcnMgPSBwYWdlRmlsdGVyc1t0YWJsZUlkXTtcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIG51bWVyaWNhbGx5IGluZGV4ZWQgYXJyYXkgb2YgZmlsdGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjb25maWcuJGhlYWRlckluZGV4ZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbk5hbWUgPSAkKGNvbmZpZy4kaGVhZGVySW5kZXhlZFtpbmRleF1bMF0pLmF0dHIod28uc29ydDJIYXNoX2hlYWRlclRleHRBdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlRmlsdGVyc1tjb2x1bW5OYW1lXSAmJiB0YWJsZUZpbHRlcnNbY29sdW1uTmFtZV0gIT0gdGhpcy5zZXR0aW5ncy5maWx0ZXJBbGxGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEZpbHRlcnMucHVzaCh0YWJsZUZpbHRlcnNbY29sdW1uTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEZpbHRlcnMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhcnJheSBvZiBmaWx0ZXIgdmFsdWVzIHRvIGEgZGVsaW1pdGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZWRGaWx0ZXJzLmpvaW4od28uc29ydDJIYXNoX3NlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHVzZSBkZWNvZGVVUklDb21wb25lbnQgb24gdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgVVJMIGhhc2guXG4gICAgICogRGVmYXVsdCBjYWxsYmFjayBmb3Igc29ydDJIYXNoX2NsZWFuSGFzaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGx1Z2luLnByb3RvdHlwZS5fY2xlYW5IYXNoID0gZnVuY3Rpb24oY29uZmlnLCB0YWJsZUlkLCBjb21wb25lbnQsIGhhc2gpIHtcbiAgICAgICAgdmFyIHdvID0gY29uZmlnLndpZGdldE9wdGlvbnM7XG4gICAgICAgIC8vIENvbnZlcnQgaGFzaCB0byBKU09OIG9iamVjdFxuICAgICAgICB2YXIgdXJsT2JqZWN0ID0gJC5TdHJpbmcuZGVwYXJhbShoYXNoKTtcbiAgICAgICAgZGVsZXRlIHVybE9iamVjdFt3by5zb3J0Mkhhc2hfaGFzaF07ICAvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gUmVtb3ZlIHNwZWNpZmllZCBjb21wb25lbnQgZm9yIHNwZWNpZmllZCB0YWJsZVxuICAgICAgICBpZiAodXJsT2JqZWN0W2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgIGlmICh1cmxPYmplY3RbY29tcG9uZW50XVt0YWJsZUlkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB1cmxPYmplY3RbY29tcG9uZW50XVt0YWJsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSBlbnRpcmUgY29tcG9uZW50IGlmIG5vIG90aGVyIHRhYmxlcyByZW1haW5pbmdcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdCh1cmxPYmplY3RbY29tcG9uZW50XSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdXJsT2JqZWN0W2NvbXBvbmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBtb2RpZmllZCBKU09OIG9iamVjdCBiYWNrIGludG8gc2VyaWFsaXplZCByZXByZXNlbnRhdGlvblxuICAgICAgICB2YXIgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGpRdWVyeS5wYXJhbSh1cmxPYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiAnJztcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlcyBpbnN0YW50aWF0aW9uIGFuZCBhY2Nlc3MgdG8gbm9uLXByaXZhdGUgbWV0aG9kcy5cbiAgICAkLmZuW3BsdWdpbk5hbWVdID0gZnVuY3Rpb24obWV0aG9kT3JPcHRpb25zKSB7XG4gICAgICAgIC8vIEdyYWIgcGx1Z2luIGluc3RhbmNlXG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICQodGhpcykuZGF0YShwbHVnaW5OYW1lKTtcbiAgICAgICAgLy8gSWYgdW5kZWZpbmVkIG9yIG9iamVjdCwgaW5pdGlhbGl6ZSBwbHVnaW4uXG4gICAgICAgIGlmIChtZXRob2RPck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0aG9kT3JPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gT25seSBpbml0aWFsaXplIGlmIG5vdCBwcmV2aW91c2x5IGRvbmUuXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKHBsdWdpbk5hbWUsIG5ldyBQbHVnaW4odGhpcywgbWV0aG9kT3JPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGVuc3VyZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB2YWxpZCBzdHJpbmcsIGFuZCBpcyB0aGUgbmFtZSBvZiBhbiBhY3R1YWwgZnVuY3Rpb24uXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1ldGhvZE9yT3B0aW9ucyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGluc3RhbmNlW21ldGhvZE9yT3B0aW9uc10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBub3QgYSBwcml2YXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAobWV0aG9kT3JPcHRpb25zLmluZGV4T2YoJ18nKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RPck9wdGlvbnNdKCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybiggJ01ldGhvZCAnICsgIG1ldGhvZE9yT3B0aW9ucyArICcgaXMgcHJpdmF0ZSEnICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdNZXRob2QgJyArICBtZXRob2RPck9wdGlvbnMgKyAnIGRvZXMgbm90IGV4aXN0LicgKTtcbiAgICAgICAgfVxuICAgIH07XG59KShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLyohIHRhYmxlc29ydGVyIChGT1JLKSAtIHVwZGF0ZWQgMjAyMC0wMy0wMyAodjIuMzEuMykqL1xyXG4vKiBJbmNsdWRlcyB3aWRnZXRzICggc3RvcmFnZSx1aXRoZW1lLGNvbHVtbnMsZmlsdGVyLHN0aWNreUhlYWRlcnMscmVzaXphYmxlLHNhdmVTb3J0ICkgKi9cclxuKGZ1bmN0aW9uKGZhY3Rvcnkpe2lmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpe2RlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTt9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpe21vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7fSBlbHNlIHtmYWN0b3J5KGpRdWVyeSk7fX0oZnVuY3Rpb24oalF1ZXJ5KSB7XHJcbi8qISBUYWJsZVNvcnRlciAoRk9SSykgdjIuMzEuMyAqLy8qXG4qIENsaWVudC1zaWRlIHRhYmxlIHNvcnRpbmcgd2l0aCBlYXNlIVxuKiBAcmVxdWlyZXMgalF1ZXJ5IHYxLjIuNitcbipcbiogQ29weXJpZ2h0IChjKSAyMDA3IENocmlzdGlhbiBCYWNoXG4qIGZvcmsgbWFpbnRhaW5lZCBieSBSb2IgR2Fycmlzb25cbipcbiogRXhhbXBsZXMgYW5kIG9yaWdpbmFsIGRvY3MgYXQ6IGh0dHA6Ly90YWJsZXNvcnRlci5jb21cbiogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4qIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuKlxuKiBAdHlwZSBqUXVlcnlcbiogQG5hbWUgdGFibGVzb3J0ZXIgKEZPUkspXG4qIEBjYXQgUGx1Z2lucy9UYWJsZXNvcnRlclxuKiBAYXV0aG9yIENocmlzdGlhbiBCYWNoIC0gY2hyaXN0aWFuLmJhY2hAcG9seWVzdGVyLnNlXG4qIEBjb250cmlidXRvciBSb2IgR2Fycmlzb24gLSBodHRwczovL2dpdGh1Yi5jb20vTW90dGllL3RhYmxlc29ydGVyXG4qIEBkb2NzIChmb3JrKSAtIGh0dHBzOi8vbW90dGllLmdpdGh1Yi5pby90YWJsZXNvcnRlci9kb2NzL1xuKi9cbi8qanNoaW50IGJyb3dzZXI6dHJ1ZSwganF1ZXJ5OnRydWUsIHVudXNlZDpmYWxzZSwgZXhwcjogdHJ1ZSAqL1xuOyggZnVuY3Rpb24oICQgKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciA9IHtcblxuXHRcdHZlcnNpb24gOiAnMi4zMS4zJyxcblxuXHRcdHBhcnNlcnMgOiBbXSxcblx0XHR3aWRnZXRzIDogW10sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cblx0XHRcdC8vICoqKiBhcHBlYXJhbmNlXG5cdFx0XHR0aGVtZSAgICAgICAgICAgIDogJ2RlZmF1bHQnLCAgLy8gYWRkcyB0YWJsZXNvcnRlci17dGhlbWV9IHRvIHRoZSB0YWJsZSBmb3Igc3R5bGluZ1xuXHRcdFx0d2lkdGhGaXhlZCAgICAgICA6IGZhbHNlLCAgICAgIC8vIGFkZHMgY29sZ3JvdXAgdG8gZml4IHdpZHRocyBvZiBjb2x1bW5zXG5cdFx0XHRzaG93UHJvY2Vzc2luZyAgIDogZmFsc2UsICAgICAgLy8gc2hvdyBhbiBpbmRldGVybWluYXRlIHRpbWVyIGljb24gaW4gdGhlIGhlYWRlciB3aGVuIHRoZSB0YWJsZSBpcyBzb3J0ZWQgb3IgZmlsdGVyZWQuXG5cblx0XHRcdGhlYWRlclRlbXBsYXRlICAgOiAne2NvbnRlbnR9JywvLyBoZWFkZXIgbGF5b3V0IHRlbXBsYXRlIChIVE1MIG9rKTsge2NvbnRlbnR9ID0gaW5uZXJIVE1MLCB7aWNvbn0gPSA8aS8+IC8vIGNsYXNzIGZyb20gY3NzSWNvblxuXHRcdFx0b25SZW5kZXJUZW1wbGF0ZSA6IG51bGwsICAgICAgIC8vIGZ1bmN0aW9uKCBpbmRleCwgdGVtcGxhdGUgKSB7IHJldHVybiB0ZW1wbGF0ZTsgfSwgLy8gdGVtcGxhdGUgaXMgYSBzdHJpbmdcblx0XHRcdG9uUmVuZGVySGVhZGVyICAgOiBudWxsLCAgICAgICAvLyBmdW5jdGlvbiggaW5kZXggKSB7fSwgLy8gbm90aGluZyB0byByZXR1cm5cblxuXHRcdFx0Ly8gKioqIGZ1bmN0aW9uYWxpdHlcblx0XHRcdGNhbmNlbFNlbGVjdGlvbiAgOiB0cnVlLCAgICAgICAvLyBwcmV2ZW50IHRleHQgc2VsZWN0aW9uIGluIHRoZSBoZWFkZXJcblx0XHRcdHRhYkluZGV4ICAgICAgICAgOiB0cnVlLCAgICAgICAvLyBhZGQgdGFiaW5kZXggdG8gaGVhZGVyIGZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XG5cdFx0XHRkYXRlRm9ybWF0ICAgICAgIDogJ21tZGR5eXl5JywgLy8gb3RoZXIgb3B0aW9uczogJ2RkbW15eXknIG9yICd5eXl5bW1kZCdcblx0XHRcdHNvcnRNdWx0aVNvcnRLZXkgOiAnc2hpZnRLZXknLCAvLyBrZXkgdXNlZCB0byBzZWxlY3QgYWRkaXRpb25hbCBjb2x1bW5zXG5cdFx0XHRzb3J0UmVzZXRLZXkgICAgIDogJ2N0cmxLZXknLCAgLy8ga2V5IHVzZWQgdG8gcmVtb3ZlIHNvcnRpbmcgb24gYSBjb2x1bW5cblx0XHRcdHVzTnVtYmVyRm9ybWF0ICAgOiB0cnVlLCAgICAgICAvLyBmYWxzZSBmb3IgR2VybWFuICcxLjIzNC41NjcsODknIG9yIEZyZW5jaCAnMSAyMzQgNTY3LDg5J1xuXHRcdFx0ZGVsYXlJbml0ICAgICAgICA6IGZhbHNlLCAgICAgIC8vIGlmIGZhbHNlLCB0aGUgcGFyc2VkIHRhYmxlIGNvbnRlbnRzIHdpbGwgbm90IHVwZGF0ZSB1bnRpbCB0aGUgZmlyc3Qgc29ydFxuXHRcdFx0c2VydmVyU2lkZVNvcnRpbmc6IGZhbHNlLCAgICAgIC8vIGlmIHRydWUsIHNlcnZlci1zaWRlIHNvcnRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBiZWNhdXNlIGNsaWVudC1zaWRlIHNvcnRpbmcgd2lsbCBiZSBkaXNhYmxlZCwgYnV0IHRoZSB1aSBhbmQgZXZlbnRzIHdpbGwgc3RpbGwgYmUgdXNlZC5cblx0XHRcdHJlc29ydCAgICAgICAgICAgOiB0cnVlLCAgICAgICAvLyBkZWZhdWx0IHNldHRpbmcgdG8gdHJpZ2dlciBhIHJlc29ydCBhZnRlciBhbiAndXBkYXRlJywgJ2FkZFJvd3MnLCAndXBkYXRlQ2VsbCcsIGV0YyBoYXMgY29tcGxldGVkXG5cblx0XHRcdC8vICoqKiBzb3J0IG9wdGlvbnNcblx0XHRcdGhlYWRlcnMgICAgICAgICAgOiB7fSwgICAgICAgICAvLyBzZXQgc29ydGVyLCBzdHJpbmcsIGVtcHR5LCBsb2NrZWQgb3JkZXIsIHNvcnRJbml0aWFsT3JkZXIsIGZpbHRlciwgZXRjLlxuXHRcdFx0aWdub3JlQ2FzZSAgICAgICA6IHRydWUsICAgICAgIC8vIGlnbm9yZSBjYXNlIHdoaWxlIHNvcnRpbmdcblx0XHRcdHNvcnRGb3JjZSAgICAgICAgOiBudWxsLCAgICAgICAvLyBjb2x1bW4ocykgZmlyc3Qgc29ydGVkOyBhbHdheXMgYXBwbGllZFxuXHRcdFx0c29ydExpc3QgICAgICAgICA6IFtdLCAgICAgICAgIC8vIEluaXRpYWwgc29ydCBvcmRlcjsgYXBwbGllZCBpbml0aWFsbHk7IHVwZGF0ZWQgd2hlbiBtYW51YWxseSBzb3J0ZWRcblx0XHRcdHNvcnRBcHBlbmQgICAgICAgOiBudWxsLCAgICAgICAvLyBjb2x1bW4ocykgc29ydGVkIGxhc3Q7IGFsd2F5cyBhcHBsaWVkXG5cdFx0XHRzb3J0U3RhYmxlICAgICAgIDogZmFsc2UsICAgICAgLy8gd2hlbiBzb3J0aW5nIHR3byByb3dzIHdpdGggZXhhY3RseSB0aGUgc2FtZSBjb250ZW50LCB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBpcyBtYWludGFpbmVkXG5cblx0XHRcdHNvcnRJbml0aWFsT3JkZXIgOiAnYXNjJywgICAgICAvLyBzb3J0IGRpcmVjdGlvbiBvbiBmaXJzdCBjbGlja1xuXHRcdFx0c29ydExvY2FsZUNvbXBhcmU6IGZhbHNlLCAgICAgIC8vIHJlcGxhY2UgZXF1aXZhbGVudCBjaGFyYWN0ZXIgKGFjY2VudGVkIGNoYXJhY3RlcnMpXG5cdFx0XHRzb3J0UmVzZXQgICAgICAgIDogZmFsc2UsICAgICAgLy8gdGhpcmQgY2xpY2sgb24gdGhlIGhlYWRlciB3aWxsIHJlc2V0IGNvbHVtbiB0byBkZWZhdWx0IC0gdW5zb3J0ZWRcblx0XHRcdHNvcnRSZXN0YXJ0ICAgICAgOiBmYWxzZSwgICAgICAvLyByZXN0YXJ0IHNvcnQgdG8gJ3NvcnRJbml0aWFsT3JkZXInIHdoZW4gY2xpY2tpbmcgb24gcHJldmlvdXNseSB1bnNvcnRlZCBjb2x1bW5zXG5cblx0XHRcdGVtcHR5VG8gICAgICAgICAgOiAnYm90dG9tJywgICAvLyBzb3J0IGVtcHR5IGNlbGwgdG8gYm90dG9tLCB0b3AsIG5vbmUsIHplcm8sIGVtcHR5TWF4LCBlbXB0eU1pblxuXHRcdFx0c3RyaW5nVG8gICAgICAgICA6ICdtYXgnLCAgICAgIC8vIHNvcnQgc3RyaW5ncyBpbiBudW1lcmljYWwgY29sdW1uIGFzIG1heCwgbWluLCB0b3AsIGJvdHRvbSwgemVyb1xuXHRcdFx0ZHVwbGljYXRlU3BhbiAgICA6IHRydWUsICAgICAgIC8vIGNvbHNwYW4gY2VsbHMgaW4gdGhlIHRib2R5IHdpbGwgaGF2ZSBkdXBsaWNhdGVkIGNvbnRlbnQgaW4gdGhlIGNhY2hlIGZvciBlYWNoIHNwYW5uZWQgY29sdW1uXG5cdFx0XHR0ZXh0RXh0cmFjdGlvbiAgIDogJ2Jhc2ljJywgICAgLy8gdGV4dCBleHRyYWN0aW9uIG1ldGhvZC9mdW5jdGlvbiAtIGZ1bmN0aW9uKCBub2RlLCB0YWJsZSwgY2VsbEluZGV4ICkge31cblx0XHRcdHRleHRBdHRyaWJ1dGUgICAgOiAnZGF0YS10ZXh0JywvLyBkYXRhLWF0dHJpYnV0ZSB0aGF0IGNvbnRhaW5zIGFsdGVybmF0ZSBjZWxsIHRleHQgKHVzZWQgaW4gZGVmYXVsdCB0ZXh0RXh0cmFjdGlvbiBmdW5jdGlvbilcblx0XHRcdHRleHRTb3J0ZXIgICAgICAgOiBudWxsLCAgICAgICAvLyBjaG9vc2Ugb3ZlcmFsbCBvciBzcGVjaWZpYyBjb2x1bW4gc29ydGVyIGZ1bmN0aW9uKCBhLCBiLCBkaXJlY3Rpb24sIHRhYmxlLCBjb2x1bW5JbmRleCApIFthbHQ6IHRzLnNvcnRUZXh0XVxuXHRcdFx0bnVtYmVyU29ydGVyICAgICA6IG51bGwsICAgICAgIC8vIGNob29zZSBvdmVyYWxsIG51bWVyaWMgc29ydGVyIGZ1bmN0aW9uKCBhLCBiLCBkaXJlY3Rpb24sIG1heENvbHVtblZhbHVlIClcblxuXHRcdFx0Ly8gKioqIHdpZGdldCBvcHRpb25zXG5cdFx0XHRpbml0V2lkZ2V0cyAgICAgIDogdHJ1ZSwgICAgICAgLy8gYXBwbHkgd2lkZ2V0cyBvbiB0YWJsZXNvcnRlciBpbml0aWFsaXphdGlvblxuXHRcdFx0d2lkZ2V0Q2xhc3MgICAgICA6ICd3aWRnZXQte25hbWV9JywgLy8gdGFibGUgY2xhc3MgbmFtZSB0ZW1wbGF0ZSB0byBtYXRjaCB0byBpbmNsdWRlIGEgd2lkZ2V0XG5cdFx0XHR3aWRnZXRzICAgICAgICAgIDogW10sICAgICAgICAgLy8gbWV0aG9kIHRvIGFkZCB3aWRnZXRzLCBlLmcuIHdpZGdldHM6IFsnemVicmEnXVxuXHRcdFx0d2lkZ2V0T3B0aW9ucyAgICA6IHtcblx0XHRcdFx0emVicmEgOiBbICdldmVuJywgJ29kZCcgXSAgLy8gemVicmEgd2lkZ2V0IGFsdGVybmF0aW5nIHJvdyBjbGFzcyBuYW1lc1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gKioqIGNhbGxiYWNrc1xuXHRcdFx0aW5pdGlhbGl6ZWQgICAgICA6IG51bGwsICAgICAgIC8vIGZ1bmN0aW9uKCB0YWJsZSApIHt9LFxuXG5cdFx0XHQvLyAqKiogZXh0cmEgY3NzIGNsYXNzIG5hbWVzXG5cdFx0XHR0YWJsZUNsYXNzICAgICAgIDogJycsXG5cdFx0XHRjc3NBc2MgICAgICAgICAgIDogJycsXG5cdFx0XHRjc3NEZXNjICAgICAgICAgIDogJycsXG5cdFx0XHRjc3NOb25lICAgICAgICAgIDogJycsXG5cdFx0XHRjc3NIZWFkZXIgICAgICAgIDogJycsXG5cdFx0XHRjc3NIZWFkZXJSb3cgICAgIDogJycsXG5cdFx0XHRjc3NQcm9jZXNzaW5nICAgIDogJycsIC8vIHByb2Nlc3NpbmcgaWNvbiBhcHBsaWVkIHRvIGhlYWRlciBkdXJpbmcgc29ydC9maWx0ZXJcblxuXHRcdFx0Y3NzQ2hpbGRSb3cgICAgICA6ICd0YWJsZXNvcnRlci1jaGlsZFJvdycsIC8vIGNsYXNzIG5hbWUgaW5kaWNpYXRpbmcgdGhhdCBhIHJvdyBpcyB0byBiZSBhdHRhY2hlZCB0byBpdHMgcGFyZW50XG5cdFx0XHRjc3NJbmZvQmxvY2sgICAgIDogJ3RhYmxlc29ydGVyLWluZm9Pbmx5JywgLy8gZG9uJ3Qgc29ydCB0Ym9keSB3aXRoIHRoaXMgY2xhc3MgbmFtZSAob25seSBvbmUgY2xhc3MgbmFtZSBhbGxvd2VkIGhlcmUhKVxuXHRcdFx0Y3NzTm9Tb3J0ICAgICAgICA6ICd0YWJsZXNvcnRlci1ub1NvcnQnLCAgIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gZWxlbWVudCBpbnNpZGUgaGVhZGVyOyBjbGlja2luZyBvbiBpdCB3b24ndCBjYXVzZSBhIHNvcnRcblx0XHRcdGNzc0lnbm9yZVJvdyAgICAgOiAndGFibGVzb3J0ZXItaWdub3JlUm93JywvLyBoZWFkZXIgcm93IHRvIGlnbm9yZTsgY2VsbHMgd2l0aGluIHRoaXMgcm93IHdpbGwgbm90IGJlIGFkZGVkIHRvIGMuJGhlYWRlcnNcblxuXHRcdFx0Y3NzSWNvbiAgICAgICAgICA6ICd0YWJsZXNvcnRlci1pY29uJywgLy8gaWYgdGhpcyBjbGFzcyBkb2VzIG5vdCBleGlzdCwgdGhlIHtpY29ufSB3aWxsIG5vdCBiZSBhZGRlZCBmcm9tIHRoZSBoZWFkZXJUZW1wbGF0ZVxuXHRcdFx0Y3NzSWNvbk5vbmUgICAgICA6ICcnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBpY29uIHdoZW4gdGhlcmUgaXMgbm8gY29sdW1uIHNvcnRcblx0XHRcdGNzc0ljb25Bc2MgICAgICAgOiAnJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgaWNvbiB3aGVuIHRoZSBjb2x1bW4gaGFzIGFuIGFzY2VuZGluZyBzb3J0XG5cdFx0XHRjc3NJY29uRGVzYyAgICAgIDogJycsIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGljb24gd2hlbiB0aGUgY29sdW1uIGhhcyBhIGRlc2NlbmRpbmcgc29ydFxuXHRcdFx0Y3NzSWNvbkRpc2FibGVkICA6ICcnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBpY29uIHdoZW4gdGhlIGNvbHVtbiBoYXMgYSBkaXNhYmxlZCBzb3J0XG5cblx0XHRcdC8vICoqKiBldmVudHNcblx0XHRcdHBvaW50ZXJDbGljayAgICAgOiAnY2xpY2snLFxuXHRcdFx0cG9pbnRlckRvd24gICAgICA6ICdtb3VzZWRvd24nLFxuXHRcdFx0cG9pbnRlclVwICAgICAgICA6ICdtb3VzZXVwJyxcblxuXHRcdFx0Ly8gKioqIHNlbGVjdG9yc1xuXHRcdFx0c2VsZWN0b3JIZWFkZXJzICA6ICc+IHRoZWFkIHRoLCA+IHRoZWFkIHRkJyxcblx0XHRcdHNlbGVjdG9yU29ydCAgICAgOiAndGgsIHRkJywgLy8galF1ZXJ5IHNlbGVjdG9yIG9mIGNvbnRlbnQgd2l0aGluIHNlbGVjdG9ySGVhZGVycyB0aGF0IGlzIGNsaWNrYWJsZSB0byB0cmlnZ2VyIGEgc29ydFxuXHRcdFx0c2VsZWN0b3JSZW1vdmUgICA6ICcucmVtb3ZlLW1lJyxcblxuXHRcdFx0Ly8gKioqIGFkdmFuY2VkXG5cdFx0XHRkZWJ1ZyAgICAgICAgICAgIDogZmFsc2UsXG5cblx0XHRcdC8vICoqKiBJbnRlcm5hbCB2YXJpYWJsZXNcblx0XHRcdGhlYWRlckxpc3Q6IFtdLFxuXHRcdFx0ZW1wdGllczoge30sXG5cdFx0XHRzdHJpbmdzOiB7fSxcblx0XHRcdHBhcnNlcnM6IFtdLFxuXG5cdFx0XHQvLyAqKiogcGFyc2VyIG9wdGlvbnMgZm9yIHZhbGlkYXRvcjsgdmFsdWVzIG11c3QgYmUgZmFsc3khXG5cdFx0XHRnbG9iYWxpemU6IDAsXG5cdFx0XHRpbWdBdHRyOiAwXG5cblx0XHRcdC8vIHJlbW92ZWQ6IHdpZGdldFplYnJhOiB7IGNzczogWydldmVuJywgJ29kZCddIH1cblxuXHRcdH0sXG5cblx0XHQvLyBpbnRlcm5hbCBjc3MgY2xhc3NlcyAtIHRoZXNlIHdpbGwgQUxXQVlTIGJlIGFkZGVkIHRvXG5cdFx0Ly8gdGhlIHRhYmxlIGFuZCBNVVNUIG9ubHkgY29udGFpbiBvbmUgY2xhc3MgbmFtZSAtIGZpeGVzICMzODFcblx0XHRjc3MgOiB7XG5cdFx0XHR0YWJsZSAgICAgIDogJ3RhYmxlc29ydGVyJyxcblx0XHRcdGNzc0hhc0NoaWxkOiAndGFibGVzb3J0ZXItaGFzQ2hpbGRSb3cnLFxuXHRcdFx0Y2hpbGRSb3cgICA6ICd0YWJsZXNvcnRlci1jaGlsZFJvdycsXG5cdFx0XHRjb2xncm91cCAgIDogJ3RhYmxlc29ydGVyLWNvbGdyb3VwJyxcblx0XHRcdGhlYWRlciAgICAgOiAndGFibGVzb3J0ZXItaGVhZGVyJyxcblx0XHRcdGhlYWRlclJvdyAgOiAndGFibGVzb3J0ZXItaGVhZGVyUm93Jyxcblx0XHRcdGhlYWRlckluICAgOiAndGFibGVzb3J0ZXItaGVhZGVyLWlubmVyJyxcblx0XHRcdGljb24gICAgICAgOiAndGFibGVzb3J0ZXItaWNvbicsXG5cdFx0XHRwcm9jZXNzaW5nIDogJ3RhYmxlc29ydGVyLXByb2Nlc3NpbmcnLFxuXHRcdFx0c29ydEFzYyAgICA6ICd0YWJsZXNvcnRlci1oZWFkZXJBc2MnLFxuXHRcdFx0c29ydERlc2MgICA6ICd0YWJsZXNvcnRlci1oZWFkZXJEZXNjJyxcblx0XHRcdHNvcnROb25lICAgOiAndGFibGVzb3J0ZXItaGVhZGVyVW5Tb3J0ZWQnXG5cdFx0fSxcblxuXHRcdC8vIGxhYmVscyBhcHBsaWVkIHRvIHNvcnRhYmxlIGhlYWRlcnMgZm9yIGFjY2Vzc2liaWxpdHkgKGFyaWEpIHN1cHBvcnRcblx0XHRsYW5ndWFnZSA6IHtcblx0XHRcdHNvcnRBc2MgICAgICA6ICdBc2NlbmRpbmcgc29ydCBhcHBsaWVkLCAnLFxuXHRcdFx0c29ydERlc2MgICAgIDogJ0Rlc2NlbmRpbmcgc29ydCBhcHBsaWVkLCAnLFxuXHRcdFx0c29ydE5vbmUgICAgIDogJ05vIHNvcnQgYXBwbGllZCwgJyxcblx0XHRcdHNvcnREaXNhYmxlZCA6ICdzb3J0aW5nIGlzIGRpc2FibGVkJyxcblx0XHRcdG5leHRBc2MgICAgICA6ICdhY3RpdmF0ZSB0byBhcHBseSBhbiBhc2NlbmRpbmcgc29ydCcsXG5cdFx0XHRuZXh0RGVzYyAgICAgOiAnYWN0aXZhdGUgdG8gYXBwbHkgYSBkZXNjZW5kaW5nIHNvcnQnLFxuXHRcdFx0bmV4dE5vbmUgICAgIDogJ2FjdGl2YXRlIHRvIHJlbW92ZSB0aGUgc29ydCdcblx0XHR9LFxuXG5cdFx0cmVnZXggOiB7XG5cdFx0XHR0ZW1wbGF0ZUNvbnRlbnQgOiAvXFx7Y29udGVudFxcfS9nLFxuXHRcdFx0dGVtcGxhdGVJY29uICAgIDogL1xce2ljb25cXH0vZyxcblx0XHRcdHRlbXBsYXRlTmFtZSAgICA6IC9cXHtuYW1lXFx9L2ksXG5cdFx0XHRzcGFjZXMgICAgICAgICAgOiAvXFxzKy9nLFxuXHRcdFx0bm9uV29yZCAgICAgICAgIDogL1xcVy9nLFxuXHRcdFx0Zm9ybUVsZW1lbnRzICAgIDogLyhpbnB1dHxzZWxlY3R8YnV0dG9ufHRleHRhcmVhKS9pLFxuXG5cdFx0XHQvLyAqKiogc29ydCBmdW5jdGlvbnMgKioqXG5cdFx0XHQvLyByZWdleCB1c2VkIGluIG5hdHVyYWwgc29ydFxuXHRcdFx0Ly8gY2h1bmsvdG9rZW5pemUgbnVtYmVycyAmIGxldHRlcnNcblx0XHRcdGNodW5rICA6IC8oXihbK1xcLV0/KD86XFxkKikoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPyk/JHxeMHhbMC05YS1mXSskfFxcZCspL2dpLFxuXHRcdFx0Ly8gcmVwbGFjZSBjaHVua3MgQCBlbmRzXG5cdFx0XHRjaHVua3MgOiAvKF5cXFxcMHxcXFxcMCQpLyxcblx0XHRcdGhleCAgICA6IC9eMHhbMC05YS1mXSskL2ksXG5cblx0XHRcdC8vICoqKiBmb3JtYXRGbG9hdCAqKipcblx0XHRcdGNvbW1hICAgICAgICAgICAgICAgIDogLywvZyxcblx0XHRcdGRpZ2l0Tm9uVVMgICAgICAgICAgIDogL1tcXHN8XFwuXS9nLFxuXHRcdFx0ZGlnaXROZWdhdGl2ZVRlc3QgICAgOiAvXlxccypcXChbLlxcZF0rXFwpLyxcblx0XHRcdGRpZ2l0TmVnYXRpdmVSZXBsYWNlIDogL15cXHMqXFwoKFsuXFxkXSspXFwpLyxcblxuXHRcdFx0Ly8gKioqIGlzRGlnaXQgKioqXG5cdFx0XHRkaWdpdFRlc3QgICAgOiAvXltcXC0rKF0/XFxkK1spXT8kLyxcblx0XHRcdGRpZ2l0UmVwbGFjZSA6IC9bLC4nXCJcXHNdL2dcblxuXHRcdH0sXG5cblx0XHQvLyBkaWdpdCBzb3J0LCB0ZXh0IGxvY2F0aW9uXG5cdFx0c3RyaW5nIDoge1xuXHRcdFx0bWF4ICAgICAgOiAxLFxuXHRcdFx0bWluICAgICAgOiAtMSxcblx0XHRcdGVtcHR5bWluIDogMSxcblx0XHRcdGVtcHR5bWF4IDogLTEsXG5cdFx0XHR6ZXJvICAgICA6IDAsXG5cdFx0XHRub25lICAgICA6IDAsXG5cdFx0XHQnbnVsbCcgICA6IDAsXG5cdFx0XHR0b3AgICAgICA6IHRydWUsXG5cdFx0XHRib3R0b20gICA6IGZhbHNlXG5cdFx0fSxcblxuXHRcdGtleUNvZGVzIDoge1xuXHRcdFx0ZW50ZXIgOiAxM1xuXHRcdH0sXG5cblx0XHQvLyBwbGFjZWhvbGRlciBkYXRlIHBhcnNlciBkYXRhIChnbG9iYWxpemUpXG5cdFx0ZGF0ZXMgOiB7fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgY2FuIGJlIGFwcGxpZWQgb24gdGFibGUuY29uZmlnIGluc3RhbmNlXG5cdFx0aW5zdGFuY2VNZXRob2RzIDoge30sXG5cblx0XHQvKlxuXHRcdOKWhOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWhFxuXHRcdOKWgOKWiOKWhCAgICDilojilojiloTiloQgICAgIOKWiOKWiCAgIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiFxuXHRcdCAgIOKWgOKWiOKWhCDilojilojiloDiloAgICAgIOKWiOKWiCAgIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWgOKWgOKWgFxuXHRcdOKWiOKWiOKWiOKWiOKWiOKWgCDilojilojilojilojilojiloggICDilojiloggICDiloDilojilojilojilojiloAg4paI4paIXG5cdFx0Ki9cblxuXHRcdHNldHVwIDogZnVuY3Rpb24oIHRhYmxlLCBjICkge1xuXHRcdFx0Ly8gaWYgbm8gdGhlYWQgb3IgdGJvZHksIG9yIHRhYmxlc29ydGVyIGlzIGFscmVhZHkgcHJlc2VudCwgcXVpdFxuXHRcdFx0aWYgKCAhdGFibGUgfHwgIXRhYmxlLnRIZWFkIHx8IHRhYmxlLnRCb2RpZXMubGVuZ3RoID09PSAwIHx8IHRhYmxlLmhhc0luaXRpYWxpemVkID09PSB0cnVlICkge1xuXHRcdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdFx0aWYgKCB0YWJsZS5oYXNJbml0aWFsaXplZCApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1N0b3BwaW5nIGluaXRpYWxpemF0aW9uLiBUYWJsZXNvcnRlciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkJyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnU3RvcHBpbmcgaW5pdGlhbGl6YXRpb24hIE5vIHRhYmxlLCB0aGVhZCBvciB0Ym9keScsIHRhYmxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRtcCA9ICcnLFxuXHRcdFx0XHQkdGFibGUgPSAkKCB0YWJsZSApLFxuXHRcdFx0XHRtZXRhID0gJC5tZXRhZGF0YTtcblx0XHRcdC8vIGluaXRpYWxpemF0aW9uIGZsYWdcblx0XHRcdHRhYmxlLmhhc0luaXRpYWxpemVkID0gZmFsc2U7XG5cdFx0XHQvLyB0YWJsZSBpcyBiZWluZyBwcm9jZXNzZWQgZmxhZ1xuXHRcdFx0dGFibGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHRcdC8vIG1ha2Ugc3VyZSB0byBzdG9yZSB0aGUgY29uZmlnIG9iamVjdFxuXHRcdFx0dGFibGUuY29uZmlnID0gYztcblx0XHRcdC8vIHNhdmUgdGhlIHNldHRpbmdzIHdoZXJlIHRoZXkgcmVhZFxuXHRcdFx0JC5kYXRhKCB0YWJsZSwgJ3RhYmxlc29ydGVyJywgYyApO1xuXHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRjb25zb2xlWyBjb25zb2xlLmdyb3VwID8gJ2dyb3VwJyA6ICdsb2cnIF0oICdJbml0aWFsaXppbmcgdGFibGVzb3J0ZXIgdicgKyB0cy52ZXJzaW9uICk7XG5cdFx0XHRcdCQuZGF0YSggdGFibGUsICdzdGFydG92ZXJhbGx0aW1lcicsIG5ldyBEYXRlKCkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZpbmcgdGhpcyBpbiB2ZXJzaW9uIDMgKG9ubHkgc3VwcG9ydHMgalF1ZXJ5IDEuNyspXG5cdFx0XHRjLnN1cHBvcnRzRGF0YU9iamVjdCA9ICggZnVuY3Rpb24oIHZlcnNpb24gKSB7XG5cdFx0XHRcdHZlcnNpb25bIDAgXSA9IHBhcnNlSW50KCB2ZXJzaW9uWyAwIF0sIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIHZlcnNpb25bIDAgXSA+IDEgKSB8fCAoIHZlcnNpb25bIDAgXSA9PT0gMSAmJiBwYXJzZUludCggdmVyc2lvblsgMSBdLCAxMCApID49IDQgKTtcblx0XHRcdH0pKCAkLmZuLmpxdWVyeS5zcGxpdCggJy4nICkgKTtcblx0XHRcdC8vIGVuc3VyZSBjYXNlIGluc2Vuc2l0aXZpdHlcblx0XHRcdGMuZW1wdHlUbyA9IGMuZW1wdHlUby50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Yy5zdHJpbmdUbyA9IGMuc3RyaW5nVG8udG9Mb3dlckNhc2UoKTtcblx0XHRcdGMubGFzdCA9IHsgc29ydExpc3QgOiBbXSwgY2xpY2tlZEluZGV4IDogLTEgfTtcblx0XHRcdC8vIGFkZCB0YWJsZSB0aGVtZSBjbGFzcyBvbmx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHkgb25lIHRoZXJlXG5cdFx0XHRpZiAoICEvdGFibGVzb3J0ZXJcXC0vLnRlc3QoICR0YWJsZS5hdHRyKCAnY2xhc3MnICkgKSApIHtcblx0XHRcdFx0dG1wID0gKCBjLnRoZW1lICE9PSAnJyA/ICcgdGFibGVzb3J0ZXItJyArIGMudGhlbWUgOiAnJyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBnaXZlIHRoZSB0YWJsZSBhIHVuaXF1ZSBpZCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluIG5hbWVzcGFjZSBiaW5kaW5nXG5cdFx0XHRpZiAoICFjLm5hbWVzcGFjZSApIHtcblx0XHRcdFx0Yy5uYW1lc3BhY2UgPSAnLnRhYmxlc29ydGVyJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoIDE2ICkuc2xpY2UoIDIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSBuYW1lc3BhY2Ugc3RhcnRzIHdpdGggYSBwZXJpb2QgJiBkb2Vzbid0IGhhdmUgd2VpcmQgY2hhcmFjdGVyc1xuXHRcdFx0XHRjLm5hbWVzcGFjZSA9ICcuJyArIGMubmFtZXNwYWNlLnJlcGxhY2UoIHRzLnJlZ2V4Lm5vbldvcmQsICcnICk7XG5cdFx0XHR9XG5cblx0XHRcdGMudGFibGUgPSB0YWJsZTtcblx0XHRcdGMuJHRhYmxlID0gJHRhYmxlXG5cdFx0XHRcdC8vIGFkZCBuYW1lc3BhY2UgdG8gdGFibGUgdG8gYWxsb3cgYmluZGluZ3Mgb24gZXh0cmEgZWxlbWVudHMgdG8gdGFyZ2V0XG5cdFx0XHRcdC8vIHRoZSBwYXJlbnQgdGFibGUgKGUuZy4gcGFyc2VyLWlucHV0LXNlbGVjdClcblx0XHRcdFx0LmFkZENsYXNzKCB0cy5jc3MudGFibGUgKyAnICcgKyBjLnRhYmxlQ2xhc3MgKyB0bXAgKyAnICcgKyBjLm5hbWVzcGFjZS5zbGljZSgxKSApXG5cdFx0XHRcdC5hdHRyKCAncm9sZScsICdncmlkJyApO1xuXHRcdFx0Yy4kaGVhZGVycyA9ICR0YWJsZS5maW5kKCBjLnNlbGVjdG9ySGVhZGVycyApO1xuXG5cdFx0XHRjLiR0YWJsZS5jaGlsZHJlbigpLmNoaWxkcmVuKCAndHInICkuYXR0ciggJ3JvbGUnLCAncm93JyApO1xuXHRcdFx0Yy4kdGJvZGllcyA9ICR0YWJsZS5jaGlsZHJlbiggJ3Rib2R5Om5vdCguJyArIGMuY3NzSW5mb0Jsb2NrICsgJyknICkuYXR0cih7XG5cdFx0XHRcdCdhcmlhLWxpdmUnIDogJ3BvbGl0ZScsXG5cdFx0XHRcdCdhcmlhLXJlbGV2YW50JyA6ICdhbGwnXG5cdFx0XHR9KTtcblx0XHRcdGlmICggYy4kdGFibGUuY2hpbGRyZW4oICdjYXB0aW9uJyApLmxlbmd0aCApIHtcblx0XHRcdFx0dG1wID0gYy4kdGFibGUuY2hpbGRyZW4oICdjYXB0aW9uJyApWyAwIF07XG5cdFx0XHRcdGlmICggIXRtcC5pZCApIHsgdG1wLmlkID0gYy5uYW1lc3BhY2Uuc2xpY2UoIDEgKSArICdjYXB0aW9uJzsgfVxuXHRcdFx0XHRjLiR0YWJsZS5hdHRyKCAnYXJpYS1sYWJlbGxlZGJ5JywgdG1wLmlkICk7XG5cdFx0XHR9XG5cdFx0XHRjLndpZGdldEluaXQgPSB7fTsgLy8ga2VlcCBhIGxpc3Qgb2YgaW5pdGlhbGl6ZWQgd2lkZ2V0c1xuXHRcdFx0Ly8gY2hhbmdlIHRleHRFeHRyYWN0aW9uIHZpYSBkYXRhLWF0dHJpYnV0ZVxuXHRcdFx0Yy50ZXh0RXh0cmFjdGlvbiA9IGMuJHRhYmxlLmF0dHIoICdkYXRhLXRleHQtZXh0cmFjdGlvbicgKSB8fCBjLnRleHRFeHRyYWN0aW9uIHx8ICdiYXNpYyc7XG5cdFx0XHQvLyBidWlsZCBoZWFkZXJzXG5cdFx0XHR0cy5idWlsZEhlYWRlcnMoIGMgKTtcblx0XHRcdC8vIGZpeGF0ZSBjb2x1bW5zIGlmIHRoZSB1c2VycyBzdXBwbGllcyB0aGUgZml4ZWRXaWR0aCBvcHRpb25cblx0XHRcdC8vIGRvIHRoaXMgYWZ0ZXIgdGhlbWUgaGFzIGJlZW4gYXBwbGllZFxuXHRcdFx0dHMuZml4Q29sdW1uV2lkdGgoIHRhYmxlICk7XG5cdFx0XHQvLyBhZGQgd2lkZ2V0cyBmcm9tIGNsYXNzIG5hbWVcblx0XHRcdHRzLmFkZFdpZGdldEZyb21DbGFzcyggdGFibGUgKTtcblx0XHRcdC8vIGFkZCB3aWRnZXQgb3B0aW9ucyBiZWZvcmUgcGFyc2luZyAoZS5nLiBncm91cGluZyB3aWRnZXQgaGFzIHBhcnNlciBzZXR0aW5ncylcblx0XHRcdHRzLmFwcGx5V2lkZ2V0T3B0aW9ucyggdGFibGUgKTtcblx0XHRcdC8vIHRyeSB0byBhdXRvIGRldGVjdCBjb2x1bW4gdHlwZSwgYW5kIHN0b3JlIGluIHRhYmxlcyBjb25maWdcblx0XHRcdHRzLnNldHVwUGFyc2VycyggYyApO1xuXHRcdFx0Ly8gc3RhcnQgdG90YWwgcm93IGNvdW50IGF0IHplcm9cblx0XHRcdGMudG90YWxSb3dzID0gMDtcblx0XHRcdC8vIG9ubHkgdmFsaWRhdGUgb3B0aW9ucyB3aGlsZSBkZWJ1Z2dpbmcuIFNlZSAjMTUyOFxuXHRcdFx0aWYgKGMuZGVidWcpIHtcblx0XHRcdFx0dHMudmFsaWRhdGVPcHRpb25zKCBjICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBidWlsZCB0aGUgY2FjaGUgZm9yIHRoZSB0Ym9keSBjZWxsc1xuXHRcdFx0Ly8gZGVsYXlJbml0IHdpbGwgZGVsYXkgYnVpbGRpbmcgdGhlIGNhY2hlIHVudGlsIHRoZSB1c2VyIHN0YXJ0cyBhIHNvcnRcblx0XHRcdGlmICggIWMuZGVsYXlJbml0ICkgeyB0cy5idWlsZENhY2hlKCBjICk7IH1cblx0XHRcdC8vIGJpbmQgYWxsIGhlYWRlciBldmVudHMgYW5kIG1ldGhvZHNcblx0XHRcdHRzLmJpbmRFdmVudHMoIHRhYmxlLCBjLiRoZWFkZXJzLCB0cnVlICk7XG5cdFx0XHR0cy5iaW5kTWV0aG9kcyggYyApO1xuXHRcdFx0Ly8gZ2V0IHNvcnQgbGlzdCBmcm9tIGpRdWVyeSBkYXRhIG9yIG1ldGFkYXRhXG5cdFx0XHQvLyBpbiBqUXVlcnkgPCAxLjQsIGFuIGVycm9yIG9jY3VycyB3aGVuIGNhbGxpbmcgJHRhYmxlLmRhdGEoKVxuXHRcdFx0aWYgKCBjLnN1cHBvcnRzRGF0YU9iamVjdCAmJiB0eXBlb2YgJHRhYmxlLmRhdGEoKS5zb3J0bGlzdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdGMuc29ydExpc3QgPSAkdGFibGUuZGF0YSgpLnNvcnRsaXN0O1xuXHRcdFx0fSBlbHNlIGlmICggbWV0YSAmJiAoICR0YWJsZS5tZXRhZGF0YSgpICYmICR0YWJsZS5tZXRhZGF0YSgpLnNvcnRsaXN0ICkgKSB7XG5cdFx0XHRcdGMuc29ydExpc3QgPSAkdGFibGUubWV0YWRhdGEoKS5zb3J0bGlzdDtcblx0XHRcdH1cblx0XHRcdC8vIGFwcGx5IHdpZGdldCBpbml0IGNvZGVcblx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgdHJ1ZSApO1xuXHRcdFx0Ly8gaWYgdXNlciBoYXMgc3VwcGxpZWQgYSBzb3J0IGxpc3QgdG8gY29uc3RydWN0b3Jcblx0XHRcdGlmICggYy5zb3J0TGlzdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHQvLyBzYXZlIHNvcnRMaXN0IGJlZm9yZSBhbnkgc29ydEFwcGVuZCBpcyBhZGRlZFxuXHRcdFx0XHRjLmxhc3Quc29ydExpc3QgPSBjLnNvcnRMaXN0O1xuXHRcdFx0XHR0cy5zb3J0T24oIGMsIGMuc29ydExpc3QsIHt9LCAhYy5pbml0V2lkZ2V0cyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHMuc2V0SGVhZGVyc0NzcyggYyApO1xuXHRcdFx0XHRpZiAoIGMuaW5pdFdpZGdldHMgKSB7XG5cdFx0XHRcdFx0Ly8gYXBwbHkgd2lkZ2V0IGZvcm1hdFxuXHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzaG93IHByb2Nlc3Nlc2luZyBpY29uXG5cdFx0XHRpZiAoIGMuc2hvd1Byb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdCR0YWJsZVxuXHRcdFx0XHQudW5iaW5kKCAnc29ydEJlZ2luJyArIGMubmFtZXNwYWNlICsgJyBzb3J0RW5kJyArIGMubmFtZXNwYWNlIClcblx0XHRcdFx0LmJpbmQoICdzb3J0QmVnaW4nICsgYy5uYW1lc3BhY2UgKyAnIHNvcnRFbmQnICsgYy5uYW1lc3BhY2UsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCggYy50aW1lclByb2Nlc3NpbmcgKTtcblx0XHRcdFx0XHR0cy5pc1Byb2Nlc3NpbmcoIHRhYmxlICk7XG5cdFx0XHRcdFx0aWYgKCBlLnR5cGUgPT09ICdzb3J0QmVnaW4nICkge1xuXHRcdFx0XHRcdFx0Yy50aW1lclByb2Nlc3NpbmcgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dHMuaXNQcm9jZXNzaW5nKCB0YWJsZSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fSwgNTAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5pdGlhbGl6ZWRcblx0XHRcdHRhYmxlLmhhc0luaXRpYWxpemVkID0gdHJ1ZTtcblx0XHRcdHRhYmxlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggJ092ZXJhbGwgaW5pdGlhbGl6YXRpb24gdGltZTonICsgdHMuYmVuY2htYXJrKCAkLmRhdGEoIHRhYmxlLCAnc3RhcnRvdmVyYWxsdGltZXInICkgKSApO1xuXHRcdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgJiYgY29uc29sZS5ncm91cEVuZCApIHsgY29uc29sZS5ncm91cEVuZCgpOyB9XG5cdFx0XHR9XG5cdFx0XHQkdGFibGUudHJpZ2dlckhhbmRsZXIoICd0YWJsZXNvcnRlci1pbml0aWFsaXplZCcsIHRhYmxlICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBjLmluaXRpYWxpemVkID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjLmluaXRpYWxpemVkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiaW5kTWV0aG9kcyA6IGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyICR0YWJsZSA9IGMuJHRhYmxlLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBjLm5hbWVzcGFjZSxcblx0XHRcdFx0ZXZlbnRzID0gKCAnc29ydFJlc2V0IHVwZGF0ZSB1cGRhdGVSb3dzIHVwZGF0ZUFsbCB1cGRhdGVIZWFkZXJzIGFkZFJvd3MgdXBkYXRlQ2VsbCB1cGRhdGVDb21wbGV0ZSAnICtcblx0XHRcdFx0XHQnc29ydG9uIGFwcGVuZENhY2hlIHVwZGF0ZUNhY2hlIGFwcGx5V2lkZ2V0SWQgYXBwbHlXaWRnZXRzIHJlZnJlc2hXaWRnZXRzIGRlc3Ryb3kgbW91c2V1cCAnICtcblx0XHRcdFx0XHQnbW91c2VsZWF2ZSAnICkuc3BsaXQoICcgJyApXG5cdFx0XHRcdFx0LmpvaW4oIG5hbWVzcGFjZSArICcgJyApO1xuXHRcdFx0Ly8gYXBwbHkgZWFzeSBtZXRob2RzIHRoYXQgdHJpZ2dlciBib3VuZCBldmVudHNcblx0XHRcdCR0YWJsZVxuXHRcdFx0LnVuYmluZCggZXZlbnRzLnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnICkgKVxuXHRcdFx0LmJpbmQoICdzb3J0UmVzZXQnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdC8vIHVzaW5nIHRoaXMuY29uZmlnIHRvIGVuc3VyZSBmdW5jdGlvbnMgYXJlIGdldHRpbmcgYSBub24tY2FjaGVkIHZlcnNpb24gb2YgdGhlIGNvbmZpZ1xuXHRcdFx0XHR0cy5zb3J0UmVzZXQoIHRoaXMuY29uZmlnLCBmdW5jdGlvbiggdGFibGUgKSB7XG5cdFx0XHRcdFx0aWYgKHRhYmxlLmlzQXBwbHlpbmdXaWRnZXRzKSB7XG5cdFx0XHRcdFx0XHQvLyBtdWx0aXBsZSB0cmlnZ2VycyBpbiBhIHJvdy4uLiBmaWx0ZXJSZXNldCwgdGhlbiBzb3J0UmVzZXQgLSBzZWUgIzEzNjFcblx0XHRcdFx0XHRcdC8vIHdhaXQgdG8gdXBkYXRlIHdpZGdldHNcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0cy5hcHBseVdpZGdldCggdGFibGUsICcnLCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0fSwgMTAwICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgJycsIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3VwZGF0ZUFsbCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCByZXNvcnQsIGNhbGxiYWNrICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy51cGRhdGVBbGwoIHRoaXMuY29uZmlnLCByZXNvcnQsIGNhbGxiYWNrICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICd1cGRhdGUnICsgbmFtZXNwYWNlICsgJyB1cGRhdGVSb3dzJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnVwZGF0ZSggdGhpcy5jb25maWcsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3VwZGF0ZUhlYWRlcnMnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnVwZGF0ZUhlYWRlcnMoIHRoaXMuY29uZmlnLCBjYWxsYmFjayApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAndXBkYXRlQ2VsbCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBjZWxsLCByZXNvcnQsIGNhbGxiYWNrICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy51cGRhdGVDZWxsKCB0aGlzLmNvbmZpZywgY2VsbCwgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAnYWRkUm93cycgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCAkcm93LCByZXNvcnQsIGNhbGxiYWNrICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy5hZGRSb3dzKCB0aGlzLmNvbmZpZywgJHJvdywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAndXBkYXRlQ29tcGxldGUnICsgbmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdzb3J0b24nICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgbGlzdCwgY2FsbGJhY2ssIGluaXQgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnNvcnRPbiggdGhpcy5jb25maWcsIGxpc3QsIGNhbGxiYWNrLCBpbml0ICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdhcHBlbmRDYWNoZScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBjYWxsYmFjaywgaW5pdCApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMuYXBwZW5kQ2FjaGUoIHRoaXMuY29uZmlnLCBpbml0ICk7XG5cdFx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyAkdGJvZGllcyB2YXJpYWJsZSBpcyB1c2VkIGJ5IHRoZSB0Ym9keSBzb3J0aW5nIHdpZGdldFxuXHRcdFx0LmJpbmQoICd1cGRhdGVDYWNoZScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBjYWxsYmFjaywgJHRib2RpZXMgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnVwZGF0ZUNhY2hlKCB0aGlzLmNvbmZpZywgY2FsbGJhY2ssICR0Ym9kaWVzICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdhcHBseVdpZGdldElkJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGlkICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy5hcHBseVdpZGdldElkKCB0aGlzLCBpZCApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAnYXBwbHlXaWRnZXRzJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGNhbGxiYWNrICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHQvLyBhcHBseSB3aWRnZXRzIChmYWxzZSA9IG5vdCBpbml0aWFsaXppbmcpXG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0aGlzLCBmYWxzZSwgY2FsbGJhY2sgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3JlZnJlc2hXaWRnZXRzJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGFsbCwgZG9udGFwcGx5ICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy5yZWZyZXNoV2lkZ2V0cyggdGhpcywgYWxsLCBkb250YXBwbHkgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3JlbW92ZVdpZGdldCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBuYW1lLCByZWZyZXNoaW5nICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy5yZW1vdmVXaWRnZXQoIHRoaXMsIG5hbWUsIHJlZnJlc2hpbmcgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ2Rlc3Ryb3knICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgcmVtb3ZlQ2xhc3NlcywgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLmRlc3Ryb3koIHRoaXMsIHJlbW92ZUNsYXNzZXMsIGNhbGxiYWNrICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdyZXNldFRvTG9hZFN0YXRlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgd2lkZ2V0c1xuXHRcdFx0XHR0cy5yZW1vdmVXaWRnZXQoIHRoaXMsIHRydWUsIGZhbHNlICk7XG5cdFx0XHRcdHZhciB0bXAgPSAkLmV4dGVuZCggdHJ1ZSwge30sIGMub3JpZ2luYWxTZXR0aW5ncyApO1xuXHRcdFx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIHNldHRpbmdzOyB0aGlzIGNsZWFycyBvdXQgY3VycmVudCBzZXR0aW5ncywgYnV0IGRvZXMgbm90IGNsZWFyXG5cdFx0XHRcdC8vIHZhbHVlcyBzYXZlZCB0byBzdG9yYWdlLlxuXHRcdFx0XHRjID0gJC5leHRlbmQoIHRydWUsIHt9LCB0cy5kZWZhdWx0cywgdG1wICk7XG5cdFx0XHRcdGMub3JpZ2luYWxTZXR0aW5ncyA9IHRtcDtcblx0XHRcdFx0dGhpcy5oYXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0XHQvLyBzZXR1cCB0aGUgZW50aXJlIHRhYmxlIGFnYWluXG5cdFx0XHRcdHRzLnNldHVwKCB0aGlzLCBjICk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0YmluZEV2ZW50cyA6IGZ1bmN0aW9uKCB0YWJsZSwgJGhlYWRlcnMsIGNvcmUgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTtcblx0XHRcdHZhciB0bXAsXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlLFxuXHRcdFx0XHRkb3duVGFyZ2V0ID0gbnVsbDtcblx0XHRcdGlmICggY29yZSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0JGhlYWRlcnMuYWRkQ2xhc3MoIG5hbWVzcGFjZS5zbGljZSggMSApICsgJ19leHRyYV9oZWFkZXJzJyApO1xuXHRcdFx0XHR0bXAgPSB0cy5nZXRDbG9zZXN0KCAkaGVhZGVycywgJ3RhYmxlJyApO1xuXHRcdFx0XHRpZiAoIHRtcC5sZW5ndGggJiYgdG1wWyAwIF0ubm9kZU5hbWUgPT09ICdUQUJMRScgJiYgdG1wWyAwIF0gIT09IHRhYmxlICkge1xuXHRcdFx0XHRcdCQoIHRtcFsgMCBdICkuYWRkQ2xhc3MoIG5hbWVzcGFjZS5zbGljZSggMSApICsgJ19leHRyYV90YWJsZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gKCBjLnBvaW50ZXJEb3duICsgJyAnICsgYy5wb2ludGVyVXAgKyAnICcgKyBjLnBvaW50ZXJDbGljayArICcgc29ydCBrZXl1cCAnIClcblx0XHRcdFx0LnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnIClcblx0XHRcdFx0LnNwbGl0KCAnICcgKVxuXHRcdFx0XHQuam9pbiggbmFtZXNwYWNlICsgJyAnICk7XG5cdFx0XHQvLyBhcHBseSBldmVudCBoYW5kbGluZyB0byBoZWFkZXJzIGFuZC9vciBhZGRpdGlvbmFsIGhlYWRlcnMgKHN0aWNreWhlYWRlcnMsIHNjcm9sbGVyLCBldGMpXG5cdFx0XHQkaGVhZGVyc1xuXHRcdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzEyODQ5L2pxdWVyeS1maW5kLXNlbGY7XG5cdFx0XHQuZmluZCggYy5zZWxlY3RvclNvcnQgKVxuXHRcdFx0LmFkZCggJGhlYWRlcnMuZmlsdGVyKCBjLnNlbGVjdG9yU29ydCApIClcblx0XHRcdC51bmJpbmQoIHRtcCApXG5cdFx0XHQuYmluZCggdG1wLCBmdW5jdGlvbiggZSwgZXh0ZXJuYWwgKSB7XG5cdFx0XHRcdHZhciAkY2VsbCwgY2VsbCwgdGVtcCxcblx0XHRcdFx0XHQkdGFyZ2V0ID0gJCggZS50YXJnZXQgKSxcblx0XHRcdFx0XHQvLyB3cmFwIGV2ZW50IHR5cGUgaW4gc3BhY2VzLCBzbyB0aGUgbWF0Y2ggZG9lc24ndCB0cmlnZ2VyIG9uIGlubmVyIHdvcmRzXG5cdFx0XHRcdFx0dHlwZSA9ICcgJyArIGUudHlwZSArICcgJztcblx0XHRcdFx0Ly8gb25seSByZWNvZ25pemUgbGVmdCBjbGlja3Ncblx0XHRcdFx0aWYgKCAoICggZS53aGljaCB8fCBlLmJ1dHRvbiApICE9PSAxICYmICF0eXBlLm1hdGNoKCAnICcgKyBjLnBvaW50ZXJDbGljayArICcgfCBzb3J0IHwga2V5dXAgJyApICkgfHxcblx0XHRcdFx0XHQvLyBhbGxvdyBwcmVzc2luZyBlbnRlclxuXHRcdFx0XHRcdCggdHlwZSA9PT0gJyBrZXl1cCAnICYmIGUud2hpY2ggIT09IHRzLmtleUNvZGVzLmVudGVyICkgfHxcblx0XHRcdFx0XHQvLyBhbGxvdyB0cmlnZ2VyaW5nIGEgY2xpY2sgZXZlbnQgKGUud2hpY2ggaXMgdW5kZWZpbmVkKSAmIGlnbm9yZSBwaHlzaWNhbCBjbGlja3Ncblx0XHRcdFx0XHQoIHR5cGUubWF0Y2goICcgJyArIGMucG9pbnRlckNsaWNrICsgJyAnICkgJiYgdHlwZW9mIGUud2hpY2ggIT09ICd1bmRlZmluZWQnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlnbm9yZSBtb3VzZXVwIGlmIG1vdXNlZG93biB3YXNuJ3Qgb24gdGhlIHNhbWUgdGFyZ2V0XG5cdFx0XHRcdGlmICggdHlwZS5tYXRjaCggJyAnICsgYy5wb2ludGVyVXAgKyAnICcgKSAmJiBkb3duVGFyZ2V0ICE9PSBlLnRhcmdldCAmJiBleHRlcm5hbCAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2V0IHRhcmdldCBvbiBtb3VzZWRvd25cblx0XHRcdFx0aWYgKCB0eXBlLm1hdGNoKCAnICcgKyBjLnBvaW50ZXJEb3duICsgJyAnICkgKSB7XG5cdFx0XHRcdFx0ZG93blRhcmdldCA9IGUudGFyZ2V0O1xuXHRcdFx0XHRcdC8vIHByZXZlbnREZWZhdWx0IG5lZWRlZCBvciBqUXVlcnkgdjEuMy4yIGFuZCBvbGRlciB0aHJvd3MgYW5cblx0XHRcdFx0XHQvLyBcIlVuY2F1Z2h0IFR5cGVFcnJvcjogaGFuZGxlci5hcHBseSBpcyBub3QgYSBmdW5jdGlvblwiIGVycm9yXG5cdFx0XHRcdFx0dGVtcCA9ICR0YXJnZXQuanF1ZXJ5LnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRpZiAoIHRlbXBbIDAgXSA9PT0gJzEnICYmIHRlbXBbIDEgXSA8IDQgKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb3duVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0JGNlbGwgPSB0cy5nZXRDbG9zZXN0KCAkKCB0aGlzICksICcuJyArIHRzLmNzcy5oZWFkZXIgKTtcblx0XHRcdFx0Ly8gcHJldmVudCBzb3J0IGJlaW5nIHRyaWdnZXJlZCBvbiBmb3JtIGVsZW1lbnRzXG5cdFx0XHRcdGlmICggdHMucmVnZXguZm9ybUVsZW1lbnRzLnRlc3QoIGUudGFyZ2V0Lm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHQvLyBub3NvcnQgY2xhc3MgbmFtZSwgb3IgZWxlbWVudHMgd2l0aGluIGEgbm9zb3J0IGNvbnRhaW5lclxuXHRcdFx0XHRcdCR0YXJnZXQuaGFzQ2xhc3MoIGMuY3NzTm9Tb3J0ICkgfHwgJHRhcmdldC5wYXJlbnRzKCAnLicgKyBjLmNzc05vU29ydCApLmxlbmd0aCA+IDAgfHxcblx0XHRcdFx0XHQvLyBkaXNhYmxlZCBjZWxsIGRpcmVjdGx5IGNsaWNrZWRcblx0XHRcdFx0XHQkY2VsbC5oYXNDbGFzcyggJ3NvcnRlci1mYWxzZScgKSB8fFxuXHRcdFx0XHRcdC8vIGVsZW1lbnRzIHdpdGhpbiBhIGJ1dHRvblxuXHRcdFx0XHRcdCR0YXJnZXQucGFyZW50cyggJ2J1dHRvbicgKS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdHJldHVybiAhYy5jYW5jZWxTZWxlY3Rpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjLmRlbGF5SW5pdCAmJiB0cy5pc0VtcHR5T2JqZWN0KCBjLmNhY2hlICkgKSB7XG5cdFx0XHRcdFx0dHMuYnVpbGRDYWNoZSggYyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVzZSBjb2x1bW4gaW5kZXggZnJvbSBkYXRhLWF0dHJpYnV0ZSBvciBpbmRleCBvZiBjdXJyZW50IHJvdzsgZml4ZXMgIzExMTZcblx0XHRcdFx0Yy5sYXN0LmNsaWNrZWRJbmRleCA9ICRjZWxsLmF0dHIoICdkYXRhLWNvbHVtbicgKSB8fCAkY2VsbC5pbmRleCgpO1xuXHRcdFx0XHRjZWxsID0gYy4kaGVhZGVySW5kZXhlZFsgYy5sYXN0LmNsaWNrZWRJbmRleCBdWzBdO1xuXHRcdFx0XHRpZiAoIGNlbGwgJiYgIWNlbGwuc29ydERpc2FibGVkICkge1xuXHRcdFx0XHRcdHRzLmluaXRTb3J0KCBjLCBjZWxsLCBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKCBjLmNhbmNlbFNlbGVjdGlvbiApIHtcblx0XHRcdFx0Ly8gY2FuY2VsIHNlbGVjdGlvblxuXHRcdFx0XHQkaGVhZGVyc1xuXHRcdFx0XHRcdC5hdHRyKCAndW5zZWxlY3RhYmxlJywgJ29uJyApXG5cdFx0XHRcdFx0LmJpbmQoICdzZWxlY3RzdGFydCcsIGZhbHNlIClcblx0XHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRcdCd1c2VyLXNlbGVjdCcgOiAnbm9uZScsXG5cdFx0XHRcdFx0XHQnTW96VXNlclNlbGVjdCcgOiAnbm9uZScgLy8gbm90IG5lZWRlZCBmb3IgalF1ZXJ5IDEuOCtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YnVpbGRIZWFkZXJzIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgJHRlbXAsIGljb24sIHRpbWVyLCBpbmR4O1xuXHRcdFx0Yy5oZWFkZXJMaXN0ID0gW107XG5cdFx0XHRjLmhlYWRlckNvbnRlbnQgPSBbXTtcblx0XHRcdGMuc29ydFZhcnMgPSBbXTtcblx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0dGltZXIgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hpbGRyZW4gdHIgaW4gdGZvb3QgLSBzZWUgaXNzdWUgIzE5NiAmICM1NDdcblx0XHRcdC8vIGRvbid0IHBhc3MgdGFibGUuY29uZmlnIHRvIGNvbXB1dGVDb2x1bW5JbmRleCBoZXJlIC0gd2lkZ2V0cyAobWF0aCkgcGFzcyBpdCB0byBcInF1aWNrbHlcIiBpbmRleCB0Ym9keSBjZWxsc1xuXHRcdFx0Yy5jb2x1bW5zID0gdHMuY29tcHV0ZUNvbHVtbkluZGV4KCBjLiR0YWJsZS5jaGlsZHJlbiggJ3RoZWFkLCB0Zm9vdCcgKS5jaGlsZHJlbiggJ3RyJyApICk7XG5cdFx0XHQvLyBhZGQgaWNvbiBpZiBjc3NJY29uIG9wdGlvbiBleGlzdHNcblx0XHRcdGljb24gPSBjLmNzc0ljb24gP1xuXHRcdFx0XHQnPGkgY2xhc3M9XCInICsgKCBjLmNzc0ljb24gPT09IHRzLmNzcy5pY29uID8gdHMuY3NzLmljb24gOiBjLmNzc0ljb24gKyAnICcgKyB0cy5jc3MuaWNvbiApICsgJ1wiPjwvaT4nIDpcblx0XHRcdFx0Jyc7XG5cdFx0XHQvLyByZWRlZmluZSBjLiRoZWFkZXJzIGhlcmUgaW4gY2FzZSBvZiBhbiB1cGRhdGVBbGwgdGhhdCByZXBsYWNlcyBvciBhZGRzIGFuIGVudGlyZSBoZWFkZXIgY2VsbCAtIHNlZSAjNjgzXG5cdFx0XHRjLiRoZWFkZXJzID0gJCggJC5tYXAoIGMuJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JIZWFkZXJzICksIGZ1bmN0aW9uKCBlbGVtLCBpbmRleCApIHtcblx0XHRcdFx0dmFyIGNvbmZpZ0hlYWRlcnMsIGhlYWRlciwgY29sdW1uLCB0ZW1wbGF0ZSwgdG1wLFxuXHRcdFx0XHRcdCRlbGVtID0gJCggZWxlbSApO1xuXHRcdFx0XHQvLyBpZ25vcmUgY2VsbCAoZG9uJ3QgYWRkIGl0IHRvIGMuJGhlYWRlcnMpIGlmIHJvdyBoYXMgaWdub3JlUm93IGNsYXNzXG5cdFx0XHRcdGlmICggdHMuZ2V0Q2xvc2VzdCggJGVsZW0sICd0cicgKS5oYXNDbGFzcyggYy5jc3NJZ25vcmVSb3cgKSApIHsgcmV0dXJuOyB9XG5cdFx0XHRcdC8vIHRyYW5zZmVyIGRhdGEtY29sdW1uIHRvIGVsZW1lbnQgaWYgbm90IHRoL3RkIC0gIzE0NTlcblx0XHRcdFx0aWYgKCAhLyh0aHx0ZCkvaS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgKSB7XG5cdFx0XHRcdFx0dG1wID0gdHMuZ2V0Q2xvc2VzdCggJGVsZW0sICd0aCwgdGQnICk7XG5cdFx0XHRcdFx0JGVsZW0uYXR0ciggJ2RhdGEtY29sdW1uJywgdG1wLmF0dHIoICdkYXRhLWNvbHVtbicgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0byBnZXQgaGVhZGVyIGNlbGwgJiBub3QgY29sdW1uIGluZGV4ZWQgY2VsbFxuXHRcdFx0XHRjb25maWdIZWFkZXJzID0gdHMuZ2V0Q29sdW1uRGF0YSggYy50YWJsZSwgYy5oZWFkZXJzLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHQvLyBzYXZlIG9yaWdpbmFsIGhlYWRlciBjb250ZW50XG5cdFx0XHRcdGMuaGVhZGVyQ29udGVudFsgaW5kZXggXSA9ICRlbGVtLmh0bWwoKTtcblx0XHRcdFx0Ly8gaWYgaGVhZGVyVGVtcGxhdGUgaXMgZW1wdHksIGRvbid0IHJlZm9ybWF0IHRoZSBoZWFkZXIgY2VsbFxuXHRcdFx0XHRpZiAoIGMuaGVhZGVyVGVtcGxhdGUgIT09ICcnICYmICEkZWxlbS5maW5kKCAnLicgKyB0cy5jc3MuaGVhZGVySW4gKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHVwIGhlYWRlciB0ZW1wbGF0ZVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gYy5oZWFkZXJUZW1wbGF0ZVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoIHRzLnJlZ2V4LnRlbXBsYXRlQ29udGVudCwgJGVsZW0uaHRtbCgpIClcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCB0cy5yZWdleC50ZW1wbGF0ZUljb24sICRlbGVtLmZpbmQoICcuJyArIHRzLmNzcy5pY29uICkubGVuZ3RoID8gJycgOiBpY29uICk7XG5cdFx0XHRcdFx0aWYgKCBjLm9uUmVuZGVyVGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXIgPSBjLm9uUmVuZGVyVGVtcGxhdGUuYXBwbHkoICRlbGVtLCBbIGluZGV4LCB0ZW1wbGF0ZSBdICk7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IGNoYW5nZSB0IGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0aWYgKCBoZWFkZXIgJiYgdHlwZW9mIGhlYWRlciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlID0gaGVhZGVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkZWxlbS5odG1sKCAnPGRpdiBjbGFzcz1cIicgKyB0cy5jc3MuaGVhZGVySW4gKyAnXCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgKTsgLy8gZmFzdGVyIHRoYW4gd3JhcElubmVyXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjLm9uUmVuZGVySGVhZGVyICkge1xuXHRcdFx0XHRcdGMub25SZW5kZXJIZWFkZXIuYXBwbHkoICRlbGVtLCBbIGluZGV4LCBjLCBjLiR0YWJsZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sdW1uID0gcGFyc2VJbnQoICRlbGVtLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKTtcblx0XHRcdFx0ZWxlbS5jb2x1bW4gPSBjb2x1bW47XG5cdFx0XHRcdHRtcCA9IHRzLmdldE9yZGVyKCB0cy5nZXREYXRhKCAkZWxlbSwgY29uZmlnSGVhZGVycywgJ3NvcnRJbml0aWFsT3JkZXInICkgfHwgYy5zb3J0SW5pdGlhbE9yZGVyICk7XG5cdFx0XHRcdC8vIHRoaXMgbWF5IGdldCB1cGRhdGVkIG51bWVyb3VzIHRpbWVzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSByb3dzXG5cdFx0XHRcdGMuc29ydFZhcnNbIGNvbHVtbiBdID0ge1xuXHRcdFx0XHRcdGNvdW50IDogLTEsIC8vIHNldCB0byAtMSBiZWNhdXNlIGNsaWNraW5nIG9uIHRoZSBoZWFkZXIgYXV0b21hdGljYWxseSBhZGRzIG9uZVxuXHRcdFx0XHRcdG9yZGVyIDogdG1wID9cblx0XHRcdFx0XHRcdCggYy5zb3J0UmVzZXQgPyBbIDEsIDAsIDIgXSA6IFsgMSwgMCBdICkgOiAvLyBkZXNjLCBhc2MsIHVuc29ydGVkXG5cdFx0XHRcdFx0XHQoIGMuc29ydFJlc2V0ID8gWyAwLCAxLCAyIF0gOiBbIDAsIDEgXSApLCAgLy8gYXNjLCBkZXNjLCB1bnNvcnRlZFxuXHRcdFx0XHRcdGxvY2tlZE9yZGVyIDogZmFsc2UsXG5cdFx0XHRcdFx0c29ydGVkQnkgOiAnJ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0bXAgPSB0cy5nZXREYXRhKCAkZWxlbSwgY29uZmlnSGVhZGVycywgJ2xvY2tlZE9yZGVyJyApIHx8IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0bXAgIT09ICd1bmRlZmluZWQnICYmIHRtcCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Yy5zb3J0VmFyc1sgY29sdW1uIF0ubG9ja2VkT3JkZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbHVtbiBdLm9yZGVyID0gdHMuZ2V0T3JkZXIoIHRtcCApID8gWyAxLCAxIF0gOiBbIDAsIDAgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZGQgY2VsbCB0byBoZWFkZXJMaXN0XG5cdFx0XHRcdGMuaGVhZGVyTGlzdFsgaW5kZXggXSA9IGVsZW07XG5cdFx0XHRcdCRlbGVtLmFkZENsYXNzKCB0cy5jc3MuaGVhZGVyICsgJyAnICsgYy5jc3NIZWFkZXIgKTtcblx0XHRcdFx0Ly8gYWRkIHRvIHBhcmVudCBpbiBjYXNlIHRoZXJlIGFyZSBtdWx0aXBsZSByb3dzXG5cdFx0XHRcdHRzLmdldENsb3Nlc3QoICRlbGVtLCAndHInIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHRzLmNzcy5oZWFkZXJSb3cgKyAnICcgKyBjLmNzc0hlYWRlclJvdyApXG5cdFx0XHRcdFx0LmF0dHIoICdyb2xlJywgJ3JvdycgKTtcblx0XHRcdFx0Ly8gYWxsb3cga2V5Ym9hcmQgY3Vyc29yIHRvIGZvY3VzIG9uIGVsZW1lbnRcblx0XHRcdFx0aWYgKCBjLnRhYkluZGV4ICkge1xuXHRcdFx0XHRcdCRlbGVtLmF0dHIoICd0YWJpbmRleCcsIDAgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0pICk7XG5cdFx0XHQvLyBjYWNoZSBoZWFkZXJzIHBlciBjb2x1bW5cblx0XHRcdGMuJGhlYWRlckluZGV4ZWQgPSBbXTtcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgYy5jb2x1bW5zOyBpbmR4KysgKSB7XG5cdFx0XHRcdC8vIGNvbHNwYW4gaW4gaGVhZGVyIG1ha2luZyBhIGNvbHVtbiB1bmRlZmluZWRcblx0XHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjLnNvcnRWYXJzWyBpbmR4IF0gKSApIHtcblx0XHRcdFx0XHRjLnNvcnRWYXJzWyBpbmR4IF0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBVc2UgYy4kaGVhZGVycy5wYXJlbnQoKSBpbiBjYXNlIHNlbGVjdG9ySGVhZGVycyBkb2Vzbid0IHBvaW50IHRvIHRoZSB0aC90ZFxuXHRcdFx0XHQkdGVtcCA9IGMuJGhlYWRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGluZHggKyAnXCJdJyApO1xuXHRcdFx0XHQvLyB0YXJnZXQgc29ydGFibGUgY29sdW1uIGNlbGxzLCB1bmxlc3MgdGhlcmUgYXJlIG5vbmUsIHRoZW4gdXNlIG5vbi1zb3J0YWJsZSBjZWxsc1xuXHRcdFx0XHQvLyAubGFzdCgpIGFkZGVkIGluIGpRdWVyeSAxLjQ7IHVzZSAuZmlsdGVyKCc6bGFzdCcpIHRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBqUXVlcnkgdjEuMi42XG5cdFx0XHRcdGMuJGhlYWRlckluZGV4ZWRbIGluZHggXSA9ICR0ZW1wLmxlbmd0aCA/XG5cdFx0XHRcdFx0JHRlbXAubm90KCAnLnNvcnRlci1mYWxzZScgKS5sZW5ndGggP1xuXHRcdFx0XHRcdFx0JHRlbXAubm90KCAnLnNvcnRlci1mYWxzZScgKS5maWx0ZXIoICc6bGFzdCcgKSA6XG5cdFx0XHRcdFx0XHQkdGVtcC5maWx0ZXIoICc6bGFzdCcgKSA6XG5cdFx0XHRcdFx0JCgpO1xuXHRcdFx0fVxuXHRcdFx0Yy4kdGFibGUuZmluZCggYy5zZWxlY3RvckhlYWRlcnMgKS5hdHRyKHtcblx0XHRcdFx0c2NvcGU6ICdjb2wnLFxuXHRcdFx0XHRyb2xlIDogJ2NvbHVtbmhlYWRlcidcblx0XHRcdH0pO1xuXHRcdFx0Ly8gZW5hYmxlL2Rpc2FibGUgc29ydGluZ1xuXHRcdFx0dHMudXBkYXRlSGVhZGVyKCBjICk7XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnQnVpbHQgaGVhZGVyczonICsgdHMuYmVuY2htYXJrKCB0aW1lciApICk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCBjLiRoZWFkZXJzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFVzZSBpdCB0byBhZGQgYSBzZXQgb2YgbWV0aG9kcyB0byB0YWJsZS5jb25maWcgd2hpY2ggd2lsbCBiZSBhdmFpbGFibGUgZm9yIGFsbCB0YWJsZXMuXG5cdFx0Ly8gVGhpcyBzaG91bGQgYmUgZG9uZSBiZWZvcmUgdGFibGUgaW5pdGlhbGl6YXRpb25cblx0XHRhZGRJbnN0YW5jZU1ldGhvZHMgOiBmdW5jdGlvbiggbWV0aG9kcyApIHtcblx0XHRcdCQuZXh0ZW5kKCB0cy5pbnN0YW5jZU1ldGhvZHMsIG1ldGhvZHMgKTtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHTilojilojilojilojilojiloQg4paE4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojilogg4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojilohcblx0XHTilojilojiloTiloTilojilogg4paI4paI4paE4paE4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiCDiloDilojiloQgICAg4paI4paI4paE4paEICAg4paI4paI4paE4paE4paI4paIIOKWgOKWiOKWhFxuXHRcdOKWiOKWiOKWgOKWgOKWgCAg4paI4paI4paA4paA4paI4paIIOKWiOKWiOKWgOKWiOKWiCAgICAg4paA4paI4paEIOKWiOKWiOKWgOKWgCAgIOKWiOKWiOKWgOKWiOKWiCAgICAg4paA4paI4paEXG5cdFx04paI4paIICAgICDilojiloggIOKWiOKWiCDilojiloggIOKWiOKWiCDilojilojilojilojilojiloAg4paI4paI4paI4paI4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWgFxuXHRcdCovXG5cdFx0c2V0dXBQYXJzZXJzIDogZnVuY3Rpb24oIGMsICR0Ym9kaWVzICkge1xuXHRcdFx0dmFyIHJvd3MsIGxpc3QsIHNwYW4sIG1heCwgY29sSW5kZXgsIGluZHgsIGhlYWRlciwgY29uZmlnSGVhZGVycyxcblx0XHRcdFx0bm9QYXJzZXIsIHBhcnNlciwgZXh0cmFjdG9yLCB0aW1lLCB0Ym9keSwgbGVuLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdHRib2R5SW5kZXggPSAwLFxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdjb3JlJyksXG5cdFx0XHRcdGRlYnVnT3V0cHV0ID0ge307XG5cdFx0XHQvLyB1cGRhdGUgdGFibGUgYm9kaWVzIGluIGNhc2Ugd2Ugc3RhcnQgd2l0aCBhbiBlbXB0eSB0YWJsZVxuXHRcdFx0Yy4kdGJvZGllcyA9IGMuJHRhYmxlLmNoaWxkcmVuKCAndGJvZHk6bm90KC4nICsgYy5jc3NJbmZvQmxvY2sgKyAnKScgKTtcblx0XHRcdHRib2R5ID0gdHlwZW9mICR0Ym9kaWVzID09PSAndW5kZWZpbmVkJyA/IGMuJHRib2RpZXMgOiAkdGJvZGllcztcblx0XHRcdGxlbiA9IHRib2R5Lmxlbmd0aDtcblx0XHRcdGlmICggbGVuID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gZGVidWcgPyBjb25zb2xlLndhcm4oICdXYXJuaW5nOiAqRW1wdHkgdGFibGUhKiBOb3QgYnVpbGRpbmcgYSBwYXJzZXIgY2FjaGUnICkgOiAnJztcblx0XHRcdH0gZWxzZSBpZiAoIGRlYnVnICkge1xuXHRcdFx0XHR0aW1lID0gbmV3IERhdGUoKTtcblx0XHRcdFx0Y29uc29sZVsgY29uc29sZS5ncm91cCA/ICdncm91cCcgOiAnbG9nJyBdKCAnRGV0ZWN0aW5nIHBhcnNlcnMgZm9yIGVhY2ggY29sdW1uJyApO1xuXHRcdFx0fVxuXHRcdFx0bGlzdCA9IHtcblx0XHRcdFx0ZXh0cmFjdG9yczogW10sXG5cdFx0XHRcdHBhcnNlcnM6IFtdXG5cdFx0XHR9O1xuXHRcdFx0d2hpbGUgKCB0Ym9keUluZGV4IDwgbGVuICkge1xuXHRcdFx0XHRyb3dzID0gdGJvZHlbIHRib2R5SW5kZXggXS5yb3dzO1xuXHRcdFx0XHRpZiAoIHJvd3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNvbEluZGV4ID0gMDtcblx0XHRcdFx0XHRtYXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBtYXg7IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbEluZGV4IF07XG5cdFx0XHRcdFx0XHRpZiAoIGhlYWRlciAmJiBoZWFkZXIubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBnZXQgY29sdW1uIGluZGV4ZWQgdGFibGUgY2VsbDsgYWRkaW5nIHRydWUgcGFyYW1ldGVyIGZpeGVzICMxMzYyIGJ1dFxuXHRcdFx0XHRcdFx0XHQvLyBpdCB3b3VsZCBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4uLlxuXHRcdFx0XHRcdFx0XHRjb25maWdIZWFkZXJzID0gdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIGMuaGVhZGVycywgY29sSW5kZXggKTsgLy8gLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdC8vIGdldCBjb2x1bW4gcGFyc2VyL2V4dHJhY3RvclxuXHRcdFx0XHRcdFx0XHRleHRyYWN0b3IgPSB0cy5nZXRQYXJzZXJCeUlkKCB0cy5nZXREYXRhKCBoZWFkZXIsIGNvbmZpZ0hlYWRlcnMsICdleHRyYWN0b3InICkgKTtcblx0XHRcdFx0XHRcdFx0cGFyc2VyID0gdHMuZ2V0UGFyc2VyQnlJZCggdHMuZ2V0RGF0YSggaGVhZGVyLCBjb25maWdIZWFkZXJzLCAnc29ydGVyJyApICk7XG5cdFx0XHRcdFx0XHRcdG5vUGFyc2VyID0gdHMuZ2V0RGF0YSggaGVhZGVyLCBjb25maWdIZWFkZXJzLCAncGFyc2VyJyApID09PSAnZmFsc2UnO1xuXHRcdFx0XHRcdFx0XHQvLyBlbXB0eSBjZWxscyBiZWhhdmlvdXIgLSBrZWVwaW5nIGVtcHR5VG9Cb3R0b20gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdGMuZW1wdGllc1tjb2xJbmRleF0gPSAoXG5cdFx0XHRcdFx0XHRcdFx0dHMuZ2V0RGF0YSggaGVhZGVyLCBjb25maWdIZWFkZXJzLCAnZW1wdHknICkgfHxcblx0XHRcdFx0XHRcdFx0XHRjLmVtcHR5VG8gfHwgKCBjLmVtcHR5VG9Cb3R0b20gPyAnYm90dG9tJyA6ICd0b3AnICkgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHQvLyB0ZXh0IHN0cmluZ3MgYmVoYXZpb3VyIGluIG51bWVyaWNhbCBzb3J0c1xuXHRcdFx0XHRcdFx0XHRjLnN0cmluZ3NbY29sSW5kZXhdID0gKFxuXHRcdFx0XHRcdFx0XHRcdHRzLmdldERhdGEoIGhlYWRlciwgY29uZmlnSGVhZGVycywgJ3N0cmluZycgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdGMuc3RyaW5nVG8gfHxcblx0XHRcdFx0XHRcdFx0XHQnbWF4JyApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRcdGlmICggbm9QYXJzZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VyID0gdHMuZ2V0UGFyc2VyQnlJZCggJ25vLXBhcnNlcicgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoICFleHRyYWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIG5vdywgbWF5YmUgZGV0ZWN0IHNvbWVkYXlcblx0XHRcdFx0XHRcdFx0XHRleHRyYWN0b3IgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VyID0gdHMuZGV0ZWN0UGFyc2VyRm9yQ29sdW1uKCBjLCByb3dzLCAtMSwgY29sSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdFx0XHRcdGRlYnVnT3V0cHV0WyAnKCcgKyBjb2xJbmRleCArICcpICcgKyBoZWFkZXIudGV4dCgpIF0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJzZXIgOiBwYXJzZXIuaWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0b3IgOiBleHRyYWN0b3IgPyBleHRyYWN0b3IuaWQgOiAnbm9uZScsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJpbmcgOiBjLnN0cmluZ3NbIGNvbEluZGV4IF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbXB0eSAgOiBjLmVtcHRpZXNbIGNvbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxpc3QucGFyc2Vyc1sgY29sSW5kZXggXSA9IHBhcnNlcjtcblx0XHRcdFx0XHRcdFx0bGlzdC5leHRyYWN0b3JzWyBjb2xJbmRleCBdID0gZXh0cmFjdG9yO1xuXHRcdFx0XHRcdFx0XHRzcGFuID0gaGVhZGVyWyAwIF0uY29sU3BhbiAtIDE7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BhbiA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29sSW5kZXggKz0gc3Bhbjtcblx0XHRcdFx0XHRcdFx0XHRtYXggKz0gc3Bhbjtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIHNwYW4gKyAxID4gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHNldCBjb2xzcGFuIGNvbHVtbnMgdG8gdXNlIHRoZSBzYW1lIHBhcnNlcnMgJiBleHRyYWN0b3JzXG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnBhcnNlcnNbIGNvbEluZGV4IC0gc3BhbiBdID0gcGFyc2VyO1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5leHRyYWN0b3JzWyBjb2xJbmRleCAtIHNwYW4gXSA9IGV4dHJhY3Rvcjtcblx0XHRcdFx0XHRcdFx0XHRcdHNwYW4tLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbEluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRib2R5SW5kZXggKz0gKCBsaXN0LnBhcnNlcnMubGVuZ3RoICkgPyBsZW4gOiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0aWYgKCAhdHMuaXNFbXB0eU9iamVjdCggZGVidWdPdXRwdXQgKSApIHtcblx0XHRcdFx0XHRjb25zb2xlWyBjb25zb2xlLnRhYmxlID8gJ3RhYmxlJyA6ICdsb2cnIF0oIGRlYnVnT3V0cHV0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnICBObyBwYXJzZXJzIGRldGVjdGVkIScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZyggJ0NvbXBsZXRlZCBkZXRlY3RpbmcgcGFyc2VycycgKyB0cy5iZW5jaG1hcmsoIHRpbWUgKSApO1xuXHRcdFx0XHRpZiAoIGNvbnNvbGUuZ3JvdXBFbmQgKSB7IGNvbnNvbGUuZ3JvdXBFbmQoKTsgfVxuXHRcdFx0fVxuXHRcdFx0Yy5wYXJzZXJzID0gbGlzdC5wYXJzZXJzO1xuXHRcdFx0Yy5leHRyYWN0b3JzID0gbGlzdC5leHRyYWN0b3JzO1xuXHRcdH0sXG5cblx0XHRhZGRQYXJzZXIgOiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGluZHgsXG5cdFx0XHRcdGxlbiA9IHRzLnBhcnNlcnMubGVuZ3RoLFxuXHRcdFx0XHRhZGQgPSB0cnVlO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0aWYgKCB0cy5wYXJzZXJzWyBpbmR4IF0uaWQudG9Mb3dlckNhc2UoKSA9PT0gcGFyc2VyLmlkLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0YWRkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggYWRkICkge1xuXHRcdFx0XHR0cy5wYXJzZXJzWyB0cy5wYXJzZXJzLmxlbmd0aCBdID0gcGFyc2VyO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRQYXJzZXJCeUlkIDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHQvKmpzaGludCBlcWVxZXE6ZmFsc2UgKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBuYW1lID09ICdmYWxzZScgKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIGluZHgsXG5cdFx0XHRcdGxlbiA9IHRzLnBhcnNlcnMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0aWYgKCB0cy5wYXJzZXJzWyBpbmR4IF0uaWQudG9Mb3dlckNhc2UoKSA9PT0gKCBuYW1lLnRvU3RyaW5nKCkgKS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdHJldHVybiB0cy5wYXJzZXJzWyBpbmR4IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0ZGV0ZWN0UGFyc2VyRm9yQ29sdW1uIDogZnVuY3Rpb24oIGMsIHJvd3MsIHJvd0luZGV4LCBjZWxsSW5kZXggKSB7XG5cdFx0XHR2YXIgY3VyLCAkbm9kZSwgcm93LFxuXHRcdFx0XHRpbmR4ID0gdHMucGFyc2Vycy5sZW5ndGgsXG5cdFx0XHRcdG5vZGUgPSBmYWxzZSxcblx0XHRcdFx0bm9kZVZhbHVlID0gJycsXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ2NvcmUnKSxcblx0XHRcdFx0a2VlcExvb2tpbmcgPSB0cnVlO1xuXHRcdFx0d2hpbGUgKCBub2RlVmFsdWUgPT09ICcnICYmIGtlZXBMb29raW5nICkge1xuXHRcdFx0XHRyb3dJbmRleCsrO1xuXHRcdFx0XHRyb3cgPSByb3dzWyByb3dJbmRleCBdO1xuXHRcdFx0XHQvLyBzdG9wIGxvb2tpbmcgYWZ0ZXIgNTAgZW1wdHkgcm93c1xuXHRcdFx0XHRpZiAoIHJvdyAmJiByb3dJbmRleCA8IDUwICkge1xuXHRcdFx0XHRcdGlmICggcm93LmNsYXNzTmFtZS5pbmRleE9mKCB0cy5jc3NJZ25vcmVSb3cgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gcm93c1sgcm93SW5kZXggXS5jZWxsc1sgY2VsbEluZGV4IF07XG5cdFx0XHRcdFx0XHRub2RlVmFsdWUgPSB0cy5nZXRFbGVtZW50VGV4dCggYywgbm9kZSwgY2VsbEluZGV4ICk7XG5cdFx0XHRcdFx0XHQkbm9kZSA9ICQoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnQ2hlY2tpbmcgaWYgdmFsdWUgd2FzIGVtcHR5IG9uIHJvdyAnICsgcm93SW5kZXggKyAnLCBjb2x1bW46ICcgK1xuXHRcdFx0XHRcdFx0XHRcdGNlbGxJbmRleCArICc6IFwiJyArIG5vZGVWYWx1ZSArICdcIicgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a2VlcExvb2tpbmcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCAtLWluZHggPj0gMCApIHtcblx0XHRcdFx0Y3VyID0gdHMucGFyc2Vyc1sgaW5keCBdO1xuXHRcdFx0XHQvLyBpZ25vcmUgdGhlIGRlZmF1bHQgdGV4dCBwYXJzZXIgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0cnVlXG5cdFx0XHRcdGlmICggY3VyICYmIGN1ci5pZCAhPT0gJ3RleHQnICYmIGN1ci5pcyAmJiBjdXIuaXMoIG5vZGVWYWx1ZSwgYy50YWJsZSwgbm9kZSwgJG5vZGUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBub3RoaW5nIGZvdW5kLCByZXR1cm4gdGhlIGdlbmVyaWMgcGFyc2VyICh0ZXh0KVxuXHRcdFx0cmV0dXJuIHRzLmdldFBhcnNlckJ5SWQoICd0ZXh0JyApO1xuXHRcdH0sXG5cblx0XHRnZXRFbGVtZW50VGV4dCA6IGZ1bmN0aW9uKCBjLCBub2RlLCBjZWxsSW5kZXggKSB7XG5cdFx0XHRpZiAoICFub2RlICkgeyByZXR1cm4gJyc7IH1cblx0XHRcdHZhciB0bXAsXG5cdFx0XHRcdGV4dHJhY3QgPSBjLnRleHRFeHRyYWN0aW9uIHx8ICcnLFxuXHRcdFx0XHQvLyBub2RlIGNvdWxkIGJlIGEganF1ZXJ5IG9iamVjdFxuXHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9qcXVlcnktdnMtaW5zdGFuY2VvZi1qcXVlcnkvMlxuXHRcdFx0XHQkbm9kZSA9IG5vZGUuanF1ZXJ5ID8gbm9kZSA6ICQoIG5vZGUgKTtcblx0XHRcdGlmICggdHlwZW9mIGV4dHJhY3QgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHQvLyBjaGVjayBkYXRhLWF0dHJpYnV0ZSBmaXJzdCB3aGVuIHNldCB0byAnYmFzaWMnOyBkb24ndCB1c2Ugbm9kZS5pbm5lclRleHQgLSBpdCdzIHJlYWxseSBzbG93IVxuXHRcdFx0XHQvLyBodHRwOi8vd3d3LmtlbGxlZ291cy5jb20vai8yMDEzLzAyLzI3L2lubmVydGV4dC12cy10ZXh0Y29udGVudC9cblx0XHRcdFx0aWYgKCBleHRyYWN0ID09PSAnYmFzaWMnICYmIHR5cGVvZiAoIHRtcCA9ICRub2RlLmF0dHIoIGMudGV4dEF0dHJpYnV0ZSApICkgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdHJldHVybiAkLnRyaW0oIHRtcCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAkLnRyaW0oIG5vZGUudGV4dENvbnRlbnQgfHwgJG5vZGUudGV4dCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBleHRyYWN0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHJldHVybiAkLnRyaW0oIGV4dHJhY3QoICRub2RlWyAwIF0sIGMudGFibGUsIGNlbGxJbmRleCApICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiAoIHRtcCA9IHRzLmdldENvbHVtbkRhdGEoIGMudGFibGUsIGV4dHJhY3QsIGNlbGxJbmRleCApICkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQudHJpbSggdG1wKCAkbm9kZVsgMCBdLCBjLnRhYmxlLCBjZWxsSW5kZXggKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBmYWxsYmFja1xuXHRcdFx0cmV0dXJuICQudHJpbSggJG5vZGVbIDAgXS50ZXh0Q29udGVudCB8fCAkbm9kZS50ZXh0KCkgKTtcblx0XHR9LFxuXG5cdFx0Ly8gY2VudHJhbGl6ZWQgZnVuY3Rpb24gdG8gZXh0cmFjdC9wYXJzZSBjZWxsIGNvbnRlbnRzXG5cdFx0Z2V0UGFyc2VkVGV4dCA6IGZ1bmN0aW9uKCBjLCBjZWxsLCBjb2xJbmRleCwgdHh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdHh0ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0dHh0ID0gdHMuZ2V0RWxlbWVudFRleHQoIGMsIGNlbGwsIGNvbEluZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBubyBwYXJzZXIsIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIHR4dFxuXHRcdFx0dmFyIHZhbCA9ICcnICsgdHh0LFxuXHRcdFx0XHRwYXJzZXIgPSBjLnBhcnNlcnNbIGNvbEluZGV4IF0sXG5cdFx0XHRcdGV4dHJhY3RvciA9IGMuZXh0cmFjdG9yc1sgY29sSW5kZXggXTtcblx0XHRcdGlmICggcGFyc2VyICkge1xuXHRcdFx0XHQvLyBkbyBleHRyYWN0IGJlZm9yZSBwYXJzaW5nLCBpZiB0aGVyZSBpcyBvbmVcblx0XHRcdFx0aWYgKCBleHRyYWN0b3IgJiYgdHlwZW9mIGV4dHJhY3Rvci5mb3JtYXQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0dHh0ID0gZXh0cmFjdG9yLmZvcm1hdCggdHh0LCBjLnRhYmxlLCBjZWxsLCBjb2xJbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFsbG93IHBhcnNpbmcgaWYgdGhlIHN0cmluZyBpcyBlbXB0eSwgcHJldmlvdXNseSBwYXJzaW5nIHdvdWxkIGNoYW5nZSBpdCB0byB6ZXJvLFxuXHRcdFx0XHQvLyBpbiBjYXNlIHRoZSBwYXJzZXIgbmVlZHMgdG8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIHRhYmxlIGNlbGwgYXR0cmlidXRlc1xuXHRcdFx0XHR2YWwgPSBwYXJzZXIuaWQgPT09ICduby1wYXJzZXInID8gJycgOlxuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0eHQgaXMgYSBzdHJpbmcgKGV4dHJhY3RvciBtYXkgaGF2ZSBjb252ZXJ0ZWQgaXQpXG5cdFx0XHRcdFx0cGFyc2VyLmZvcm1hdCggJycgKyB0eHQsIGMudGFibGUsIGNlbGwsIGNvbEluZGV4ICk7XG5cdFx0XHRcdGlmICggYy5pZ25vcmVDYXNlICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdOKWhOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojiloQg4paE4paI4paI4paI4paI4paEIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiFxuXHRcdOKWiOKWiCAg4paA4paAIOKWiOKWiOKWhOKWhOKWiOKWiCDilojiloggIOKWgOKWgCDilojilojiloTiloTilojilogg4paI4paI4paE4paEXG5cdFx04paI4paIICDiloTiloQg4paI4paI4paA4paA4paI4paIIOKWiOKWiCAg4paE4paEIOKWiOKWiOKWgOKWgOKWiOKWiCDilojilojiloDiloBcblx0XHTiloDilojilojilojilojiloAg4paI4paIICDilojilogg4paA4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiFxuXHRcdCovXG5cdFx0YnVpbGRDYWNoZSA6IGZ1bmN0aW9uKCBjLCBjYWxsYmFjaywgJHRib2RpZXMgKSB7XG5cdFx0XHR2YXIgY2FjaGUsIHZhbCwgdHh0LCByb3dJbmRleCwgY29sSW5kZXgsIHRib2R5SW5kZXgsICR0Ym9keSwgJHJvdyxcblx0XHRcdFx0Y29scywgJGNlbGxzLCBjZWxsLCBjYWNoZVRpbWUsIHRvdGFsUm93cywgcm93RGF0YSwgcHJldlJvd0RhdGEsXG5cdFx0XHRcdGNvbE1heCwgc3BhbiwgY2FjaGVJbmRleCwgaGFzUGFyc2VyLCBtYXgsIGxlbiwgaW5kZXgsXG5cdFx0XHRcdHRhYmxlID0gYy50YWJsZSxcblx0XHRcdFx0cGFyc2VycyA9IGMucGFyc2Vycyxcblx0XHRcdFx0ZGVidWcgPSB0cy5kZWJ1ZyhjLCAnY29yZScpO1xuXHRcdFx0Ly8gdXBkYXRlIHRib2R5IHZhcmlhYmxlXG5cdFx0XHRjLiR0Ym9kaWVzID0gYy4kdGFibGUuY2hpbGRyZW4oICd0Ym9keTpub3QoLicgKyBjLmNzc0luZm9CbG9jayArICcpJyApO1xuXHRcdFx0JHRib2R5ID0gdHlwZW9mICR0Ym9kaWVzID09PSAndW5kZWZpbmVkJyA/IGMuJHRib2RpZXMgOiAkdGJvZGllcyxcblx0XHRcdGMuY2FjaGUgPSB7fTtcblx0XHRcdGMudG90YWxSb3dzID0gMDtcblx0XHRcdC8vIGlmIG5vIHBhcnNlcnMgZm91bmQsIHJldHVybiAtIGl0J3MgYW4gZW1wdHkgdGFibGUuXG5cdFx0XHRpZiAoICFwYXJzZXJzICkge1xuXHRcdFx0XHRyZXR1cm4gZGVidWcgPyBjb25zb2xlLndhcm4oICdXYXJuaW5nOiAqRW1wdHkgdGFibGUhKiBOb3QgYnVpbGRpbmcgYSBjYWNoZScgKSA6ICcnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0Y2FjaGVUaW1lID0gbmV3IERhdGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIHByb2Nlc3NpbmcgaWNvblxuXHRcdFx0aWYgKCBjLnNob3dQcm9jZXNzaW5nICkge1xuXHRcdFx0XHR0cy5pc1Byb2Nlc3NpbmcoIHRhYmxlLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8ICR0Ym9keS5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0Y29sTWF4ID0gW107IC8vIGNvbHVtbiBtYXggdmFsdWUgcGVyIHRib2R5XG5cdFx0XHRcdGNhY2hlID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdID0ge1xuXHRcdFx0XHRcdG5vcm1hbGl6ZWQ6IFtdIC8vIGFycmF5IG9mIG5vcm1hbGl6ZWQgcm93IGRhdGE7IGxhc3QgZW50cnkgY29udGFpbnMgJ3Jvd0RhdGEnIGFib3ZlXG5cdFx0XHRcdFx0Ly8gY29sTWF4OiAjICAgLy8gYWRkZWQgYXQgdGhlIGVuZFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRvdGFsUm93cyA9ICggJHRib2R5WyB0Ym9keUluZGV4IF0gJiYgJHRib2R5WyB0Ym9keUluZGV4IF0ucm93cy5sZW5ndGggKSB8fCAwO1xuXHRcdFx0XHRmb3IgKCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgdG90YWxSb3dzOyArK3Jvd0luZGV4ICkge1xuXHRcdFx0XHRcdHJvd0RhdGEgPSB7XG5cdFx0XHRcdFx0XHQvLyBvcmRlcjogb3JpZ2luYWwgcm93IG9yZGVyICNcblx0XHRcdFx0XHRcdC8vICRyb3cgOiBqUXVlcnkgT2JqZWN0W11cblx0XHRcdFx0XHRcdGNoaWxkOiBbXSwgLy8gY2hpbGQgcm93IHRleHQgKGZpbHRlciB3aWRnZXQpXG5cdFx0XHRcdFx0XHRyYXc6IFtdICAgIC8vIG9yaWdpbmFsIHJvdyB0ZXh0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHQvKiogQWRkIHRoZSB0YWJsZSBkYXRhIHRvIG1haW4gZGF0YSBhcnJheSAqL1xuXHRcdFx0XHRcdCRyb3cgPSAkKCAkdGJvZHlbIHRib2R5SW5kZXggXS5yb3dzWyByb3dJbmRleCBdICk7XG5cdFx0XHRcdFx0Y29scyA9IFtdO1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBcInJlbW92ZS1tZVwiIHJvd3Ncblx0XHRcdFx0XHRpZiAoICRyb3cuaGFzQ2xhc3MoIGMuc2VsZWN0b3JSZW1vdmUuc2xpY2UoMSkgKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgY2hpbGQgcm93LCBhZGQgaXQgdG8gdGhlIGxhc3Qgcm93J3MgY2hpbGRyZW4gYW5kIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHJvd1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBjaGlsZCByb3cgY2xhc3MsIGlmIGl0IGlzIHRoZSBmaXJzdCByb3dcblx0XHRcdFx0XHRpZiAoICRyb3cuaGFzQ2xhc3MoIGMuY3NzQ2hpbGRSb3cgKSAmJiByb3dJbmRleCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdGxlbiA9IGNhY2hlLm5vcm1hbGl6ZWQubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHByZXZSb3dEYXRhID0gY2FjaGUubm9ybWFsaXplZFsgbGVuIF1bIGMuY29sdW1ucyBdO1xuXHRcdFx0XHRcdFx0cHJldlJvd0RhdGEuJHJvdyA9IHByZXZSb3dEYXRhLiRyb3cuYWRkKCAkcm93ICk7XG5cdFx0XHRcdFx0XHQvLyBhZGQgJ2hhc0NoaWxkJyBjbGFzcyBuYW1lIHRvIHBhcmVudCByb3dcblx0XHRcdFx0XHRcdGlmICggISRyb3cucHJldigpLmhhc0NsYXNzKCBjLmNzc0NoaWxkUm93ICkgKSB7XG5cdFx0XHRcdFx0XHRcdCRyb3cucHJldigpLmFkZENsYXNzKCB0cy5jc3MuY3NzSGFzQ2hpbGQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHNhdmUgY2hpbGQgcm93IGNvbnRlbnQgKHVuLXBhcnNlZCEpXG5cdFx0XHRcdFx0XHQkY2VsbHMgPSAkcm93LmNoaWxkcmVuKCAndGgsIHRkJyApO1xuXHRcdFx0XHRcdFx0bGVuID0gcHJldlJvd0RhdGEuY2hpbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0cHJldlJvd0RhdGEuY2hpbGRbIGxlbiBdID0gW107XG5cdFx0XHRcdFx0XHQvLyBjaGlsZCByb3cgY29udGVudCBkb2VzIG5vdCBhY2NvdW50IGZvciBjb2xzcGFucy9yb3dzcGFuczsgc28gaW5kZXhpbmcgbWF5IGJlIG9mZlxuXHRcdFx0XHRcdFx0Y2FjaGVJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRtYXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdFx0XHRmb3IgKCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgbWF4OyBjb2xJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsID0gJGNlbGxzWyBjb2xJbmRleCBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNlbGwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJldlJvd0RhdGEuY2hpbGRbIGxlbiBdWyBjb2xJbmRleCBdID0gdHMuZ2V0UGFyc2VkVGV4dCggYywgY2VsbCwgY29sSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0XHRzcGFuID0gJGNlbGxzWyBjb2xJbmRleCBdLmNvbFNwYW4gLSAxO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggc3BhbiA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYWNoZUluZGV4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdFx0XHRtYXggKz0gc3Bhbjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y2FjaGVJbmRleCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gZ28gdG8gdGhlIG5leHQgZm9yIGxvb3Bcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyb3dEYXRhLiRyb3cgPSAkcm93O1xuXHRcdFx0XHRcdHJvd0RhdGEub3JkZXIgPSByb3dJbmRleDsgLy8gYWRkIG9yaWdpbmFsIHJvdyBwb3NpdGlvbiB0byByb3dDYWNoZVxuXHRcdFx0XHRcdGNhY2hlSW5kZXggPSAwO1xuXHRcdFx0XHRcdG1heCA9IGMuY29sdW1ucztcblx0XHRcdFx0XHRmb3IgKCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgbWF4OyArK2NvbEluZGV4ICkge1xuXHRcdFx0XHRcdFx0Y2VsbCA9ICRyb3dbIDAgXS5jZWxsc1sgY29sSW5kZXggXTtcblx0XHRcdFx0XHRcdGlmICggY2VsbCAmJiBjYWNoZUluZGV4IDwgYy5jb2x1bW5zICkge1xuXHRcdFx0XHRcdFx0XHRoYXNQYXJzZXIgPSB0eXBlb2YgcGFyc2Vyc1sgY2FjaGVJbmRleCBdICE9PSAndW5kZWZpbmVkJztcblx0XHRcdFx0XHRcdFx0aWYgKCAhaGFzUGFyc2VyICYmIGRlYnVnICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ05vIHBhcnNlciBmb3VuZCBmb3Igcm93OiAnICsgcm93SW5kZXggKyAnLCBjb2x1bW46ICcgKyBjb2xJbmRleCArXG5cdFx0XHRcdFx0XHRcdFx0XHQnOyBjZWxsIGNvbnRhaW5pbmc6IFwiJyArICQoY2VsbCkudGV4dCgpICsgJ1wiOyBkb2VzIGl0IGhhdmUgYSBoZWFkZXI/JyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhbCA9IHRzLmdldEVsZW1lbnRUZXh0KCBjLCBjZWxsLCBjYWNoZUluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdHJvd0RhdGEucmF3WyBjYWNoZUluZGV4IF0gPSB2YWw7IC8vIHNhdmUgb3JpZ2luYWwgcm93IHRleHRcblx0XHRcdFx0XHRcdFx0Ly8gc2F2ZSByYXcgY29sdW1uIHRleHQgZXZlbiBpZiB0aGVyZSBpcyBubyBwYXJzZXIgc2V0XG5cdFx0XHRcdFx0XHRcdHR4dCA9IHRzLmdldFBhcnNlZFRleHQoIGMsIGNlbGwsIGNhY2hlSW5kZXgsIHZhbCApO1xuXHRcdFx0XHRcdFx0XHRjb2xzWyBjYWNoZUluZGV4IF0gPSB0eHQ7XG5cdFx0XHRcdFx0XHRcdGlmICggaGFzUGFyc2VyICYmICggcGFyc2Vyc1sgY2FjaGVJbmRleCBdLnR5cGUgfHwgJycgKS50b0xvd2VyQ2FzZSgpID09PSAnbnVtZXJpYycgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIGNvbHVtbiBtYXggdmFsdWUgKGlnbm9yZSBzaWduKVxuXHRcdFx0XHRcdFx0XHRcdGNvbE1heFsgY2FjaGVJbmRleCBdID0gTWF0aC5tYXgoIE1hdGguYWJzKCB0eHQgKSB8fCAwLCBjb2xNYXhbIGNhY2hlSW5kZXggXSB8fCAwICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gYWxsb3cgY29sU3BhbiBpbiB0Ym9keVxuXHRcdFx0XHRcdFx0XHRzcGFuID0gY2VsbC5jb2xTcGFuIC0gMTtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGFuID4gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpbmRleCA8PSBzcGFuICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZHVwbGljYXRlIHRleHQgKG9yIG5vdCkgdG8gc3Bhbm5lZCBjb2x1bW5zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpbnN0ZWFkIG9mIHNldHRpbmcgZHVwbGljYXRlIHNwYW4gdG8gZW1wdHkgc3RyaW5nLCB1c2UgdGV4dEV4dHJhY3Rpb24gdG8gdHJ5IHRvIGdldCBhIHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzY0NDk3MTEvMTQ1MzQ2XG5cdFx0XHRcdFx0XHRcdFx0XHR0eHQgPSBjLmR1cGxpY2F0ZVNwYW4gfHwgaW5kZXggPT09IDAgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eHQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgYy50ZXh0RXh0cmFjdGlvbiAhPT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzLmdldEVsZW1lbnRUZXh0KCBjLCBjZWxsLCBjYWNoZUluZGV4ICsgaW5kZXggKSB8fCAnJyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Jyc7XG5cdFx0XHRcdFx0XHRcdFx0XHRyb3dEYXRhLnJhd1sgY2FjaGVJbmRleCArIGluZGV4IF0gPSB0eHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xzWyBjYWNoZUluZGV4ICsgaW5kZXggXSA9IHR4dDtcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlSW5kZXggKz0gc3Bhbjtcblx0XHRcdFx0XHRcdFx0XHRtYXggKz0gc3Bhbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FjaGVJbmRleCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbnN1cmUgcm93RGF0YSBpcyBhbHdheXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gKGFmdGVyIHRoZSBsYXN0IGNvbHVtbilcblx0XHRcdFx0XHRjb2xzWyBjLmNvbHVtbnMgXSA9IHJvd0RhdGE7XG5cdFx0XHRcdFx0Y2FjaGUubm9ybWFsaXplZFsgY2FjaGUubm9ybWFsaXplZC5sZW5ndGggXSA9IGNvbHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGUuY29sTWF4ID0gY29sTWF4O1xuXHRcdFx0XHQvLyB0b3RhbCB1cCByb3dzLCBub3QgaW5jbHVkaW5nIGNoaWxkIHJvd3Ncblx0XHRcdFx0Yy50b3RhbFJvd3MgKz0gY2FjaGUubm9ybWFsaXplZC5sZW5ndGg7XG5cblx0XHRcdH1cblx0XHRcdGlmICggYy5zaG93UHJvY2Vzc2luZyApIHtcblx0XHRcdFx0dHMuaXNQcm9jZXNzaW5nKCB0YWJsZSApOyAvLyByZW1vdmUgcHJvY2Vzc2luZyBpY29uXG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRsZW4gPSBNYXRoLm1pbiggNSwgYy5jYWNoZVsgMCBdLm5vcm1hbGl6ZWQubGVuZ3RoICk7XG5cdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ0J1aWxkaW5nIGNhY2hlIGZvciAnICsgYy50b3RhbFJvd3MgK1xuXHRcdFx0XHRcdCcgcm93cyAoc2hvd2luZyAnICsgbGVuICsgJyByb3dzIGluIGxvZykgYW5kICcgKyBjLmNvbHVtbnMgKyAnIGNvbHVtbnMnICtcblx0XHRcdFx0XHR0cy5iZW5jaG1hcmsoIGNhY2hlVGltZSApICk7XG5cdFx0XHRcdHZhbCA9IHt9O1xuXHRcdFx0XHRmb3IgKCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgYy5jb2x1bW5zOyBjb2xJbmRleCsrICkge1xuXHRcdFx0XHRcdGZvciAoIGNhY2hlSW5kZXggPSAwOyBjYWNoZUluZGV4IDwgbGVuOyBjYWNoZUluZGV4KysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICF2YWxbICdyb3c6ICcgKyBjYWNoZUluZGV4IF0gKSB7XG5cdFx0XHRcdFx0XHRcdHZhbFsgJ3JvdzogJyArIGNhY2hlSW5kZXggXSA9IHt9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsWyAncm93OiAnICsgY2FjaGVJbmRleCBdWyBjLiRoZWFkZXJJbmRleGVkWyBjb2xJbmRleCBdLnRleHQoKSBdID1cblx0XHRcdFx0XHRcdFx0Yy5jYWNoZVsgMCBdLm5vcm1hbGl6ZWRbIGNhY2hlSW5kZXggXVsgY29sSW5kZXggXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZVsgY29uc29sZS50YWJsZSA/ICd0YWJsZScgOiAnbG9nJyBdKCB2YWwgKTtcblx0XHRcdFx0aWYgKCBjb25zb2xlLmdyb3VwRW5kICkgeyBjb25zb2xlLmdyb3VwRW5kKCk7IH1cblx0XHRcdH1cblx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICkge1xuXHRcdFx0XHRjYWxsYmFjayggdGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0Q29sdW1uVGV4dCA6IGZ1bmN0aW9uKCB0YWJsZSwgY29sdW1uLCBjYWxsYmFjaywgcm93RmlsdGVyICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWzBdO1xuXHRcdFx0dmFyIHRib2R5SW5kZXgsIHJvd0luZGV4LCBjYWNoZSwgcm93LCB0Ym9keUxlbiwgcm93TGVuLCByYXcsIHBhcnNlZCwgJGNlbGwsIHJlc3VsdCxcblx0XHRcdFx0aGFzQ2FsbGJhY2sgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsXG5cdFx0XHRcdGFsbENvbHVtbnMgPSBjb2x1bW4gPT09ICdhbGwnLFxuXHRcdFx0XHRkYXRhID0geyByYXcgOiBbXSwgcGFyc2VkOiBbXSwgJGNlbGw6IFtdIH0sXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWc7XG5cdFx0XHRpZiAoIHRzLmlzRW1wdHlPYmplY3QoIGMgKSApIHtcblx0XHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ05vIGNhY2hlIGZvdW5kIC0gYWJvcnRpbmcgZ2V0Q29sdW1uVGV4dCBmdW5jdGlvbiEnICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRib2R5TGVuID0gYy4kdGJvZGllcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgdGJvZHlMZW47IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0XHRjYWNoZSA9IGMuY2FjaGVbIHRib2R5SW5kZXggXS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdHJvd0xlbiA9IGNhY2hlLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93TGVuOyByb3dJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0cm93ID0gY2FjaGVbIHJvd0luZGV4IF07XG5cdFx0XHRcdFx0XHRpZiAoIHJvd0ZpbHRlciAmJiAhcm93WyBjLmNvbHVtbnMgXS4kcm93LmlzKCByb3dGaWx0ZXIgKSApIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cGFyc2VkID0gKCBhbGxDb2x1bW5zICkgPyByb3cuc2xpY2UoIDAsIGMuY29sdW1ucyApIDogcm93WyBjb2x1bW4gXTtcblx0XHRcdFx0XHRcdHJvdyA9IHJvd1sgYy5jb2x1bW5zIF07XG5cdFx0XHRcdFx0XHRyYXcgPSAoIGFsbENvbHVtbnMgKSA/IHJvdy5yYXcgOiByb3cucmF3WyBjb2x1bW4gXTtcblx0XHRcdFx0XHRcdCRjZWxsID0gKCBhbGxDb2x1bW5zICkgPyByb3cuJHJvdy5jaGlsZHJlbigpIDogcm93LiRyb3cuY2hpbGRyZW4oKS5lcSggY29sdW1uICk7XG5cdFx0XHRcdFx0XHRpZiAoIGhhc0NhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBjYWxsYmFjayh7XG5cdFx0XHRcdFx0XHRcdFx0dGJvZHlJbmRleCA6IHRib2R5SW5kZXgsXG5cdFx0XHRcdFx0XHRcdFx0cm93SW5kZXggOiByb3dJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZWQgOiBwYXJzZWQsXG5cdFx0XHRcdFx0XHRcdFx0cmF3IDogcmF3LFxuXHRcdFx0XHRcdFx0XHRcdCRyb3cgOiByb3cuJHJvdyxcblx0XHRcdFx0XHRcdFx0XHQkY2VsbCA6ICRjZWxsXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCByZXN1bHQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRkYXRhLnBhcnNlZFsgZGF0YS5wYXJzZWQubGVuZ3RoIF0gPSBwYXJzZWQ7XG5cdFx0XHRcdFx0XHRcdGRhdGEucmF3WyBkYXRhLnJhdy5sZW5ndGggXSA9IHJhdztcblx0XHRcdFx0XHRcdFx0ZGF0YS4kY2VsbFsgZGF0YS4kY2VsbC5sZW5ndGggXSA9ICRjZWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXR1cm4gZXZlcnl0aGluZ1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHTilojiloggIOKWiOKWiCDilojilojilojilojilojiloQg4paI4paI4paI4paI4paI4paEIOKWhOKWiOKWiOKWiOKWiOKWhCDilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paIXG5cdFx04paI4paIICDilojilogg4paI4paI4paE4paE4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiCAgIOKWiOKWiCAgIOKWiOKWiOKWhOKWhFxuXHRcdOKWiOKWiCAg4paI4paIIOKWiOKWiOKWgOKWgOKWgCAg4paI4paIICDilojilogg4paI4paI4paA4paA4paI4paIICAg4paI4paIICAg4paI4paI4paA4paAXG5cdFx04paA4paI4paI4paI4paI4paAIOKWiOKWiCAgICAg4paI4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIICAg4paI4paIICAg4paI4paI4paI4paI4paI4paIXG5cdFx0Ki9cblx0XHRzZXRIZWFkZXJzQ3NzIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgaW5keCwgY29sdW1uLFxuXHRcdFx0XHRsaXN0ID0gYy5zb3J0TGlzdCxcblx0XHRcdFx0bGVuID0gbGlzdC5sZW5ndGgsXG5cdFx0XHRcdG5vbmUgPSB0cy5jc3Muc29ydE5vbmUgKyAnICcgKyBjLmNzc05vbmUsXG5cdFx0XHRcdGNzcyA9IFsgdHMuY3NzLnNvcnRBc2MgKyAnICcgKyBjLmNzc0FzYywgdHMuY3NzLnNvcnREZXNjICsgJyAnICsgYy5jc3NEZXNjIF0sXG5cdFx0XHRcdGNzc0ljb24gPSBbIGMuY3NzSWNvbkFzYywgYy5jc3NJY29uRGVzYywgYy5jc3NJY29uTm9uZSBdLFxuXHRcdFx0XHRhcmlhID0gWyAnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnIF0sXG5cdFx0XHRcdHVwZGF0ZUNvbHVtblNvcnQgPSBmdW5jdGlvbigkZWwsIGluZGV4KSB7XG5cdFx0XHRcdFx0JGVsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIG5vbmUgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjc3NbIGluZGV4IF0gKVxuXHRcdFx0XHRcdFx0LmF0dHIoICdhcmlhLXNvcnQnLCBhcmlhWyBpbmRleCBdIClcblx0XHRcdFx0XHRcdC5maW5kKCAnLicgKyB0cy5jc3MuaWNvbiApXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNzc0ljb25bIDIgXSApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNzc0ljb25bIGluZGV4IF0gKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gZmluZCB0aGUgZm9vdGVyXG5cdFx0XHRcdCRleHRyYXMgPSBjLiR0YWJsZVxuXHRcdFx0XHRcdC5maW5kKCAndGZvb3QgdHInIClcblx0XHRcdFx0XHQuY2hpbGRyZW4oICd0ZCwgdGgnIClcblx0XHRcdFx0XHQuYWRkKCAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfaGVhZGVycycgKSApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjc3Muam9pbiggJyAnICkgKSxcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBoZWFkZXIgaW5mb3JtYXRpb25cblx0XHRcdFx0JHNvcnRlZCA9IGMuJGhlYWRlcnNcblx0XHRcdFx0XHQuYWRkKCAkKCAndGhlYWQgJyArIGMubmFtZXNwYWNlICsgJ19leHRyYV9oZWFkZXJzJyApIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNzcy5qb2luKCAnICcgKSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBub25lIClcblx0XHRcdFx0XHQuYXR0ciggJ2FyaWEtc29ydCcsICdub25lJyApXG5cdFx0XHRcdFx0LmZpbmQoICcuJyArIHRzLmNzcy5pY29uIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNzc0ljb24uam9pbiggJyAnICkgKVxuXHRcdFx0XHRcdC5lbmQoKTtcblx0XHRcdC8vIGFkZCBjc3Mgbm9uZSB0byBhbGwgc29ydGFibGUgaGVhZGVyc1xuXHRcdFx0JHNvcnRlZFxuXHRcdFx0XHQubm90KCAnLnNvcnRlci1mYWxzZScgKVxuXHRcdFx0XHQuZmluZCggJy4nICsgdHMuY3NzLmljb24gKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGNzc0ljb25bIDIgXSApO1xuXHRcdFx0Ly8gYWRkIGRpc2FibGVkIGNzcyBpY29uIGNsYXNzXG5cdFx0XHRpZiAoIGMuY3NzSWNvbkRpc2FibGVkICkge1xuXHRcdFx0XHQkc29ydGVkXG5cdFx0XHRcdFx0LmZpbHRlciggJy5zb3J0ZXItZmFsc2UnIClcblx0XHRcdFx0XHQuZmluZCggJy4nICsgdHMuY3NzLmljb24gKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggYy5jc3NJY29uRGlzYWJsZWQgKTtcblx0XHRcdH1cblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdC8vIGRpcmVjdGlvbiA9IDIgbWVhbnMgcmVzZXQhXG5cdFx0XHRcdGlmICggbGlzdFsgaW5keCBdWyAxIF0gIT09IDIgKSB7XG5cdFx0XHRcdFx0Ly8gbXVsdGljb2x1bW4gc29ydGluZyB1cGRhdGluZyAtIHNlZSAjMTAwNVxuXHRcdFx0XHRcdC8vIC5ub3QoZnVuY3Rpb24oKSB7fSkgbmVlZHMgalF1ZXJ5IDEuNFxuXHRcdFx0XHRcdC8vIGZpbHRlcihmdW5jdGlvbihpLCBlbCkge30pIDwtIGVsIGlzIHVuZGVmaW5lZCBpbiBqUXVlcnkgdjEuMi42XG5cdFx0XHRcdFx0JHNvcnRlZCA9IGMuJGhlYWRlcnMuZmlsdGVyKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdC8vIG9ubHkgaW5jbHVkZSBoZWFkZXJzIHRoYXQgYXJlIGluIHRoZSBzb3J0TGlzdCAodGhpcyBpbmNsdWRlcyBjb2xzcGFucylcblx0XHRcdFx0XHRcdHZhciBpbmNsdWRlID0gdHJ1ZSxcblx0XHRcdFx0XHRcdFx0JGVsID0gYy4kaGVhZGVycy5lcSggaSApLFxuXHRcdFx0XHRcdFx0XHRjb2wgPSBwYXJzZUludCggJGVsLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKSxcblx0XHRcdFx0XHRcdFx0ZW5kID0gY29sICsgdHMuZ2V0Q2xvc2VzdCggJGVsLCAndGgsIHRkJyApWzBdLmNvbFNwYW47XG5cdFx0XHRcdFx0XHRmb3IgKCA7IGNvbCA8IGVuZDsgY29sKysgKSB7XG5cdFx0XHRcdFx0XHRcdGluY2x1ZGUgPSBpbmNsdWRlID8gaW5jbHVkZSB8fCB0cy5pc1ZhbHVlSW5BcnJheSggY29sLCBjLnNvcnRMaXN0ICkgPiAtMSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGluY2x1ZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBjaG9vc2UgdGhlIDpsYXN0IGluIGNhc2UgdGhlcmUgYXJlIG5lc3RlZCBjb2x1bW5zXG5cdFx0XHRcdFx0JHNvcnRlZCA9ICRzb3J0ZWRcblx0XHRcdFx0XHRcdC5ub3QoICcuc29ydGVyLWZhbHNlJyApXG5cdFx0XHRcdFx0XHQuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGxpc3RbIGluZHggXVsgMCBdICsgJ1wiXScgKyAoIGxlbiA9PT0gMSA/ICc6bGFzdCcgOiAnJyApICk7XG5cdFx0XHRcdFx0aWYgKCAkc29ydGVkLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZvciAoIGNvbHVtbiA9IDA7IGNvbHVtbiA8ICRzb3J0ZWQubGVuZ3RoOyBjb2x1bW4rKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhJHNvcnRlZFsgY29sdW1uIF0uc29ydERpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZUNvbHVtblNvcnQoICRzb3J0ZWQuZXEoIGNvbHVtbiApLCBsaXN0WyBpbmR4IF1bIDEgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFkZCBzb3J0ZWQgY2xhc3MgdG8gZm9vdGVyICYgZXh0cmEgaGVhZGVycywgaWYgdGhleSBleGlzdFxuXHRcdFx0XHRcdGlmICggJGV4dHJhcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVDb2x1bW5Tb3J0KCAkZXh0cmFzLmZpbHRlciggJ1tkYXRhLWNvbHVtbj1cIicgKyBsaXN0WyBpbmR4IF1bIDAgXSArICdcIl0nICksIGxpc3RbIGluZHggXVsgMSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgdmVyYm9zZSBhcmlhIGxhYmVsc1xuXHRcdFx0bGVuID0gYy4kaGVhZGVycy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHR0cy5zZXRDb2x1bW5BcmlhTGFiZWwoIGMsIGMuJGhlYWRlcnMuZXEoIGluZHggKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRDbG9zZXN0IDogZnVuY3Rpb24oICRlbCwgc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBqUXVlcnkgdjEuMi42IGRvZXNuJ3QgaGF2ZSBjbG9zZXN0KClcblx0XHRcdGlmICggJC5mbi5jbG9zZXN0ICkge1xuXHRcdFx0XHRyZXR1cm4gJGVsLmNsb3Nlc3QoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJGVsLmlzKCBzZWxlY3RvciApID9cblx0XHRcdFx0JGVsIDpcblx0XHRcdFx0JGVsLnBhcmVudHMoIHNlbGVjdG9yICkuZmlsdGVyKCAnOmZpcnN0JyApO1xuXHRcdH0sXG5cblx0XHQvLyBuZXh0U29ydCAob3B0aW9uYWwpLCBsZXRzIHlvdSBkaXNhYmxlIG5leHQgc29ydCB0ZXh0XG5cdFx0c2V0Q29sdW1uQXJpYUxhYmVsIDogZnVuY3Rpb24oIGMsICRoZWFkZXIsIG5leHRTb3J0ICkge1xuXHRcdFx0aWYgKCAkaGVhZGVyLmxlbmd0aCApIHtcblx0XHRcdFx0dmFyIGNvbHVtbiA9IHBhcnNlSW50KCAkaGVhZGVyLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKSxcblx0XHRcdFx0XHR2YXJzID0gYy5zb3J0VmFyc1sgY29sdW1uIF0sXG5cdFx0XHRcdFx0dG1wID0gJGhlYWRlci5oYXNDbGFzcyggdHMuY3NzLnNvcnRBc2MgKSA/XG5cdFx0XHRcdFx0XHQnc29ydEFzYycgOlxuXHRcdFx0XHRcdFx0JGhlYWRlci5oYXNDbGFzcyggdHMuY3NzLnNvcnREZXNjICkgPyAnc29ydERlc2MnIDogJ3NvcnROb25lJyxcblx0XHRcdFx0XHR0eHQgPSAkLnRyaW0oICRoZWFkZXIudGV4dCgpICkgKyAnOiAnICsgdHMubGFuZ3VhZ2VbIHRtcCBdO1xuXHRcdFx0XHRpZiAoICRoZWFkZXIuaGFzQ2xhc3MoICdzb3J0ZXItZmFsc2UnICkgfHwgbmV4dFNvcnQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHR4dCArPSB0cy5sYW5ndWFnZS5zb3J0RGlzYWJsZWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gKCB2YXJzLmNvdW50ICsgMSApICUgdmFycy5vcmRlci5sZW5ndGg7XG5cdFx0XHRcdFx0bmV4dFNvcnQgPSB2YXJzLm9yZGVyWyB0bXAgXTtcblx0XHRcdFx0XHQvLyBpZiBuZXh0U29ydFxuXHRcdFx0XHRcdHR4dCArPSB0cy5sYW5ndWFnZVsgbmV4dFNvcnQgPT09IDAgPyAnbmV4dEFzYycgOiBuZXh0U29ydCA9PT0gMSA/ICduZXh0RGVzYycgOiAnbmV4dE5vbmUnIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0JGhlYWRlci5hdHRyKCAnYXJpYS1sYWJlbCcsIHR4dCApO1xuXHRcdFx0XHRpZiAodmFycy5zb3J0ZWRCeSkge1xuXHRcdFx0XHRcdCRoZWFkZXIuYXR0ciggJ2RhdGEtc29ydGVkQnknLCB2YXJzLnNvcnRlZEJ5ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGhlYWRlci5yZW1vdmVBdHRyKCdkYXRhLXNvcnRlZEJ5Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dXBkYXRlSGVhZGVyIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIGlzRGlzYWJsZWQsICRoZWFkZXIsIGNvbCxcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlLFxuXHRcdFx0XHRsZW4gPSBjLiRoZWFkZXJzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzLmVxKCBpbmRleCApO1xuXHRcdFx0XHRjb2wgPSB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgYy5oZWFkZXJzLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHQvLyBhZGQgJ3NvcnRlci1mYWxzZScgY2xhc3MgaWYgJ3BhcnNlci1mYWxzZScgaXMgc2V0XG5cdFx0XHRcdGlzRGlzYWJsZWQgPSB0cy5nZXREYXRhKCAkaGVhZGVyLCBjb2wsICdzb3J0ZXInICkgPT09ICdmYWxzZScgfHwgdHMuZ2V0RGF0YSggJGhlYWRlciwgY29sLCAncGFyc2VyJyApID09PSAnZmFsc2UnO1xuXHRcdFx0XHR0cy5zZXRDb2x1bW5Tb3J0KCBjLCAkaGVhZGVyLCBpc0Rpc2FibGVkICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldENvbHVtblNvcnQgOiBmdW5jdGlvbiggYywgJGhlYWRlciwgaXNEaXNhYmxlZCApIHtcblx0XHRcdHZhciBpZCA9IGMudGFibGUuaWQ7XG5cdFx0XHQkaGVhZGVyWyAwIF0uc29ydERpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0XHRcdCRoZWFkZXJbIGlzRGlzYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJyBdKCAnc29ydGVyLWZhbHNlJyApXG5cdFx0XHRcdC5hdHRyKCAnYXJpYS1kaXNhYmxlZCcsICcnICsgaXNEaXNhYmxlZCApO1xuXHRcdFx0Ly8gZGlzYWJsZSB0YWIgaW5kZXggb24gZGlzYWJsZWQgY2VsbHNcblx0XHRcdGlmICggYy50YWJJbmRleCApIHtcblx0XHRcdFx0aWYgKCBpc0Rpc2FibGVkICkge1xuXHRcdFx0XHRcdCRoZWFkZXIucmVtb3ZlQXR0ciggJ3RhYmluZGV4JyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRoZWFkZXIuYXR0ciggJ3RhYmluZGV4JywgJzAnICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFyaWEtY29udHJvbHMgLSByZXF1aXJlcyB0YWJsZSBJRFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0aWYgKCBpc0Rpc2FibGVkICkge1xuXHRcdFx0XHRcdCRoZWFkZXIucmVtb3ZlQXR0ciggJ2FyaWEtY29udHJvbHMnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGhlYWRlci5hdHRyKCAnYXJpYS1jb250cm9scycsIGlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dXBkYXRlSGVhZGVyU29ydENvdW50IDogZnVuY3Rpb24oIGMsIGxpc3QgKSB7XG5cdFx0XHR2YXIgY29sLCBkaXIsIGdyb3VwLCBpbmR4LCBwcmltYXJ5LCB0ZW1wLCB2YWwsIG9yZGVyLFxuXHRcdFx0XHRzb3J0TGlzdCA9IGxpc3QgfHwgYy5zb3J0TGlzdCxcblx0XHRcdFx0bGVuID0gc29ydExpc3QubGVuZ3RoO1xuXHRcdFx0Yy5zb3J0TGlzdCA9IFtdO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0dmFsID0gc29ydExpc3RbIGluZHggXTtcblx0XHRcdFx0Ly8gZW5zdXJlIGFsbCBzb3J0TGlzdCB2YWx1ZXMgYXJlIG51bWVyaWMgLSBmaXhlcyAjMTI3XG5cdFx0XHRcdGNvbCA9IHBhcnNlSW50KCB2YWxbIDAgXSwgMTAgKTtcblx0XHRcdFx0Ly8gcHJldmVudHMgZXJyb3IgaWYgc29ydG9uIGFycmF5IGlzIHdyb25nXG5cdFx0XHRcdGlmICggY29sIDwgYy5jb2x1bW5zICkge1xuXG5cdFx0XHRcdFx0Ly8gc2V0IG9yZGVyIGlmIG5vdCBhbHJlYWR5IGRlZmluZWQgLSBkdWUgdG8gY29sc3BhbiBoZWFkZXIgd2l0aG91dCBhc3NvY2lhdGVkIGhlYWRlciBjZWxsXG5cdFx0XHRcdFx0Ly8gYWRkaW5nIHRoaXMgY2hlY2sgcHJldmVudHMgYSBqYXZhc2NyaXB0IGVycm9yXG5cdFx0XHRcdFx0aWYgKCAhYy5zb3J0VmFyc1sgY29sIF0ub3JkZXIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRzLmdldE9yZGVyKCBjLnNvcnRJbml0aWFsT3JkZXIgKSApIHtcblx0XHRcdFx0XHRcdFx0b3JkZXIgPSBjLnNvcnRSZXNldCA/IFsgMSwgMCwgMiBdIDogWyAxLCAwIF07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRvcmRlciA9IGMuc29ydFJlc2V0ID8gWyAwLCAxLCAyIF0gOiBbIDAsIDEgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLm9yZGVyID0gb3JkZXI7XG5cdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3JkZXIgPSBjLnNvcnRWYXJzWyBjb2wgXS5vcmRlcjtcblx0XHRcdFx0XHRkaXIgPSAoICcnICsgdmFsWyAxIF0gKS5tYXRjaCggL14oMXxkfHN8b3xuKS8gKTtcblx0XHRcdFx0XHRkaXIgPSBkaXIgPyBkaXJbIDAgXSA6ICcnO1xuXHRcdFx0XHRcdC8vIDAvKGEpc2MgKGRlZmF1bHQpLCAxLyhkKWVzYywgKHMpYW1lLCAobylwcG9zaXRlLCAobilleHRcblx0XHRcdFx0XHRzd2l0Y2ggKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRjYXNlICcxJyA6IGNhc2UgJ2QnIDogLy8gZGVzY2VuZGluZ1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3MnIDogLy8gc2FtZSBkaXJlY3Rpb24gKGFzIHByaW1hcnkgY29sdW1uKVxuXHRcdFx0XHRcdFx0XHQvLyBpZiBwcmltYXJ5IHNvcnQgaXMgc2V0IHRvICdzJywgbWFrZSBpdCBhc2NlbmRpbmdcblx0XHRcdFx0XHRcdFx0ZGlyID0gcHJpbWFyeSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ28nIDpcblx0XHRcdFx0XHRcdFx0dGVtcCA9IG9yZGVyWyAoIHByaW1hcnkgfHwgMCApICUgb3JkZXIubGVuZ3RoIF07XG5cdFx0XHRcdFx0XHRcdC8vIG9wcG9zaXRlIG9mIHByaW1hcnkgY29sdW1uOyBidXQgcmVzZXRzIGlmIHByaW1hcnkgcmVzZXRzXG5cdFx0XHRcdFx0XHRcdGRpciA9IHRlbXAgPT09IDAgPyAxIDogdGVtcCA9PT0gMSA/IDAgOiAyO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ24nIDpcblx0XHRcdFx0XHRcdFx0ZGlyID0gb3JkZXJbICggKytjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCApICUgb3JkZXIubGVuZ3RoIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdCA6IC8vIGFzY2VuZGluZ1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJpbWFyeSA9IGluZHggPT09IDAgPyBkaXIgOiBwcmltYXJ5O1xuXHRcdFx0XHRcdGdyb3VwID0gWyBjb2wsIHBhcnNlSW50KCBkaXIsIDEwICkgfHwgMCBdO1xuXHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBncm91cDtcblx0XHRcdFx0XHRkaXIgPSAkLmluQXJyYXkoIGdyb3VwWyAxIF0sIG9yZGVyICk7IC8vIGZpeGVzIGlzc3VlICMxNjdcblx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IGRpciA+PSAwID8gZGlyIDogZ3JvdXBbIDEgXSAlIG9yZGVyLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGVBbGwgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0YWJsZSA9IGMudGFibGU7XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdHRzLnJlZnJlc2hXaWRnZXRzKCB0YWJsZSwgdHJ1ZSwgdHJ1ZSApO1xuXHRcdFx0dHMuYnVpbGRIZWFkZXJzKCBjICk7XG5cdFx0XHR0cy5iaW5kRXZlbnRzKCB0YWJsZSwgYy4kaGVhZGVycywgdHJ1ZSApO1xuXHRcdFx0dHMuYmluZE1ldGhvZHMoIGMgKTtcblx0XHRcdHRzLmNvbW1vblVwZGF0ZSggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdH0sXG5cblx0XHR1cGRhdGUgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0YWJsZSA9IGMudGFibGU7XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHVwZGF0ZSBzb3J0aW5nIChpZiBlbmFibGVkL2Rpc2FibGVkKVxuXHRcdFx0dHMudXBkYXRlSGVhZGVyKCBjICk7XG5cdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHR9LFxuXG5cdFx0Ly8gc2ltcGxlIGhlYWRlciB1cGRhdGUgLSBzZWUgIzk4OVxuXHRcdHVwZGF0ZUhlYWRlcnMgOiBmdW5jdGlvbiggYywgY2FsbGJhY2sgKSB7XG5cdFx0XHRjLnRhYmxlLmlzVXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0dHMuYnVpbGRIZWFkZXJzKCBjICk7XG5cdFx0XHR0cy5iaW5kRXZlbnRzKCBjLnRhYmxlLCBjLiRoZWFkZXJzLCB0cnVlICk7XG5cdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlQ2VsbCA6IGZ1bmN0aW9uKCBjLCBjZWxsLCByZXNvcnQsIGNhbGxiYWNrICkge1xuXHRcdFx0Ly8gdXBkYXRlQ2VsbCBmb3IgY2hpbGQgcm93cyBpcyBhIG1lc3MgLSB3ZSdsbCBpZ25vcmUgdGhlbSBmb3Igbm93XG5cdFx0XHQvLyBldmVudHVhbGx5IEknbGwgYnJlYWsgb3V0IHRoZSBcInVwZGF0ZVwiIHJvdyBjYWNoZSBjb2RlIHRvIG1ha2UgZXZlcnl0aGluZyBjb25zaXN0ZW50XG5cdFx0XHRpZiAoICQoIGNlbGwgKS5jbG9zZXN0KCAndHInICkuaGFzQ2xhc3MoIGMuY3NzQ2hpbGRSb3cgKSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUYWJsZXNvcnRlciBXYXJuaW5nISBcInVwZGF0ZUNlbGxcIiBmb3IgY2hpbGQgcm93IGNvbnRlbnQgaGFzIGJlZW4gZGlzYWJsZWQsIHVzZSBcInVwZGF0ZVwiIGluc3RlYWQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjLmNhY2hlICkgKSB7XG5cdFx0XHRcdC8vIGVtcHR5IHRhYmxlLCBkbyBhbiB1cGRhdGUgaW5zdGVhZCAtIGZpeGVzICMxMDk5XG5cdFx0XHRcdHRzLnVwZGF0ZUhlYWRlciggYyApO1xuXHRcdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Yy50YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdGMuJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JSZW1vdmUgKS5yZW1vdmUoKTtcblx0XHRcdC8vIGdldCBwb3NpdGlvbiBmcm9tIHRoZSBkb21cblx0XHRcdHZhciB0bXAsIGluZHgsIHJvdywgaWNlbGwsIGNhY2hlLCBsZW4sXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0JGNlbGwgPSAkKCBjZWxsICksXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYWNoZSAtIGZvcm1hdDogZnVuY3Rpb24oIHMsIHRhYmxlLCBjZWxsLCBjZWxsSW5kZXggKVxuXHRcdFx0XHQvLyBubyBjbG9zZXN0IGluIGpRdWVyeSB2MS4yLjZcblx0XHRcdFx0dGJvZHlJbmRleCA9ICR0Ym9kaWVzLmluZGV4KCB0cy5nZXRDbG9zZXN0KCAkY2VsbCwgJ3Rib2R5JyApICksXG5cdFx0XHRcdHRiY2FjaGUgPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0sXG5cdFx0XHRcdCRyb3cgPSB0cy5nZXRDbG9zZXN0KCAkY2VsbCwgJ3RyJyApO1xuXHRcdFx0Y2VsbCA9ICRjZWxsWyAwIF07IC8vIGluIGNhc2UgY2VsbCBpcyBhIGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHRib2R5IG1heSBub3QgZXhpc3QgaWYgdXBkYXRlIGlzIGluaXRpYWxpemVkIHdoaWxlIHRib2R5IGlzIHJlbW92ZWQgZm9yIHByb2Nlc3Npbmdcblx0XHRcdGlmICggJHRib2RpZXMubGVuZ3RoICYmIHRib2R5SW5kZXggPj0gMCApIHtcblx0XHRcdFx0cm93ID0gJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKS5maW5kKCAndHInICkubm90KCAnLicgKyBjLmNzc0NoaWxkUm93ICkuaW5kZXgoICRyb3cgKTtcblx0XHRcdFx0Y2FjaGUgPSB0YmNhY2hlLm5vcm1hbGl6ZWRbIHJvdyBdO1xuXHRcdFx0XHRsZW4gPSAkcm93WyAwIF0uY2VsbHMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoIGxlbiAhPT0gYy5jb2x1bW5zICkge1xuXHRcdFx0XHRcdC8vIGNvbHNwYW4gaW4gaGVyZSBzb21ld2hlcmUhXG5cdFx0XHRcdFx0aWNlbGwgPSAwO1xuXHRcdFx0XHRcdHRtcCA9IGZhbHNlO1xuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICF0bXAgJiYgJHJvd1sgMCBdLmNlbGxzWyBpbmR4IF0gIT09IGNlbGwgKSB7XG5cdFx0XHRcdFx0XHRcdGljZWxsICs9ICRyb3dbIDAgXS5jZWxsc1sgaW5keCBdLmNvbFNwYW47XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpY2VsbCA9ICRjZWxsLmluZGV4KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wID0gdHMuZ2V0RWxlbWVudFRleHQoIGMsIGNlbGwsIGljZWxsICk7IC8vIHJhd1xuXHRcdFx0XHRjYWNoZVsgYy5jb2x1bW5zIF0ucmF3WyBpY2VsbCBdID0gdG1wO1xuXHRcdFx0XHR0bXAgPSB0cy5nZXRQYXJzZWRUZXh0KCBjLCBjZWxsLCBpY2VsbCwgdG1wICk7XG5cdFx0XHRcdGNhY2hlWyBpY2VsbCBdID0gdG1wOyAvLyBwYXJzZWRcblx0XHRcdFx0aWYgKCAoIGMucGFyc2Vyc1sgaWNlbGwgXS50eXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdC8vIHVwZGF0ZSBjb2x1bW4gbWF4IHZhbHVlIChpZ25vcmUgc2lnbilcblx0XHRcdFx0XHR0YmNhY2hlLmNvbE1heFsgaWNlbGwgXSA9IE1hdGgubWF4KCBNYXRoLmFicyggdG1wICkgfHwgMCwgdGJjYWNoZS5jb2xNYXhbIGljZWxsIF0gfHwgMCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcCA9IHJlc29ydCAhPT0gJ3VuZGVmaW5lZCcgPyByZXNvcnQgOiBjLnJlc29ydDtcblx0XHRcdFx0aWYgKCB0bXAgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIHdpZGdldHMgd2lsbCBiZSByZWFwcGxpZWRcblx0XHRcdFx0XHR0cy5jaGVja1Jlc29ydCggYywgdG1wLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGRvbid0IHJlYXBwbHkgd2lkZ2V0cyBpcyByZXNvcnQgaXMgZmFsc2UsIGp1c3QgaW4gY2FzZSBpdCBjYXVzZXNcblx0XHRcdFx0XHQvLyBwcm9ibGVtcyB3aXRoIGVsZW1lbnQgZm9jdXNcblx0XHRcdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICd1cGRhdGVDZWxsIGFib3J0ZWQsIHRib2R5IG1pc3Npbmcgb3Igbm90IHdpdGhpbiB0aGUgaW5kaWNhdGVkIHRhYmxlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMudGFibGUuaXNVcGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZGRSb3dzIDogZnVuY3Rpb24oIGMsICRyb3csIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdHh0LCB2YWwsIHRib2R5SW5kZXgsIHJvd0luZGV4LCByb3dzLCBjZWxsSW5kZXgsIGxlbiwgb3JkZXIsXG5cdFx0XHRcdGNhY2hlSW5kZXgsIHJvd0RhdGEsIGNlbGxzLCBjZWxsLCBzcGFuLFxuXHRcdFx0XHQvLyBhbGxvdyBwYXNzaW5nIGEgcm93IHN0cmluZyBpZiBvbmx5IG9uZSBub24taW5mbyB0Ym9keSBleGlzdHMgaW4gdGhlIHRhYmxlXG5cdFx0XHRcdHZhbGlkID0gdHlwZW9mICRyb3cgPT09ICdzdHJpbmcnICYmIGMuJHRib2RpZXMubGVuZ3RoID09PSAxICYmIC88dHIvLnRlc3QoICRyb3cgfHwgJycgKSxcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlO1xuXHRcdFx0aWYgKCB2YWxpZCApIHtcblx0XHRcdFx0JHJvdyA9ICQoICRyb3cgKTtcblx0XHRcdFx0Yy4kdGJvZGllcy5hcHBlbmQoICRyb3cgKTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdCEkcm93IHx8XG5cdFx0XHRcdC8vIHJvdyBpcyBhIGpRdWVyeSBvYmplY3Q/XG5cdFx0XHRcdCEoICRyb3cgaW5zdGFuY2VvZiAkICkgfHxcblx0XHRcdFx0Ly8gcm93IGNvbnRhaW5lZCBpbiB0aGUgdGFibGU/XG5cdFx0XHRcdCggdHMuZ2V0Q2xvc2VzdCggJHJvdywgJ3RhYmxlJyApWyAwIF0gIT09IGMudGFibGUgKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnYWRkUm93cyBtZXRob2QgcmVxdWlyZXMgKDEpIGEgalF1ZXJ5IHNlbGVjdG9yIHJlZmVyZW5jZSB0byByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5ICcgK1xuXHRcdFx0XHRcdFx0J2JlZW4gYWRkZWQgdG8gdGhlIHRhYmxlLCBvciAoMikgcm93IEhUTUwgc3RyaW5nIHRvIGJlIGFkZGVkIHRvIGEgdGFibGUgd2l0aCBvbmx5IG9uZSB0Ym9keScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdGlmICggdHMuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICkge1xuXHRcdFx0XHQvLyBlbXB0eSB0YWJsZSwgZG8gYW4gdXBkYXRlIGluc3RlYWQgLSBmaXhlcyAjNDUwXG5cdFx0XHRcdHRzLnVwZGF0ZUhlYWRlciggYyApO1xuXHRcdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJvd3MgPSAkcm93LmZpbHRlciggJ3RyJyApLmF0dHIoICdyb2xlJywgJ3JvdycgKS5sZW5ndGg7XG5cdFx0XHRcdHRib2R5SW5kZXggPSBjLiR0Ym9kaWVzLmluZGV4KCAkcm93LnBhcmVudHMoICd0Ym9keScgKS5maWx0ZXIoICc6Zmlyc3QnICkgKTtcblx0XHRcdFx0Ly8gZml4ZXMgYWRkaW5nIHJvd3MgdG8gYW4gZW1wdHkgdGFibGUgLSBzZWUgaXNzdWUgIzE3OVxuXHRcdFx0XHRpZiAoICEoIGMucGFyc2VycyAmJiBjLnBhcnNlcnMubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0dHMuc2V0dXBQYXJzZXJzKCBjICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIGVhY2ggcm93XG5cdFx0XHRcdGZvciAoIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dzOyByb3dJbmRleCsrICkge1xuXHRcdFx0XHRcdGNhY2hlSW5kZXggPSAwO1xuXHRcdFx0XHRcdGxlbiA9ICRyb3dbIHJvd0luZGV4IF0uY2VsbHMubGVuZ3RoO1xuXHRcdFx0XHRcdG9yZGVyID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWQubGVuZ3RoO1xuXHRcdFx0XHRcdGNlbGxzID0gW107XG5cdFx0XHRcdFx0cm93RGF0YSA9IHtcblx0XHRcdFx0XHRcdGNoaWxkIDogW10sXG5cdFx0XHRcdFx0XHRyYXcgOiBbXSxcblx0XHRcdFx0XHRcdCRyb3cgOiAkcm93LmVxKCByb3dJbmRleCApLFxuXHRcdFx0XHRcdFx0b3JkZXIgOiBvcmRlclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gYWRkIGVhY2ggY2VsbFxuXHRcdFx0XHRcdGZvciAoIGNlbGxJbmRleCA9IDA7IGNlbGxJbmRleCA8IGxlbjsgY2VsbEluZGV4KysgKSB7XG5cdFx0XHRcdFx0XHRjZWxsID0gJHJvd1sgcm93SW5kZXggXS5jZWxsc1sgY2VsbEluZGV4IF07XG5cdFx0XHRcdFx0XHR0eHQgPSB0cy5nZXRFbGVtZW50VGV4dCggYywgY2VsbCwgY2FjaGVJbmRleCApO1xuXHRcdFx0XHRcdFx0cm93RGF0YS5yYXdbIGNhY2hlSW5kZXggXSA9IHR4dDtcblx0XHRcdFx0XHRcdHZhbCA9IHRzLmdldFBhcnNlZFRleHQoIGMsIGNlbGwsIGNhY2hlSW5kZXgsIHR4dCApO1xuXHRcdFx0XHRcdFx0Y2VsbHNbIGNhY2hlSW5kZXggXSA9IHZhbDtcblx0XHRcdFx0XHRcdGlmICggKCBjLnBhcnNlcnNbIGNhY2hlSW5kZXggXS50eXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdFx0XHQvLyB1cGRhdGUgY29sdW1uIG1heCB2YWx1ZSAoaWdub3JlIHNpZ24pXG5cdFx0XHRcdFx0XHRcdGMuY2FjaGVbIHRib2R5SW5kZXggXS5jb2xNYXhbIGNhY2hlSW5kZXggXSA9XG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoIE1hdGguYWJzKCB2YWwgKSB8fCAwLCBjLmNhY2hlWyB0Ym9keUluZGV4IF0uY29sTWF4WyBjYWNoZUluZGV4IF0gfHwgMCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3BhbiA9IGNlbGwuY29sU3BhbiAtIDE7XG5cdFx0XHRcdFx0XHRpZiAoIHNwYW4gPiAwICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZUluZGV4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWNoZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFkZCB0aGUgcm93IGRhdGEgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNlbGxzWyBjLmNvbHVtbnMgXSA9IHJvd0RhdGE7XG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGNhY2hlXG5cdFx0XHRcdFx0Yy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWRbIG9yZGVyIF0gPSBjZWxscztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXNvcnQgdXNpbmcgY3VycmVudCBzZXR0aW5nc1xuXHRcdFx0XHR0cy5jaGVja1Jlc29ydCggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGVDYWNoZSA6IGZ1bmN0aW9uKCBjLCBjYWxsYmFjaywgJHRib2RpZXMgKSB7XG5cdFx0XHQvLyByZWJ1aWxkIHBhcnNlcnNcblx0XHRcdGlmICggISggYy5wYXJzZXJzICYmIGMucGFyc2Vycy5sZW5ndGggKSApIHtcblx0XHRcdFx0dHMuc2V0dXBQYXJzZXJzKCBjLCAkdGJvZGllcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVidWlsZCB0aGUgY2FjaGUgbWFwXG5cdFx0XHR0cy5idWlsZENhY2hlKCBjLCBjYWxsYmFjaywgJHRib2RpZXMgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaW5pdCBmbGFnICh0cnVlKSB1c2VkIGJ5IHBhZ2VyIHBsdWdpbiB0byBwcmV2ZW50IHdpZGdldCBhcHBsaWNhdGlvblxuXHRcdC8vIHJlbmFtZWQgZnJvbSBhcHBlbmRUb1RhYmxlXG5cdFx0YXBwZW5kQ2FjaGUgOiBmdW5jdGlvbiggYywgaW5pdCApIHtcblx0XHRcdHZhciBwYXJzZWQsIHRvdGFsUm93cywgJHRib2R5LCAkY3VyVGJvZHksIHJvd0luZGV4LCB0Ym9keUluZGV4LCBhcHBlbmRUaW1lLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0cm93cyA9IFtdLFxuXHRcdFx0XHRjYWNoZSA9IGMuY2FjaGU7XG5cdFx0XHQvLyBlbXB0eSB0YWJsZSAtIGZpeGVzICMyMDYvIzM0NlxuXHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHQvLyBydW4gcGFnZXIgYXBwZW5kZXIgaW4gY2FzZSB0aGUgdGFibGUgd2FzIGp1c3QgZW1wdGllZFxuXHRcdFx0XHRyZXR1cm4gYy5hcHBlbmRlciA/IGMuYXBwZW5kZXIoIHRhYmxlLCByb3dzICkgOlxuXHRcdFx0XHRcdHRhYmxlLmlzVXBkYXRpbmcgPyBjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3VwZGF0ZUNvbXBsZXRlJywgdGFibGUgKSA6ICcnOyAvLyBGaXhlcyAjNTMyXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGFwcGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0JHRib2R5ID0gJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKTtcblx0XHRcdFx0aWYgKCAkdGJvZHkubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGRldGFjaCB0Ym9keSBmb3IgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdFx0JGN1clRib2R5ID0gdHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJHRib2R5LCB0cnVlICk7XG5cdFx0XHRcdFx0cGFyc2VkID0gY2FjaGVbIHRib2R5SW5kZXggXS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdHRvdGFsUm93cyA9IHBhcnNlZC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRvdGFsUm93czsgcm93SW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdHJvd3Nbcm93cy5sZW5ndGhdID0gcGFyc2VkWyByb3dJbmRleCBdWyBjLmNvbHVtbnMgXS4kcm93O1xuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlUm93cyB1c2VkIGJ5IHRoZSBwYWdlciBwbHVnaW47IGRvbid0IHJlbmRlciBpZiB1c2luZyBhamF4IC0gZml4ZXMgIzQxMVxuXHRcdFx0XHRcdFx0aWYgKCAhYy5hcHBlbmRlciB8fCAoIGMucGFnZXIgJiYgIWMucGFnZXIucmVtb3ZlUm93cyAmJiAhYy5wYWdlci5hamF4ICkgKSB7XG5cdFx0XHRcdFx0XHRcdCRjdXJUYm9keS5hcHBlbmQoIHBhcnNlZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvdyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyByZXN0b3JlIHRib2R5XG5cdFx0XHRcdFx0dHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJGN1clRib2R5LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGMuYXBwZW5kZXIgKSB7XG5cdFx0XHRcdGMuYXBwZW5kZXIoIHRhYmxlLCByb3dzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnUmVidWlsdCB0YWJsZScgKyB0cy5iZW5jaG1hcmsoIGFwcGVuZFRpbWUgKSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXBwbHkgdGFibGUgd2lkZ2V0czsgYnV0IG5vdCBiZWZvcmUgYWpheCBjb21wbGV0ZXNcblx0XHRcdGlmICggIWluaXQgJiYgIWMuYXBwZW5kZXIgKSB7XG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YWJsZS5pc1VwZGF0aW5nICkge1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3VwZGF0ZUNvbXBsZXRlJywgdGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y29tbW9uVXBkYXRlIDogZnVuY3Rpb24oIGMsIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHQvLyByZW1vdmUgcm93cy9lbGVtZW50cyBiZWZvcmUgdXBkYXRlXG5cdFx0XHRjLiR0YWJsZS5maW5kKCBjLnNlbGVjdG9yUmVtb3ZlICkucmVtb3ZlKCk7XG5cdFx0XHQvLyByZWJ1aWxkIHBhcnNlcnNcblx0XHRcdHRzLnNldHVwUGFyc2VycyggYyApO1xuXHRcdFx0Ly8gcmVidWlsZCB0aGUgY2FjaGUgbWFwXG5cdFx0XHR0cy5idWlsZENhY2hlKCBjICk7XG5cdFx0XHR0cy5jaGVja1Jlc29ydCggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdOKWhOKWiOKWiOKWiOKWiOKWiCDiloTilojilojilojilojiloQg4paI4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilogg4paI4paI4paI4paI4paI4paEIOKWhOKWiOKWiOKWiOKWiOKWhFxuXHRcdOKWgOKWiOKWhCAgICDilojiloggIOKWiOKWiCDilojilojiloTiloTilojiloggICDilojiloggICDilojilogg4paI4paIICDilojilogg4paI4paIIOKWhOKWhOKWhFxuXHRcdCAgIOKWgOKWiOKWhCDilojiloggIOKWiOKWiCDilojilojiloDilojiloggICAg4paI4paIICAg4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiCDiloDilojilohcblx0XHTilojilojilojilojilojiloAg4paA4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiCAg4paI4paIIOKWgOKWiOKWiOKWiOKWiOKWgFxuXHRcdCovXG5cdFx0aW5pdFNvcnQgOiBmdW5jdGlvbiggYywgY2VsbCwgZXZlbnQgKSB7XG5cdFx0XHRpZiAoIGMudGFibGUuaXNVcGRhdGluZyApIHtcblx0XHRcdFx0Ly8gbGV0IGFueSB1cGRhdGVzIGNvbXBsZXRlIGJlZm9yZSBpbml0aWFsaXppbmcgYSBzb3J0XG5cdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cy5pbml0U29ydCggYywgY2VsbCwgZXZlbnQgKTtcblx0XHRcdFx0fSwgNTAgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFycnksIGluZHgsIGhlYWRlckluZHgsIGRpciwgdGVtcCwgdG1wLCAkaGVhZGVyLFxuXHRcdFx0XHRub3RNdWx0aVNvcnQgPSAhZXZlbnRbIGMuc29ydE11bHRpU29ydEtleSBdLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdGxlbiA9IGMuJGhlYWRlcnMubGVuZ3RoLFxuXHRcdFx0XHR0aCA9IHRzLmdldENsb3Nlc3QoICQoIGNlbGwgKSwgJ3RoLCB0ZCcgKSxcblx0XHRcdFx0Y29sID0gcGFyc2VJbnQoIHRoLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKSxcblx0XHRcdFx0c29ydGVkQnkgPSBldmVudC50eXBlID09PSAnbW91c2V1cCcgPyAndXNlcicgOiBldmVudC50eXBlLFxuXHRcdFx0XHRvcmRlciA9IGMuc29ydFZhcnNbIGNvbCBdLm9yZGVyO1xuXHRcdFx0dGggPSB0aFswXTtcblx0XHRcdC8vIE9ubHkgY2FsbCBzb3J0U3RhcnQgaWYgc29ydGluZyBpcyBlbmFibGVkXG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3NvcnRTdGFydCcsIHRhYmxlICk7XG5cdFx0XHQvLyBnZXQgY3VycmVudCBjb2x1bW4gc29ydCBvcmRlclxuXHRcdFx0dG1wID0gKCBjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCArIDEgKSAlIG9yZGVyLmxlbmd0aDtcblx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLmNvdW50ID0gZXZlbnRbIGMuc29ydFJlc2V0S2V5IF0gPyAyIDogdG1wO1xuXHRcdFx0Ly8gcmVzZXQgYWxsIHNvcnRzIG9uIG5vbi1jdXJyZW50IGNvbHVtbiAtIGlzc3VlICMzMFxuXHRcdFx0aWYgKCBjLnNvcnRSZXN0YXJ0ICkge1xuXHRcdFx0XHRmb3IgKCBoZWFkZXJJbmR4ID0gMDsgaGVhZGVySW5keCA8IGxlbjsgaGVhZGVySW5keCsrICkge1xuXHRcdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzLmVxKCBoZWFkZXJJbmR4ICk7XG5cdFx0XHRcdFx0dG1wID0gcGFyc2VJbnQoICRoZWFkZXIuYXR0ciggJ2RhdGEtY29sdW1uJyApLCAxMCApO1xuXHRcdFx0XHRcdC8vIG9ubHkgcmVzZXQgY291bnRzIG9uIGNvbHVtbnMgdGhhdCB3ZXJlbid0IGp1c3QgY2xpY2tlZCBvbiBhbmQgaWYgbm90IGluY2x1ZGVkIGluIGEgbXVsdGlzb3J0XG5cdFx0XHRcdFx0aWYgKCBjb2wgIT09IHRtcCAmJiAoIG5vdE11bHRpU29ydCB8fCAkaGVhZGVyLmhhc0NsYXNzKCB0cy5jc3Muc29ydE5vbmUgKSApICkge1xuXHRcdFx0XHRcdFx0Yy5zb3J0VmFyc1sgdG1wIF0uY291bnQgPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHVzZXIgb25seSB3YW50cyB0byBzb3J0IG9uIG9uZSBjb2x1bW5cblx0XHRcdGlmICggbm90TXVsdGlTb3J0ICkge1xuXHRcdFx0XHQkLmVhY2goIGMuc29ydFZhcnMsIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGkgXS5zb3J0ZWRCeSA9ICcnO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gZmx1c2ggdGhlIHNvcnQgbGlzdFxuXHRcdFx0XHRjLnNvcnRMaXN0ID0gW107XG5cdFx0XHRcdGMubGFzdC5zb3J0TGlzdCA9IFtdO1xuXHRcdFx0XHRpZiAoIGMuc29ydEZvcmNlICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGFycnkgPSBjLnNvcnRGb3JjZTtcblx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGFycnkubGVuZ3RoOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGFycnlbIGluZHggXVsgMCBdICE9PSBjb2wgKSB7XG5cdFx0XHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBhcnJ5WyBpbmR4IF07XG5cdFx0XHRcdFx0XHRcdGMuc29ydFZhcnNbIGFycnlbIGluZHggXVsgMCBdIF0uc29ydGVkQnkgPSAnc29ydEZvcmNlJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIGNvbHVtbiB0byBzb3J0IGxpc3Rcblx0XHRcdFx0ZGlyID0gb3JkZXJbIGMuc29ydFZhcnNbIGNvbCBdLmNvdW50IF07XG5cdFx0XHRcdGlmICggZGlyIDwgMiApIHtcblx0XHRcdFx0XHRjLnNvcnRMaXN0WyBjLnNvcnRMaXN0Lmxlbmd0aCBdID0gWyBjb2wsIGRpciBdO1xuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLnNvcnRlZEJ5ID0gc29ydGVkQnk7XG5cdFx0XHRcdFx0Ly8gYWRkIG90aGVyIGNvbHVtbnMgaWYgaGVhZGVyIHNwYW5zIGFjcm9zcyBtdWx0aXBsZVxuXHRcdFx0XHRcdGlmICggdGguY29sU3BhbiA+IDEgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMTsgaW5keCA8IHRoLmNvbFNwYW47IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgY29sICsgaW5keCwgZGlyIF07XG5cdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBjb3VudCBvbiBjb2x1bW5zIGluIGNvbFNwYW5cblx0XHRcdFx0XHRcdFx0Yy5zb3J0VmFyc1sgY29sICsgaW5keCBdLmNvdW50ID0gJC5pbkFycmF5KCBkaXIsIG9yZGVyICk7XG5cdFx0XHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCArIGluZHggXS5zb3J0ZWRCeSA9IHNvcnRlZEJ5O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtdWx0aSBjb2x1bW4gc29ydGluZ1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2V0IHJpZCBvZiB0aGUgc29ydEFwcGVuZCBiZWZvcmUgYWRkaW5nIG1vcmUgLSBmaXhlcyBpc3N1ZSAjMTE1ICYgIzUyM1xuXHRcdFx0XHRjLnNvcnRMaXN0ID0gJC5leHRlbmQoIFtdLCBjLmxhc3Quc29ydExpc3QgKTtcblxuXHRcdFx0XHQvLyB0aGUgdXNlciBoYXMgY2xpY2tlZCBvbiBhbiBhbHJlYWR5IHNvcnRlZCBjb2x1bW5cblx0XHRcdFx0aWYgKCB0cy5pc1ZhbHVlSW5BcnJheSggY29sLCBjLnNvcnRMaXN0ICkgPj0gMCApIHtcblx0XHRcdFx0XHQvLyByZXZlcnNlIHRoZSBzb3J0aW5nIGRpcmVjdGlvblxuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLnNvcnRlZEJ5ID0gc29ydGVkQnk7XG5cdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjLnNvcnRMaXN0Lmxlbmd0aDsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0dG1wID0gYy5zb3J0TGlzdFsgaW5keCBdO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDAgXSA9PT0gY29sICkge1xuXHRcdFx0XHRcdFx0XHQvLyBvcmRlci5jb3VudCBzZWVtcyB0byBiZSBpbmNvcnJlY3Qgd2hlbiBjb21wYXJlZCB0byBjZWxsLmNvdW50XG5cdFx0XHRcdFx0XHRcdHRtcFsgMSBdID0gb3JkZXJbIGMuc29ydFZhcnNbIGNvbCBdLmNvdW50IF07XG5cdFx0XHRcdFx0XHRcdGlmICggdG1wWzFdID09PSAyICkge1xuXHRcdFx0XHRcdFx0XHRcdGMuc29ydExpc3Quc3BsaWNlKCBpbmR4LCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0Yy5zb3J0VmFyc1sgY29sIF0uY291bnQgPSAtMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBhZGQgY29sdW1uIHRvIHNvcnQgbGlzdCBhcnJheVxuXHRcdFx0XHRcdGRpciA9IG9yZGVyWyBjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCBdO1xuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLnNvcnRlZEJ5ID0gc29ydGVkQnk7XG5cdFx0XHRcdFx0aWYgKCBkaXIgPCAyICkge1xuXHRcdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgY29sLCBkaXIgXTtcblx0XHRcdFx0XHRcdC8vIGFkZCBvdGhlciBjb2x1bW5zIGlmIGhlYWRlciBzcGFucyBhY3Jvc3MgbXVsdGlwbGVcblx0XHRcdFx0XHRcdGlmICggdGguY29sU3BhbiA+IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAxOyBpbmR4IDwgdGguY29sU3BhbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBbIGNvbCArIGluZHgsIGRpciBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBjb3VudCBvbiBjb2x1bW5zIGluIGNvbFNwYW5cblx0XHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgKyBpbmR4IF0uY291bnQgPSAkLmluQXJyYXkoIGRpciwgb3JkZXIgKTtcblx0XHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgKyBpbmR4IF0uc29ydGVkQnkgPSBzb3J0ZWRCeTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2F2ZSBzb3J0IGJlZm9yZSBhcHBseWluZyBzb3J0QXBwZW5kXG5cdFx0XHRjLmxhc3Quc29ydExpc3QgPSAkLmV4dGVuZCggW10sIGMuc29ydExpc3QgKTtcblx0XHRcdGlmICggYy5zb3J0TGlzdC5sZW5ndGggJiYgYy5zb3J0QXBwZW5kICkge1xuXHRcdFx0XHRhcnJ5ID0gJC5pc0FycmF5KCBjLnNvcnRBcHBlbmQgKSA/IGMuc29ydEFwcGVuZCA6IGMuc29ydEFwcGVuZFsgYy5zb3J0TGlzdFsgMCBdWyAwIF0gXTtcblx0XHRcdFx0aWYgKCAhdHMuaXNFbXB0eU9iamVjdCggYXJyeSApICkge1xuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgYXJyeS5sZW5ndGg7IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdGlmICggYXJyeVsgaW5keCBdWyAwIF0gIT09IGNvbCAmJiB0cy5pc1ZhbHVlSW5BcnJheSggYXJyeVsgaW5keCBdWyAwIF0sIGMuc29ydExpc3QgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGRpciA9IGFycnlbIGluZHggXVsgMSBdO1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gKCAnJyArIGRpciApLm1hdGNoKCAvXihhfGR8c3xvfG4pLyApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlbXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wID0gYy5zb3J0TGlzdFsgMCBdWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggdGVtcFsgMCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZCcgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3MnIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ28nIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gdG1wID09PSAwID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbicgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAoIHRtcCArIDEgKSAlIG9yZGVyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgYXJyeVsgaW5keCBdWyAwIF0sIGRpciBdO1xuXHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBhcnJ5WyBpbmR4IF1bIDAgXSBdLnNvcnRlZEJ5ID0gJ3NvcnRBcHBlbmQnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc29ydEJlZ2luIGV2ZW50IHRyaWdnZXJlZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHNvcnRcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEJlZ2luJywgdGFibGUgKTtcblx0XHRcdC8vIHNldFRpbWVvdXQgbmVlZGVkIHNvIHRoZSBwcm9jZXNzaW5nIGljb24gc2hvd3MgdXBcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBzZXQgY3NzIGZvciBoZWFkZXJzXG5cdFx0XHRcdHRzLnNldEhlYWRlcnNDc3MoIGMgKTtcblx0XHRcdFx0dHMubXVsdGlzb3J0KCBjICk7XG5cdFx0XHRcdHRzLmFwcGVuZENhY2hlKCBjICk7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEJlZm9yZUVuZCcsIHRhYmxlICk7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEVuZCcsIHRhYmxlICk7XG5cdFx0XHR9LCAxICk7XG5cdFx0fSxcblxuXHRcdC8vIHNvcnQgbXVsdGlwbGUgY29sdW1uc1xuXHRcdG11bHRpc29ydCA6IGZ1bmN0aW9uKCBjICkgeyAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG5cdFx0XHR2YXIgdGJvZHlJbmRleCwgc29ydFRpbWUsIGNvbE1heCwgcm93cywgdG1wLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdHNvcnRlciA9IFtdLFxuXHRcdFx0XHRkaXIgPSAwLFxuXHRcdFx0XHR0ZXh0U29ydGVyID0gYy50ZXh0U29ydGVyIHx8ICcnLFxuXHRcdFx0XHRzb3J0TGlzdCA9IGMuc29ydExpc3QsXG5cdFx0XHRcdHNvcnRMZW4gPSBzb3J0TGlzdC5sZW5ndGgsXG5cdFx0XHRcdGxlbiA9IGMuJHRib2RpZXMubGVuZ3RoO1xuXHRcdFx0aWYgKCBjLnNlcnZlclNpZGVTb3J0aW5nIHx8IHRzLmlzRW1wdHlPYmplY3QoIGMuY2FjaGUgKSApIHtcblx0XHRcdFx0Ly8gZW1wdHkgdGFibGUgLSBmaXhlcyAjMjA2LyMzNDZcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkgeyBzb3J0VGltZSA9IG5ldyBEYXRlKCk7IH1cblx0XHRcdC8vIGNhY2hlIHRleHRTb3J0ZXIgdG8gb3B0aW1pemUgc3BlZWRcblx0XHRcdGlmICggdHlwZW9mIHRleHRTb3J0ZXIgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRjb2xNYXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdHdoaWxlICggY29sTWF4LS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHRleHRTb3J0ZXIsIGNvbE1heCApO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRtcCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdHNvcnRlclsgY29sTWF4IF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8IGxlbjsgdGJvZHlJbmRleCsrICkge1xuXHRcdFx0XHRjb2xNYXggPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0uY29sTWF4O1xuXHRcdFx0XHRyb3dzID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWQ7XG5cblx0XHRcdFx0cm93cy5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0XHR2YXIgc29ydEluZGV4LCBudW0sIGNvbCwgb3JkZXIsIHNvcnQsIHgsIHk7XG5cdFx0XHRcdFx0Ly8gcm93cyBpcyB1bmRlZmluZWQgaGVyZSBpbiBJRSwgc28gZG9uJ3QgdXNlIGl0IVxuXHRcdFx0XHRcdGZvciAoIHNvcnRJbmRleCA9IDA7IHNvcnRJbmRleCA8IHNvcnRMZW47IHNvcnRJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0Y29sID0gc29ydExpc3RbIHNvcnRJbmRleCBdWyAwIF07XG5cdFx0XHRcdFx0XHRvcmRlciA9IHNvcnRMaXN0WyBzb3J0SW5kZXggXVsgMSBdO1xuXHRcdFx0XHRcdFx0Ly8gc29ydCBkaXJlY3Rpb24sIHRydWUgPSBhc2MsIGZhbHNlID0gZGVzY1xuXHRcdFx0XHRcdFx0ZGlyID0gb3JkZXIgPT09IDA7XG5cblx0XHRcdFx0XHRcdGlmICggYy5zb3J0U3RhYmxlICYmIGFbIGNvbCBdID09PSBiWyBjb2wgXSAmJiBzb3J0TGVuID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYVsgYy5jb2x1bW5zIF0ub3JkZXIgLSBiWyBjLmNvbHVtbnMgXS5vcmRlcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gbmF0dXJhbCBzb3J0IHNpbmNlIGl0IGlzIG1vcmUgcm9idXN0XG5cdFx0XHRcdFx0XHRudW0gPSAvbi9pLnRlc3QoIHRzLmdldFNvcnRUeXBlKCBjLnBhcnNlcnMsIGNvbCApICk7XG5cdFx0XHRcdFx0XHRpZiAoIG51bSAmJiBjLnN0cmluZ3NbIGNvbCBdICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzb3J0IHN0cmluZ3MgaW4gbnVtZXJpY2FsIGNvbHVtbnNcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgKCB0cy5zdHJpbmdbIGMuc3RyaW5nc1sgY29sIF0gXSApID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bnVtID0gKCBkaXIgPyAxIDogLTEgKSAqICggdHMuc3RyaW5nWyBjLnN0cmluZ3NbIGNvbCBdIF0gPyAtMSA6IDEgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRudW0gPSAoIGMuc3RyaW5nc1sgY29sIF0gKSA/IHRzLnN0cmluZ1sgYy5zdHJpbmdzWyBjb2wgXSBdIHx8IDAgOiAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGZhbGwgYmFjayB0byBidWlsdC1pbiBudW1lcmljIHNvcnRcblx0XHRcdFx0XHRcdFx0Ly8gdmFyIHNvcnQgPSAkLnRhYmxlc29ydGVyWydzb3J0JyArIHNdKCBhW2NvbF0sIGJbY29sXSwgZGlyLCBjb2xNYXhbY29sXSwgdGFibGUgKTtcblx0XHRcdFx0XHRcdFx0c29ydCA9IGMubnVtYmVyU29ydGVyID8gYy5udW1iZXJTb3J0ZXIoIGFbIGNvbCBdLCBiWyBjb2wgXSwgZGlyLCBjb2xNYXhbIGNvbCBdLCB0YWJsZSApIDpcblx0XHRcdFx0XHRcdFx0XHR0c1sgJ3NvcnROdW1lcmljJyArICggZGlyID8gJ0FzYycgOiAnRGVzYycgKSBdKCBhWyBjb2wgXSwgYlsgY29sIF0sIG51bSwgY29sTWF4WyBjb2wgXSwgY29sLCBjICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBzZXQgYSAmIGIgZGVwZW5kaW5nIG9uIHNvcnQgZGlyZWN0aW9uXG5cdFx0XHRcdFx0XHRcdHggPSBkaXIgPyBhIDogYjtcblx0XHRcdFx0XHRcdFx0eSA9IGRpciA/IGIgOiBhO1xuXHRcdFx0XHRcdFx0XHQvLyB0ZXh0IHNvcnQgZnVuY3Rpb25cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdGV4dFNvcnRlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjdXN0b20gT1ZFUkFMTCB0ZXh0IHNvcnRlclxuXHRcdFx0XHRcdFx0XHRcdHNvcnQgPSB0ZXh0U29ydGVyKCB4WyBjb2wgXSwgeVsgY29sIF0sIGRpciwgY29sLCB0YWJsZSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygc29ydGVyWyBjb2wgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjdXN0b20gdGV4dCBzb3J0ZXIgZm9yIGEgU1BFQ0lGSUMgQ09MVU1OXG5cdFx0XHRcdFx0XHRcdFx0c29ydCA9IHNvcnRlclsgY29sIF0oIHhbIGNvbCBdLCB5WyBjb2wgXSwgZGlyLCBjb2wsIHRhYmxlICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZmFsbCBiYWNrIHRvIG5hdHVyYWwgc29ydFxuXHRcdFx0XHRcdFx0XHRcdHNvcnQgPSB0c1sgJ3NvcnROYXR1cmFsJyArICggZGlyID8gJ0FzYycgOiAnRGVzYycgKSBdKCBhWyBjb2wgXSB8fCAnJywgYlsgY29sIF0gfHwgJycsIGNvbCwgYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHNvcnQgKSB7IHJldHVybiBzb3J0OyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhWyBjLmNvbHVtbnMgXS5vcmRlciAtIGJbIGMuY29sdW1ucyBdLm9yZGVyO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coICdBcHBseWluZyBzb3J0ICcgKyBzb3J0TGlzdC50b1N0cmluZygpICsgdHMuYmVuY2htYXJrKCBzb3J0VGltZSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlc29ydENvbXBsZXRlIDogZnVuY3Rpb24oIGMsIGNhbGxiYWNrICkge1xuXHRcdFx0aWYgKCBjLnRhYmxlLmlzVXBkYXRpbmcgKSB7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAndXBkYXRlQ29tcGxldGUnLCBjLnRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApIHtcblx0XHRcdFx0Y2FsbGJhY2soIGMudGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2hlY2tSZXNvcnQgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBzb3J0TGlzdCA9ICQuaXNBcnJheSggcmVzb3J0ICkgPyByZXNvcnQgOiBjLnNvcnRMaXN0LFxuXHRcdFx0XHQvLyBpZiBubyByZXNvcnQgcGFyYW1ldGVyIGlzIHBhc3NlZCwgZmFsbGJhY2sgdG8gY29uZmlnLnJlc29ydCAodHJ1ZSBieSBkZWZhdWx0KVxuXHRcdFx0XHRyZXNydCA9IHR5cGVvZiByZXNvcnQgPT09ICd1bmRlZmluZWQnID8gYy5yZXNvcnQgOiByZXNvcnQ7XG5cdFx0XHQvLyBkb24ndCB0cnkgdG8gcmVzb3J0IGlmIHRoZSB0YWJsZSBpcyBzdGlsbCBwcm9jZXNzaW5nXG5cdFx0XHQvLyB0aGlzIHdpbGwgY2F0Y2ggc3BhbW1pbmcgb2YgdGhlIHVwZGF0ZUNlbGwgbWV0aG9kXG5cdFx0XHRpZiAoIHJlc3J0ICE9PSBmYWxzZSAmJiAhYy5zZXJ2ZXJTaWRlU29ydGluZyAmJiAhYy50YWJsZS5pc1Byb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdGlmICggc29ydExpc3QubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRzLnNvcnRPbiggYywgc29ydExpc3QsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dHMucmVzb3J0Q29tcGxldGUoIGMsIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRzLnNvcnRSZXNldCggYywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCBjLnRhYmxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHMucmVzb3J0Q29tcGxldGUoIGMsIGNhbGxiYWNrICk7XG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCBjLnRhYmxlLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzb3J0T24gOiBmdW5jdGlvbiggYywgbGlzdCwgY2FsbGJhY2ssIGluaXQgKSB7XG5cdFx0XHR2YXIgaW5keCxcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlO1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzb3J0U3RhcnQnLCB0YWJsZSApO1xuXHRcdFx0Zm9yIChpbmR4ID0gMDsgaW5keCA8IGMuY29sdW1uczsgaW5keCsrKSB7XG5cdFx0XHRcdGMuc29ydFZhcnNbIGluZHggXS5zb3J0ZWRCeSA9IHRzLmlzVmFsdWVJbkFycmF5KCBpbmR4LCBsaXN0ICkgPiAtMSA/ICdzb3J0b24nIDogJyc7XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgaGVhZGVyIGNvdW50IGluZGV4XG5cdFx0XHR0cy51cGRhdGVIZWFkZXJTb3J0Q291bnQoIGMsIGxpc3QgKTtcblx0XHRcdC8vIHNldCBjc3MgZm9yIGhlYWRlcnNcblx0XHRcdHRzLnNldEhlYWRlcnNDc3MoIGMgKTtcblx0XHRcdC8vIGZpeGVzICMzNDZcblx0XHRcdGlmICggYy5kZWxheUluaXQgJiYgdHMuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICkge1xuXHRcdFx0XHR0cy5idWlsZENhY2hlKCBjICk7XG5cdFx0XHR9XG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3NvcnRCZWdpbicsIHRhYmxlICk7XG5cdFx0XHQvLyBzb3J0IHRoZSB0YWJsZSBhbmQgYXBwZW5kIGl0IHRvIHRoZSBkb21cblx0XHRcdHRzLm11bHRpc29ydCggYyApO1xuXHRcdFx0dHMuYXBwZW5kQ2FjaGUoIGMsIGluaXQgKTtcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEJlZm9yZUVuZCcsIHRhYmxlICk7XG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3NvcnRFbmQnLCB0YWJsZSApO1xuXHRcdFx0dHMuYXBwbHlXaWRnZXQoIHRhYmxlICk7XG5cdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApIHtcblx0XHRcdFx0Y2FsbGJhY2soIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNvcnRSZXNldCA6IGZ1bmN0aW9uKCBjLCBjYWxsYmFjayApIHtcblx0XHRcdGMuc29ydExpc3QgPSBbXTtcblx0XHRcdHZhciBpbmR4O1xuXHRcdFx0Zm9yIChpbmR4ID0gMDsgaW5keCA8IGMuY29sdW1uczsgaW5keCsrKSB7XG5cdFx0XHRcdGMuc29ydFZhcnNbIGluZHggXS5jb3VudCA9IC0xO1xuXHRcdFx0XHRjLnNvcnRWYXJzWyBpbmR4IF0uc29ydGVkQnkgPSAnJztcblx0XHRcdH1cblx0XHRcdHRzLnNldEhlYWRlcnNDc3MoIGMgKTtcblx0XHRcdHRzLm11bHRpc29ydCggYyApO1xuXHRcdFx0dHMuYXBwZW5kQ2FjaGUoIGMgKTtcblx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICkge1xuXHRcdFx0XHRjYWxsYmFjayggYy50YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTb3J0VHlwZSA6IGZ1bmN0aW9uKCBwYXJzZXJzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZXJzICYmIHBhcnNlcnNbIGNvbHVtbiBdICkgPyBwYXJzZXJzWyBjb2x1bW4gXS50eXBlIHx8ICcnIDogJyc7XG5cdFx0fSxcblxuXHRcdGdldE9yZGVyIDogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdC8vIGxvb2sgZm9yICdkJyBpbiAnZGVzYycgb3JkZXI7IHJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gKCAvXmQvaS50ZXN0KCB2YWwgKSB8fCB2YWwgPT09IDEgKTtcblx0XHR9LFxuXG5cdFx0Ly8gTmF0dXJhbCBzb3J0IC0gaHR0cHM6Ly9naXRodWIuY29tL292ZXJzZXQvamF2YXNjcmlwdC1uYXR1cmFsLXNvcnQgKGRhdGUgc29ydGluZyByZW1vdmVkKVxuXHRcdHNvcnROYXR1cmFsIDogZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGEgPT09IGIgKSB7IHJldHVybiAwOyB9XG5cdFx0XHRhID0gKCBhIHx8ICcnICkudG9TdHJpbmcoKTtcblx0XHRcdGIgPSAoIGIgfHwgJycgKS50b1N0cmluZygpO1xuXHRcdFx0dmFyIGFOdW0sIGJOdW0sIGFGbG9hdCwgYkZsb2F0LCBpbmR4LCBtYXgsXG5cdFx0XHRcdHJlZ2V4ID0gdHMucmVnZXg7XG5cdFx0XHQvLyBmaXJzdCB0cnkgYW5kIHNvcnQgSGV4IGNvZGVzXG5cdFx0XHRpZiAoIHJlZ2V4LmhleC50ZXN0KCBiICkgKSB7XG5cdFx0XHRcdGFOdW0gPSBwYXJzZUludCggYS5tYXRjaCggcmVnZXguaGV4ICksIDE2ICk7XG5cdFx0XHRcdGJOdW0gPSBwYXJzZUludCggYi5tYXRjaCggcmVnZXguaGV4ICksIDE2ICk7XG5cdFx0XHRcdGlmICggYU51bSA8IGJOdW0gKSB7IHJldHVybiAtMTsgfVxuXHRcdFx0XHRpZiAoIGFOdW0gPiBiTnVtICkgeyByZXR1cm4gMTsgfVxuXHRcdFx0fVxuXHRcdFx0Ly8gY2h1bmsvdG9rZW5pemVcblx0XHRcdGFOdW0gPSBhLnJlcGxhY2UoIHJlZ2V4LmNodW5rLCAnXFxcXDAkMVxcXFwwJyApLnJlcGxhY2UoIHJlZ2V4LmNodW5rcywgJycgKS5zcGxpdCggJ1xcXFwwJyApO1xuXHRcdFx0Yk51bSA9IGIucmVwbGFjZSggcmVnZXguY2h1bmssICdcXFxcMCQxXFxcXDAnICkucmVwbGFjZSggcmVnZXguY2h1bmtzLCAnJyApLnNwbGl0KCAnXFxcXDAnICk7XG5cdFx0XHRtYXggPSBNYXRoLm1heCggYU51bS5sZW5ndGgsIGJOdW0ubGVuZ3RoICk7XG5cdFx0XHQvLyBuYXR1cmFsIHNvcnRpbmcgdGhyb3VnaCBzcGxpdCBudW1lcmljIHN0cmluZ3MgYW5kIGRlZmF1bHQgc3RyaW5nc1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBtYXg7IGluZHgrKyApIHtcblx0XHRcdFx0Ly8gZmluZCBmbG9hdHMgbm90IHN0YXJ0aW5nIHdpdGggJzAnLCBzdHJpbmcgb3IgMCBpZiBub3QgZGVmaW5lZFxuXHRcdFx0XHRhRmxvYXQgPSBpc05hTiggYU51bVsgaW5keCBdICkgPyBhTnVtWyBpbmR4IF0gfHwgMCA6IHBhcnNlRmxvYXQoIGFOdW1bIGluZHggXSApIHx8IDA7XG5cdFx0XHRcdGJGbG9hdCA9IGlzTmFOKCBiTnVtWyBpbmR4IF0gKSA/IGJOdW1bIGluZHggXSB8fCAwIDogcGFyc2VGbG9hdCggYk51bVsgaW5keCBdICkgfHwgMDtcblx0XHRcdFx0Ly8gaGFuZGxlIG51bWVyaWMgdnMgc3RyaW5nIGNvbXBhcmlzb24gLSBudW1iZXIgPCBzdHJpbmcgLSAoS3lsZSBBZGFtcylcblx0XHRcdFx0aWYgKCBpc05hTiggYUZsb2F0ICkgIT09IGlzTmFOKCBiRmxvYXQgKSApIHsgcmV0dXJuIGlzTmFOKCBhRmxvYXQgKSA/IDEgOiAtMTsgfVxuXHRcdFx0XHQvLyByZWx5IG9uIHN0cmluZyBjb21wYXJpc29uIGlmIGRpZmZlcmVudCB0eXBlcyAtIGkuZS4gJzAyJyA8IDIgIT0gJzAyJyA8ICcyJ1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBhRmxvYXQgIT09IHR5cGVvZiBiRmxvYXQgKSB7XG5cdFx0XHRcdFx0YUZsb2F0ICs9ICcnO1xuXHRcdFx0XHRcdGJGbG9hdCArPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFGbG9hdCA8IGJGbG9hdCApIHsgcmV0dXJuIC0xOyB9XG5cdFx0XHRcdGlmICggYUZsb2F0ID4gYkZsb2F0ICkgeyByZXR1cm4gMTsgfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdHNvcnROYXR1cmFsQXNjIDogZnVuY3Rpb24oIGEsIGIsIGNvbCwgYyApIHtcblx0XHRcdGlmICggYSA9PT0gYiApIHsgcmV0dXJuIDA7IH1cblx0XHRcdHZhciBlbXB0eSA9IHRzLnN0cmluZ1sgKCBjLmVtcHRpZXNbIGNvbCBdIHx8IGMuZW1wdHlUbyApIF07XG5cdFx0XHRpZiAoIGEgPT09ICcnICYmIGVtcHR5ICE9PSAwICkgeyByZXR1cm4gdHlwZW9mIGVtcHR5ID09PSAnYm9vbGVhbicgPyAoIGVtcHR5ID8gLTEgOiAxICkgOiAtZW1wdHkgfHwgLTE7IH1cblx0XHRcdGlmICggYiA9PT0gJycgJiYgZW1wdHkgIT09IDAgKSB7IHJldHVybiB0eXBlb2YgZW1wdHkgPT09ICdib29sZWFuJyA/ICggZW1wdHkgPyAxIDogLTEgKSA6IGVtcHR5IHx8IDE7IH1cblx0XHRcdHJldHVybiB0cy5zb3J0TmF0dXJhbCggYSwgYiApO1xuXHRcdH0sXG5cblx0XHRzb3J0TmF0dXJhbERlc2MgOiBmdW5jdGlvbiggYSwgYiwgY29sLCBjICkge1xuXHRcdFx0aWYgKCBhID09PSBiICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0dmFyIGVtcHR5ID0gdHMuc3RyaW5nWyAoIGMuZW1wdGllc1sgY29sIF0gfHwgYy5lbXB0eVRvICkgXTtcblx0XHRcdGlmICggYSA9PT0gJycgJiYgZW1wdHkgIT09IDAgKSB7IHJldHVybiB0eXBlb2YgZW1wdHkgPT09ICdib29sZWFuJyA/ICggZW1wdHkgPyAtMSA6IDEgKSA6IGVtcHR5IHx8IDE7IH1cblx0XHRcdGlmICggYiA9PT0gJycgJiYgZW1wdHkgIT09IDAgKSB7IHJldHVybiB0eXBlb2YgZW1wdHkgPT09ICdib29sZWFuJyA/ICggZW1wdHkgPyAxIDogLTEgKSA6IC1lbXB0eSB8fCAtMTsgfVxuXHRcdFx0cmV0dXJuIHRzLnNvcnROYXR1cmFsKCBiLCBhICk7XG5cdFx0fSxcblxuXHRcdC8vIGJhc2ljIGFscGhhYmV0aWNhbCBzb3J0XG5cdFx0c29ydFRleHQgOiBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHJldHVybiBhID4gYiA/IDEgOiAoIGEgPCBiID8gLTEgOiAwICk7XG5cdFx0fSxcblxuXHRcdC8vIHJldHVybiB0ZXh0IHN0cmluZyB2YWx1ZSBieSBhZGRpbmcgdXAgYXNjaWkgdmFsdWVcblx0XHQvLyBzbyB0aGUgdGV4dCBpcyBzb21ld2hhdCBzb3J0ZWQgd2hlbiB1c2luZyBhIGRpZ2l0YWwgc29ydFxuXHRcdC8vIHRoaXMgaXMgTk9UIGFuIGFscGhhbnVtZXJpYyBzb3J0XG5cdFx0Z2V0VGV4dFZhbHVlIDogZnVuY3Rpb24oIHZhbCwgbnVtLCBtYXggKSB7XG5cdFx0XHRpZiAoIG1heCApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB0ZXh0IHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IG51bWVyaWNhbCB2YWx1ZSAobWF4KVxuXHRcdFx0XHR2YXIgaW5keCxcblx0XHRcdFx0XHRsZW4gPSB2YWwgPyB2YWwubGVuZ3RoIDogMCxcblx0XHRcdFx0XHRuID0gbWF4ICsgbnVtO1xuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdG4gKz0gdmFsLmNoYXJDb2RlQXQoIGluZHggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVtICogbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH0sXG5cblx0XHRzb3J0TnVtZXJpY0FzYyA6IGZ1bmN0aW9uKCBhLCBiLCBudW0sIG1heCwgY29sLCBjICkge1xuXHRcdFx0aWYgKCBhID09PSBiICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0dmFyIGVtcHR5ID0gdHMuc3RyaW5nWyAoIGMuZW1wdGllc1sgY29sIF0gfHwgYy5lbXB0eVRvICkgXTtcblx0XHRcdGlmICggYSA9PT0gJycgJiYgZW1wdHkgIT09IDAgKSB7IHJldHVybiB0eXBlb2YgZW1wdHkgPT09ICdib29sZWFuJyA/ICggZW1wdHkgPyAtMSA6IDEgKSA6IC1lbXB0eSB8fCAtMTsgfVxuXHRcdFx0aWYgKCBiID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IDEgOiAtMSApIDogZW1wdHkgfHwgMTsgfVxuXHRcdFx0aWYgKCBpc05hTiggYSApICkgeyBhID0gdHMuZ2V0VGV4dFZhbHVlKCBhLCBudW0sIG1heCApOyB9XG5cdFx0XHRpZiAoIGlzTmFOKCBiICkgKSB7IGIgPSB0cy5nZXRUZXh0VmFsdWUoIGIsIG51bSwgbWF4ICk7IH1cblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0c29ydE51bWVyaWNEZXNjIDogZnVuY3Rpb24oIGEsIGIsIG51bSwgbWF4LCBjb2wsIGMgKSB7XG5cdFx0XHRpZiAoIGEgPT09IGIgKSB7IHJldHVybiAwOyB9XG5cdFx0XHR2YXIgZW1wdHkgPSB0cy5zdHJpbmdbICggYy5lbXB0aWVzWyBjb2wgXSB8fCBjLmVtcHR5VG8gKSBdO1xuXHRcdFx0aWYgKCBhID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IC0xIDogMSApIDogZW1wdHkgfHwgMTsgfVxuXHRcdFx0aWYgKCBiID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IDEgOiAtMSApIDogLWVtcHR5IHx8IC0xOyB9XG5cdFx0XHRpZiAoIGlzTmFOKCBhICkgKSB7IGEgPSB0cy5nZXRUZXh0VmFsdWUoIGEsIG51bSwgbWF4ICk7IH1cblx0XHRcdGlmICggaXNOYU4oIGIgKSApIHsgYiA9IHRzLmdldFRleHRWYWx1ZSggYiwgbnVtLCBtYXggKTsgfVxuXHRcdFx0cmV0dXJuIGIgLSBhO1xuXHRcdH0sXG5cblx0XHRzb3J0TnVtZXJpYyA6IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdOKWiOKWiCDilojilogg4paI4paIIOKWiOKWiCDilojilojilojilojilojiloQg4paE4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilogg4paE4paI4paI4paI4paI4paIXG5cdFx04paI4paIIOKWiOKWiCDilojilogg4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiCDiloTiloTiloQg4paI4paI4paE4paEICAgICDilojiloggICDiloDilojiloRcblx0XHTilojilogg4paI4paIIOKWiOKWiCDilojilogg4paI4paIICDilojilogg4paI4paIIOKWgOKWiOKWiCDilojilojiloDiloAgICAgIOKWiOKWiCAgICAgIOKWgOKWiOKWhFxuXHRcdOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWgCDilojilogg4paI4paI4paI4paI4paI4paAIOKWgOKWiOKWiOKWiOKWiOKWgCDilojilojilojilojilojiloggICDilojiloggICDilojilojilojilojilojiloBcblx0XHQqL1xuXHRcdGFkZFdpZGdldCA6IGZ1bmN0aW9uKCB3aWRnZXQgKSB7XG5cdFx0XHRpZiAoIHdpZGdldC5pZCAmJiAhdHMuaXNFbXB0eU9iamVjdCggdHMuZ2V0V2lkZ2V0QnlJZCggd2lkZ2V0LmlkICkgKSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnXCInICsgd2lkZ2V0LmlkICsgJ1wiIHdpZGdldCB3YXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlIScgKTtcblx0XHRcdH1cblx0XHRcdHRzLndpZGdldHNbIHRzLndpZGdldHMubGVuZ3RoIF0gPSB3aWRnZXQ7XG5cdFx0fSxcblxuXHRcdGhhc1dpZGdldCA6IGZ1bmN0aW9uKCAkdGFibGUsIG5hbWUgKSB7XG5cdFx0XHQkdGFibGUgPSAkKCAkdGFibGUgKTtcblx0XHRcdHJldHVybiAkdGFibGUubGVuZ3RoICYmICR0YWJsZVsgMCBdLmNvbmZpZyAmJiAkdGFibGVbIDAgXS5jb25maWcud2lkZ2V0SW5pdFsgbmFtZSBdIHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRnZXRXaWRnZXRCeUlkIDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHR2YXIgaW5keCwgd2lkZ2V0LFxuXHRcdFx0XHRsZW4gPSB0cy53aWRnZXRzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdHdpZGdldCA9IHRzLndpZGdldHNbIGluZHggXTtcblx0XHRcdFx0aWYgKCB3aWRnZXQgJiYgd2lkZ2V0LmlkICYmIHdpZGdldC5pZC50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdpZGdldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhcHBseVdpZGdldE9wdGlvbnMgOiBmdW5jdGlvbiggdGFibGUgKSB7XG5cdFx0XHR2YXIgaW5keCwgd2lkZ2V0LCB3byxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0bGVuID0gYy53aWRnZXRzLmxlbmd0aDtcblx0XHRcdGlmICggbGVuICkge1xuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdHdpZGdldCA9IHRzLmdldFdpZGdldEJ5SWQoIGMud2lkZ2V0c1sgaW5keCBdICk7XG5cdFx0XHRcdFx0aWYgKCB3aWRnZXQgJiYgd2lkZ2V0Lm9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0XHR3byA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgd2lkZ2V0Lm9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdGMud2lkZ2V0T3B0aW9ucyA9ICQuZXh0ZW5kKCB0cnVlLCB3bywgYy53aWRnZXRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHQvLyBhZGQgd2lkZ2V0T3B0aW9ucyB0byBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbGlkYXRvclxuXHRcdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIHRzLmRlZmF1bHRzLndpZGdldE9wdGlvbnMsIHdpZGdldC5vcHRpb25zICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFkZFdpZGdldEZyb21DbGFzcyA6IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdHZhciBsZW4sIGluZHgsXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdC8vIGxvb2sgZm9yIHdpZGdldHMgdG8gYXBwbHkgZnJvbSB0YWJsZSBjbGFzc1xuXHRcdFx0XHQvLyBkb24ndCBtYXRjaCBmcm9tICd1aS13aWRnZXQtY29udGVudCc7IHVzZSBcXFMgaW5zdGVhZCBvZiBcXHcgdG8gaW5jbHVkZSB3aWRnZXRzXG5cdFx0XHRcdC8vIHdpdGggZGFzaGVzIGluIHRoZSBuYW1lLCBlLmcuIFwid2lkZ2V0LXRlc3QtMlwiIGV4dHJhY3RzIG91dCBcInRlc3QtMlwiXG5cdFx0XHRcdHJlZ2V4ID0gJ14nICsgYy53aWRnZXRDbGFzcy5yZXBsYWNlKCB0cy5yZWdleC50ZW1wbGF0ZU5hbWUsICcoXFxcXFMrKSsnICkgKyAnJCcsXG5cdFx0XHRcdHdpZGdldENsYXNzID0gbmV3IFJlZ0V4cCggcmVnZXgsICdnJyApLFxuXHRcdFx0XHQvLyBzcGxpdCB1cCB0YWJsZSBjbGFzcyAod2lkZ2V0IGlkJ3MgY2FuIGluY2x1ZGUgZGFzaGVzKSAtIHN0b3AgdXNpbmcgbWF0Y2hcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIG9ubHkgb25lIHdpZGdldCBnZXRzIGV4dHJhY3RlZCwgc2VlICMxMTA5XG5cdFx0XHRcdHdpZGdldHMgPSAoIHRhYmxlLmNsYXNzTmFtZSB8fCAnJyApLnNwbGl0KCB0cy5yZWdleC5zcGFjZXMgKTtcblx0XHRcdGlmICggd2lkZ2V0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGxlbiA9IHdpZGdldHMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdGlmICggd2lkZ2V0c1sgaW5keCBdLm1hdGNoKCB3aWRnZXRDbGFzcyApICkge1xuXHRcdFx0XHRcdFx0Yy53aWRnZXRzWyBjLndpZGdldHMubGVuZ3RoIF0gPSB3aWRnZXRzWyBpbmR4IF0ucmVwbGFjZSggd2lkZ2V0Q2xhc3MsICckMScgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YXBwbHlXaWRnZXRJZCA6IGZ1bmN0aW9uKCB0YWJsZSwgaWQsIGluaXQgKSB7XG5cdFx0XHR0YWJsZSA9ICQodGFibGUpWzBdO1xuXHRcdFx0dmFyIGFwcGxpZWQsIHRpbWUsIG5hbWUsXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdjb3JlJyksXG5cdFx0XHRcdHdpZGdldCA9IHRzLmdldFdpZGdldEJ5SWQoIGlkICk7XG5cdFx0XHRpZiAoIHdpZGdldCApIHtcblx0XHRcdFx0bmFtZSA9IHdpZGdldC5pZDtcblx0XHRcdFx0YXBwbGllZCA9IGZhbHNlO1xuXHRcdFx0XHQvLyBhZGQgd2lkZ2V0IG5hbWUgdG8gb3B0aW9uIGxpc3Qgc28gaXQgZ2V0cyByZWFwcGxpZWQgYWZ0ZXIgc29ydGluZywgZmlsdGVyaW5nLCBldGNcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIG5hbWUsIGMud2lkZ2V0cyApIDwgMCApIHtcblx0XHRcdFx0XHRjLndpZGdldHNbIGMud2lkZ2V0cy5sZW5ndGggXSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZWJ1ZyApIHsgdGltZSA9IG5ldyBEYXRlKCk7IH1cblxuXHRcdFx0XHRpZiAoIGluaXQgfHwgISggYy53aWRnZXRJbml0WyBuYW1lIF0gKSApIHtcblx0XHRcdFx0XHQvLyBzZXQgaW5pdCBmbGFnIGZpcnN0IHRvIHByZXZlbnQgY2FsbGluZyBpbml0IG1vcmUgdGhhbiBvbmNlIChlLmcuIHBhZ2VyKVxuXHRcdFx0XHRcdGMud2lkZ2V0SW5pdFsgbmFtZSBdID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAoIHRhYmxlLmhhc0luaXRpYWxpemVkICkge1xuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgcmVhcHBseSB3aWRnZXQgb3B0aW9ucyBvbiB0YWJsZXNvcnRlciBpbml0XG5cdFx0XHRcdFx0XHR0cy5hcHBseVdpZGdldE9wdGlvbnMoIHRhYmxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIHdpZGdldC5pbml0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0YXBwbGllZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlWyBjb25zb2xlLmdyb3VwID8gJ2dyb3VwJyA6ICdsb2cnIF0oICdJbml0aWFsaXppbmcgJyArIG5hbWUgKyAnIHdpZGdldCcgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdpZGdldC5pbml0KCB0YWJsZSwgd2lkZ2V0LCBjLCB3byApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpbml0ICYmIHR5cGVvZiB3aWRnZXQuZm9ybWF0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGFwcGxpZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlWyBjb25zb2xlLmdyb3VwID8gJ2dyb3VwJyA6ICdsb2cnIF0oICdVcGRhdGluZyAnICsgbmFtZSArICcgd2lkZ2V0JyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aWRnZXQuZm9ybWF0KCB0YWJsZSwgYywgd28sIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHRpZiAoIGFwcGxpZWQgKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0NvbXBsZXRlZCAnICsgKCBpbml0ID8gJ2luaXRpYWxpemluZyAnIDogJ2FwcGx5aW5nICcgKSArIG5hbWUgKyAnIHdpZGdldCcgKyB0cy5iZW5jaG1hcmsoIHRpbWUgKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBjb25zb2xlLmdyb3VwRW5kICkgeyBjb25zb2xlLmdyb3VwRW5kKCk7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YXBwbHlXaWRnZXQgOiBmdW5jdGlvbiggdGFibGUsIGluaXQsIGNhbGxiYWNrICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWyAwIF07IC8vIGluIGNhc2UgdGhpcyBpcyBjYWxsZWQgZXh0ZXJuYWxseVxuXHRcdFx0dmFyIGluZHgsIGxlbiwgbmFtZXMsIHdpZGdldCwgdGltZSxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0ZGVidWcgPSB0cy5kZWJ1ZyhjLCAnY29yZScpLFxuXHRcdFx0XHR3aWRnZXRzID0gW107XG5cdFx0XHQvLyBwcmV2ZW50IG51bWVyb3VzIGNvbnNlY3V0aXZlIHdpZGdldCBhcHBsaWNhdGlvbnNcblx0XHRcdGlmICggaW5pdCAhPT0gZmFsc2UgJiYgdGFibGUuaGFzSW5pdGlhbGl6ZWQgJiYgKCB0YWJsZS5pc0FwcGx5aW5nV2lkZ2V0cyB8fCB0YWJsZS5pc1VwZGF0aW5nICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggZGVidWcgKSB7IHRpbWUgPSBuZXcgRGF0ZSgpOyB9XG5cdFx0XHR0cy5hZGRXaWRnZXRGcm9tQ2xhc3MoIHRhYmxlICk7XG5cdFx0XHQvLyBwcmV2ZW50IFwidGFibGVzb3J0ZXItcmVhZHlcIiBmcm9tIGZpcmluZyBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvd1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCBjLnRpbWVyUmVhZHkgKTtcblx0XHRcdGlmICggYy53aWRnZXRzLmxlbmd0aCApIHtcblx0XHRcdFx0dGFibGUuaXNBcHBseWluZ1dpZGdldHMgPSB0cnVlO1xuXHRcdFx0XHQvLyBlbnN1cmUgdW5pcXVlIHdpZGdldCBpZHNcblx0XHRcdFx0Yy53aWRnZXRzID0gJC5ncmVwKCBjLndpZGdldHMsIGZ1bmN0aW9uKCB2YWwsIGluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkoIHZhbCwgYy53aWRnZXRzICkgPT09IGluZGV4O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bmFtZXMgPSBjLndpZGdldHMgfHwgW107XG5cdFx0XHRcdGxlbiA9IG5hbWVzLmxlbmd0aDtcblx0XHRcdFx0Ly8gYnVpbGQgd2lkZ2V0IGFycmF5ICYgYWRkIHByaW9yaXR5IGFzIG5lZWRlZFxuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdHdpZGdldCA9IHRzLmdldFdpZGdldEJ5SWQoIG5hbWVzWyBpbmR4IF0gKTtcblx0XHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQuaWQgKSB7XG5cdFx0XHRcdFx0XHQvLyBzZXQgcHJpb3JpdHkgdG8gMTAgaWYgbm90IGRlZmluZWRcblx0XHRcdFx0XHRcdGlmICggIXdpZGdldC5wcmlvcml0eSApIHsgd2lkZ2V0LnByaW9yaXR5ID0gMTA7IH1cblx0XHRcdFx0XHRcdHdpZGdldHNbIGluZHggXSA9IHdpZGdldDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1wiJyArIG5hbWVzWyBpbmR4IF0gKyAnXCIgd2FzIGVuYWJsZWQsIGJ1dCB0aGUgd2lkZ2V0IGNvZGUgaGFzIG5vdCBiZWVuIGxvYWRlZCEnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNvcnQgd2lkZ2V0cyBieSBwcmlvcml0eVxuXHRcdFx0XHR3aWRnZXRzLnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRcdHJldHVybiBhLnByaW9yaXR5IDwgYi5wcmlvcml0eSA/IC0xIDogYS5wcmlvcml0eSA9PT0gYi5wcmlvcml0eSA/IDAgOiAxO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gYWRkL3VwZGF0ZSBzZWxlY3RlZCB3aWRnZXRzXG5cdFx0XHRcdGxlbiA9IHdpZGdldHMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ1N0YXJ0ICcgKyAoIGluaXQgPyAnaW5pdGlhbGl6aW5nJyA6ICdhcHBseWluZycgKSArICcgd2lkZ2V0cycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdHdpZGdldCA9IHdpZGdldHNbIGluZHggXTtcblx0XHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQuaWQgKSB7XG5cdFx0XHRcdFx0XHR0cy5hcHBseVdpZGdldElkKCB0YWJsZSwgd2lkZ2V0LmlkLCBpbml0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZGVidWcgJiYgY29uc29sZS5ncm91cEVuZCApIHsgY29uc29sZS5ncm91cEVuZCgpOyB9XG5cdFx0XHR9XG5cdFx0XHRjLnRpbWVyUmVhZHkgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGFibGUuaXNBcHBseWluZ1dpZGdldHMgPSBmYWxzZTtcblx0XHRcdFx0JC5kYXRhKCB0YWJsZSwgJ2xhc3RXaWRnZXRBcHBsaWNhdGlvbicsIG5ldyBEYXRlKCkgKTtcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICd0YWJsZXNvcnRlci1yZWFkeScgKTtcblx0XHRcdFx0Ly8gY2FsbGJhY2sgZXhlY3V0ZWQgb24gaW5pdCBvbmx5XG5cdFx0XHRcdGlmICggIWluaXQgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCB0YWJsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdFx0d2lkZ2V0ID0gYy53aWRnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0NvbXBsZXRlZCAnICtcblx0XHRcdFx0XHRcdCggaW5pdCA9PT0gdHJ1ZSA/ICdpbml0aWFsaXppbmcgJyA6ICdhcHBseWluZyAnICkgKyB3aWRnZXQgK1xuXHRcdFx0XHRcdFx0JyB3aWRnZXQnICsgKCB3aWRnZXQgIT09IDEgPyAncycgOiAnJyApICsgdHMuYmVuY2htYXJrKCB0aW1lICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAgKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlV2lkZ2V0IDogZnVuY3Rpb24oIHRhYmxlLCBuYW1lLCByZWZyZXNoaW5nICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWyAwIF07XG5cdFx0XHR2YXIgaW5kZXgsIHdpZGdldCwgaW5keCwgbGVuLFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnO1xuXHRcdFx0Ly8gaWYgbmFtZSA9PT0gdHJ1ZSwgYWRkIGFsbCB3aWRnZXRzIGZyb20gJC50YWJsZXNvcnRlci53aWRnZXRzXG5cdFx0XHRpZiAoIG5hbWUgPT09IHRydWUgKSB7XG5cdFx0XHRcdG5hbWUgPSBbXTtcblx0XHRcdFx0bGVuID0gdHMud2lkZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0d2lkZ2V0ID0gdHMud2lkZ2V0c1sgaW5keCBdO1xuXHRcdFx0XHRcdGlmICggd2lkZ2V0ICYmIHdpZGdldC5pZCApIHtcblx0XHRcdFx0XHRcdG5hbWVbIG5hbWUubGVuZ3RoIF0gPSB3aWRnZXQuaWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBuYW1lIGNhbiBiZSBlaXRoZXIgYW4gYXJyYXkgb2Ygd2lkZ2V0cyBuYW1lcyxcblx0XHRcdFx0Ly8gb3IgYSBzcGFjZS9jb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiB3aWRnZXQgbmFtZXNcblx0XHRcdFx0bmFtZSA9ICggJC5pc0FycmF5KCBuYW1lICkgPyBuYW1lLmpvaW4oICcsJyApIDogbmFtZSB8fCAnJyApLnRvTG93ZXJDYXNlKCkuc3BsaXQoIC9bXFxzLF0rLyApO1xuXHRcdFx0fVxuXHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHR3aWRnZXQgPSB0cy5nZXRXaWRnZXRCeUlkKCBuYW1lWyBpbmRleCBdICk7XG5cdFx0XHRcdGluZHggPSAkLmluQXJyYXkoIG5hbWVbIGluZGV4IF0sIGMud2lkZ2V0cyApO1xuXHRcdFx0XHQvLyBkb24ndCByZW1vdmUgdGhlIHdpZGdldCBmcm9tIGNvbmZpZy53aWRnZXQgaWYgcmVmcmVzaGluZ1xuXHRcdFx0XHRpZiAoIGluZHggPj0gMCAmJiByZWZyZXNoaW5nICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdGMud2lkZ2V0cy5zcGxpY2UoIGluZHgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQucmVtb3ZlICkge1xuXHRcdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAoIHJlZnJlc2hpbmcgPyAnUmVmcmVzaGluZycgOiAnUmVtb3ZpbmcnICkgKyAnIFwiJyArIG5hbWVbIGluZGV4IF0gKyAnXCIgd2lkZ2V0JyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aWRnZXQucmVtb3ZlKCB0YWJsZSwgYywgYy53aWRnZXRPcHRpb25zLCByZWZyZXNoaW5nICk7XG5cdFx0XHRcdFx0Yy53aWRnZXRJbml0WyBuYW1lWyBpbmRleCBdIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICd3aWRnZXRSZW1vdmVFbmQnLCB0YWJsZSApO1xuXHRcdH0sXG5cblx0XHRyZWZyZXNoV2lkZ2V0cyA6IGZ1bmN0aW9uKCB0YWJsZSwgZG9BbGwsIGRvbnRhcHBseSApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVsgMCBdOyAvLyBzZWUgaXNzdWUgIzI0M1xuXHRcdFx0dmFyIGluZHgsIHdpZGdldCxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0Y3VyV2lkZ2V0cyA9IGMud2lkZ2V0cyxcblx0XHRcdFx0d2lkZ2V0cyA9IHRzLndpZGdldHMsXG5cdFx0XHRcdGxlbiA9IHdpZGdldHMubGVuZ3RoLFxuXHRcdFx0XHRsaXN0ID0gW10sXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHRhYmxlICkge1xuXHRcdFx0XHRcdCQoIHRhYmxlICkudHJpZ2dlckhhbmRsZXIoICdyZWZyZXNoQ29tcGxldGUnICk7XG5cdFx0XHRcdH07XG5cdFx0XHQvLyByZW1vdmUgd2lkZ2V0cyBub3QgZGVmaW5lZCBpbiBjb25maWcud2lkZ2V0cywgdW5sZXNzIGRvQWxsIGlzIHRydWVcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdHdpZGdldCA9IHdpZGdldHNbIGluZHggXTtcblx0XHRcdFx0aWYgKCB3aWRnZXQgJiYgd2lkZ2V0LmlkICYmICggZG9BbGwgfHwgJC5pbkFycmF5KCB3aWRnZXQuaWQsIGN1cldpZGdldHMgKSA8IDAgKSApIHtcblx0XHRcdFx0XHRsaXN0WyBsaXN0Lmxlbmd0aCBdID0gd2lkZ2V0LmlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0cy5yZW1vdmVXaWRnZXQoIHRhYmxlLCBsaXN0LmpvaW4oICcsJyApLCB0cnVlICk7XG5cdFx0XHRpZiAoIGRvbnRhcHBseSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0Ly8gY2FsbCB3aWRnZXQgaW5pdCBpZlxuXHRcdFx0XHR0cy5hcHBseVdpZGdldCggdGFibGUsIGRvQWxsIHx8IGZhbHNlLCBjYWxsYmFjayApO1xuXHRcdFx0XHRpZiAoIGRvQWxsICkge1xuXHRcdFx0XHRcdC8vIGFwcGx5IHdpZGdldCBmb3JtYXRcblx0XHRcdFx0XHR0cy5hcHBseVdpZGdldCggdGFibGUsIGZhbHNlLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayggdGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHTilojiloggIOKWiOKWiCDilojilojilojilojilojilogg4paI4paIIOKWiOKWiCAgICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilogg4paI4paI4paI4paI4paI4paIIOKWhOKWiOKWiOKWiOKWiOKWiFxuXHRcdOKWiOKWiCAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiOKWhOKWhCAgIOKWgOKWiOKWhFxuXHRcdOKWiOKWiCAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiOKWgOKWgCAgICAgIOKWgOKWiOKWhFxuXHRcdOKWgOKWiOKWiOKWiOKWiOKWgCAgIOKWiOKWiCAgIOKWiOKWiCDilojilojilojilojilojilogg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojiloBcblx0XHQqL1xuXHRcdGJlbmNobWFyayA6IGZ1bmN0aW9uKCBkaWZmICkge1xuXHRcdFx0cmV0dXJuICggJyAoJyArICggbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBkaWZmLmdldFRpbWUoKSApICsgJyBtcyknICk7XG5cdFx0fSxcblx0XHQvLyBkZXByZWNhdGVkIHRzLmxvZ1xuXHRcdGxvZyA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coIGFyZ3VtZW50cyApO1xuXHRcdH0sXG5cdFx0ZGVidWcgOiBmdW5jdGlvbihjLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gYyAmJiAoXG5cdFx0XHRcdGMuZGVidWcgPT09IHRydWUgfHxcblx0XHRcdFx0dHlwZW9mIGMuZGVidWcgPT09ICdzdHJpbmcnICYmIGMuZGVidWcuaW5kZXhPZihuYW1lKSA+IC0xXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvLyAkLmlzRW1wdHlPYmplY3QgZnJvbSBqUXVlcnkgdjEuNFxuXHRcdGlzRW1wdHlPYmplY3QgOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0Lypqc2hpbnQgZm9yaW46IGZhbHNlICovXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRpc1ZhbHVlSW5BcnJheSA6IGZ1bmN0aW9uKCBjb2x1bW4sIGFycnkgKSB7XG5cdFx0XHR2YXIgaW5keCxcblx0XHRcdFx0bGVuID0gYXJyeSAmJiBhcnJ5Lmxlbmd0aCB8fCAwO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0aWYgKCBhcnJ5WyBpbmR4IF1bIDAgXSA9PT0gY29sdW1uICkge1xuXHRcdFx0XHRcdHJldHVybiBpbmR4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSxcblxuXHRcdGZvcm1hdEZsb2F0IDogZnVuY3Rpb24oIHN0ciwgdGFibGUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ciA9PT0gJycgKSB7IHJldHVybiBzdHI7IH1cblx0XHRcdC8vIGFsbG93IHVzaW5nIGZvcm1hdEZsb2F0IHdpdGhvdXQgYSB0YWJsZTsgZGVmYXVsdHMgdG8gVVMgbnVtYmVyIGZvcm1hdFxuXHRcdFx0dmFyIG51bSxcblx0XHRcdFx0dXNGb3JtYXQgPSB0YWJsZSAmJiB0YWJsZS5jb25maWcgPyB0YWJsZS5jb25maWcudXNOdW1iZXJGb3JtYXQgIT09IGZhbHNlIDpcblx0XHRcdFx0XHR0eXBlb2YgdGFibGUgIT09ICd1bmRlZmluZWQnID8gdGFibGUgOiB0cnVlO1xuXHRcdFx0aWYgKCB1c0Zvcm1hdCApIHtcblx0XHRcdFx0Ly8gVVMgRm9ybWF0IC0gMSwyMzQsNTY3Ljg5IC0+IDEyMzQ1NjcuODlcblx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIHRzLnJlZ2V4LmNvbW1hLCAnJyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gR2VybWFuIEZvcm1hdCA9IDEuMjM0LjU2Nyw4OSAtPiAxMjM0NTY3Ljg5XG5cdFx0XHRcdC8vIEZyZW5jaCBGb3JtYXQgPSAxIDIzNCA1NjcsODkgLT4gMTIzNDU2Ny44OVxuXHRcdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggdHMucmVnZXguZGlnaXROb25VUywgJycgKS5yZXBsYWNlKCB0cy5yZWdleC5jb21tYSwgJy4nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLnJlZ2V4LmRpZ2l0TmVnYXRpdmVUZXN0LnRlc3QoIHN0ciApICkge1xuXHRcdFx0XHQvLyBtYWtlICgjKSBpbnRvIGEgbmVnYXRpdmUgbnVtYmVyIC0+ICgxMCkgPSAtMTBcblx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIHRzLnJlZ2V4LmRpZ2l0TmVnYXRpdmVSZXBsYWNlLCAnLSQxJyApO1xuXHRcdFx0fVxuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggc3RyICk7XG5cdFx0XHQvLyByZXR1cm4gdGhlIHRleHQgaW5zdGVhZCBvZiB6ZXJvXG5cdFx0XHRyZXR1cm4gaXNOYU4oIG51bSApID8gJC50cmltKCBzdHIgKSA6IG51bTtcblx0XHR9LFxuXG5cdFx0aXNEaWdpdCA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHQvLyByZXBsYWNlIGFsbCB1bndhbnRlZCBjaGFycyBhbmQgbWF0Y2hcblx0XHRcdHJldHVybiBpc05hTiggc3RyICkgP1xuXHRcdFx0XHR0cy5yZWdleC5kaWdpdFRlc3QudGVzdCggc3RyLnRvU3RyaW5nKCkucmVwbGFjZSggdHMucmVnZXguZGlnaXRSZXBsYWNlLCAnJyApICkgOlxuXHRcdFx0XHRzdHIgIT09ICcnO1xuXHRcdH0sXG5cblx0XHQvLyBjb21wdXRlVGFibGVIZWFkZXJDZWxsSW5kZXhlcyBmcm9tOlxuXHRcdC8vIGh0dHA6Ly93d3cuamF2YXNjcmlwdHRvb2xib3guY29tL2xpYi90YWJsZS9leGFtcGxlcy5waHBcblx0XHQvLyBodHRwOi8vd3d3LmphdmFzY3JpcHR0b29sYm94LmNvbS90ZW1wL3RhYmxlX2NlbGxpbmRleC5odG1sXG5cdFx0Y29tcHV0ZUNvbHVtbkluZGV4IDogZnVuY3Rpb24oICRyb3dzLCBjICkge1xuXHRcdFx0dmFyIGksIGosIGssIGwsIGNlbGwsIGNlbGxzLCByb3dJbmRleCwgcm93U3BhbiwgY29sU3BhbiwgZmlyc3RBdmFpbENvbCxcblx0XHRcdFx0Ly8gdG90YWwgY29sdW1ucyBoYXMgYmVlbiBjYWxjdWxhdGVkLCB1c2UgaXQgdG8gc2V0IHRoZSBtYXRyaXhyb3dcblx0XHRcdFx0Y29sdW1ucyA9IGMgJiYgYy5jb2x1bW5zIHx8IDAsXG5cdFx0XHRcdG1hdHJpeCA9IFtdLFxuXHRcdFx0XHRtYXRyaXhyb3cgPSBuZXcgQXJyYXkoIGNvbHVtbnMgKTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgJHJvd3MubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGNlbGxzID0gJHJvd3NbIGkgXS5jZWxscztcblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBjZWxscy5sZW5ndGg7IGorKyApIHtcblx0XHRcdFx0XHRjZWxsID0gY2VsbHNbIGogXTtcblx0XHRcdFx0XHRyb3dJbmRleCA9IGk7XG5cdFx0XHRcdFx0cm93U3BhbiA9IGNlbGwucm93U3BhbiB8fCAxO1xuXHRcdFx0XHRcdGNvbFNwYW4gPSBjZWxsLmNvbFNwYW4gfHwgMTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBtYXRyaXhbIHJvd0luZGV4IF0gPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0bWF0cml4WyByb3dJbmRleCBdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEZpbmQgZmlyc3QgYXZhaWxhYmxlIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG5cdFx0XHRcdFx0Zm9yICggayA9IDA7IGsgPCBtYXRyaXhbIHJvd0luZGV4IF0ubGVuZ3RoICsgMTsgaysrICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWF0cml4WyByb3dJbmRleCBdWyBrIF0gPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRmaXJzdEF2YWlsQ29sID0gaztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGpzY3M6ZGlzYWJsZSBkaXNhbGxvd0VtcHR5QmxvY2tzXG5cdFx0XHRcdFx0aWYgKCBjb2x1bW5zICYmIGNlbGwuY2VsbEluZGV4ID09PSBmaXJzdEF2YWlsQ29sICkge1xuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgdG8gYW55dGhpbmdcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjZWxsLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHRcdC8vIGpzY3M6ZW5hYmxlIGRpc2FsbG93RW1wdHlCbG9ja3Ncblx0XHRcdFx0XHRcdC8vIGFkZCBkYXRhLWNvbHVtbiAoc2V0QXR0cmlidXRlID0gSUU4Kylcblx0XHRcdFx0XHRcdGNlbGwuc2V0QXR0cmlidXRlKCAnZGF0YS1jb2x1bW4nLCBmaXJzdEF2YWlsQ29sICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHJlbW92ZSBvbmNlIHdlIGRyb3Agc3VwcG9ydCBmb3IgSUU3IC0gMS8xMi8yMDE2XG5cdFx0XHRcdFx0XHQkKCBjZWxsICkuYXR0ciggJ2RhdGEtY29sdW1uJywgZmlyc3RBdmFpbENvbCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKCBrID0gcm93SW5kZXg7IGsgPCByb3dJbmRleCArIHJvd1NwYW47IGsrKyApIHtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIG1hdHJpeFsgayBdID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdFx0bWF0cml4WyBrIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdHJpeHJvdyA9IG1hdHJpeFsgayBdO1xuXHRcdFx0XHRcdFx0Zm9yICggbCA9IGZpcnN0QXZhaWxDb2w7IGwgPCBmaXJzdEF2YWlsQ29sICsgY29sU3BhbjsgbCsrICkge1xuXHRcdFx0XHRcdFx0XHRtYXRyaXhyb3dbIGwgXSA9ICd4Jztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRzLmNoZWNrQ29sdW1uQ291bnQoJHJvd3MsIG1hdHJpeCwgbWF0cml4cm93Lmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0cml4cm93Lmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0Y2hlY2tDb2x1bW5Db3VudCA6IGZ1bmN0aW9uKCRyb3dzLCBtYXRyaXgsIGNvbHVtbnMpIHtcblx0XHRcdC8vIHRoaXMgRE9FUyBOT1QgcmVwb3J0IGFueSB0Ym9keSBjb2x1bW4gaXNzdWVzLCBleGNlcHQgZm9yIHRoZSBtYXRoIGFuZFxuXHRcdFx0Ly8gYW5kIGNvbHVtbiBzZWxlY3RvciB3aWRnZXRzXG5cdFx0XHR2YXIgaSwgbGVuLFxuXHRcdFx0XHR2YWxpZCA9IHRydWUsXG5cdFx0XHRcdGNlbGxzID0gW107XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Ly8gc29tZSBtYXRyaXggZW50cmllcyBhcmUgdW5kZWZpbmVkIHdoZW4gdGVzdGluZyB0aGUgZm9vdGVyIGJlY2F1c2Vcblx0XHRcdFx0Ly8gaXQgaXMgdXNpbmcgdGhlIHJvd0luZGV4IHByb3BlcnR5XG5cdFx0XHRcdGlmICggbWF0cml4W2ldICkge1xuXHRcdFx0XHRcdGxlbiA9IG1hdHJpeFtpXS5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKCBtYXRyaXhbaV0ubGVuZ3RoICE9PSBjb2x1bW5zICkge1xuXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdmFsaWQgKSB7XG5cdFx0XHRcdCRyb3dzLmVhY2goIGZ1bmN0aW9uKCBpbmR4LCBlbCApIHtcblx0XHRcdFx0XHR2YXIgY2VsbCA9IGVsLnBhcmVudEVsZW1lbnQubm9kZU5hbWU7XG5cdFx0XHRcdFx0aWYgKCBjZWxscy5pbmRleE9mKCBjZWxsICkgPCAwICkge1xuXHRcdFx0XHRcdFx0Y2VsbHMucHVzaCggY2VsbCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFx0J0ludmFsaWQgb3IgaW5jb3JyZWN0IG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSAnICtcblx0XHRcdFx0XHRjZWxscy5qb2luKCAnIG9yICcgKSArICc7IGV4cGVjdGVkICcgKyBjb2x1bW5zICtcblx0XHRcdFx0XHQnLCBidXQgZm91bmQgJyArIGxlbiArICcgY29sdW1ucydcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gYXV0b21hdGljYWxseSBhZGQgYSBjb2xncm91cCB3aXRoIGNvbCBlbGVtZW50cyBzZXQgdG8gYSBwZXJjZW50YWdlIHdpZHRoXG5cdFx0Zml4Q29sdW1uV2lkdGggOiBmdW5jdGlvbiggdGFibGUgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTtcblx0XHRcdHZhciBvdmVyYWxsV2lkdGgsIHBlcmNlbnQsICR0Ym9kaWVzLCBsZW4sIGluZGV4LFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHQkY29sZ3JvdXAgPSBjLiR0YWJsZS5jaGlsZHJlbiggJ2NvbGdyb3VwJyApO1xuXHRcdFx0Ly8gcmVtb3ZlIHBsdWdpbi1hZGRlZCBjb2xncm91cCwgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlZnJlc2ggdGhlIHdpZHRoc1xuXHRcdFx0aWYgKCAkY29sZ3JvdXAubGVuZ3RoICYmICRjb2xncm91cC5oYXNDbGFzcyggdHMuY3NzLmNvbGdyb3VwICkgKSB7XG5cdFx0XHRcdCRjb2xncm91cC5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdGlmICggYy53aWR0aEZpeGVkICYmIGMuJHRhYmxlLmNoaWxkcmVuKCAnY29sZ3JvdXAnICkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHQkY29sZ3JvdXAgPSAkKCAnPGNvbGdyb3VwIGNsYXNzPVwiJyArIHRzLmNzcy5jb2xncm91cCArICdcIj4nICk7XG5cdFx0XHRcdG92ZXJhbGxXaWR0aCA9IGMuJHRhYmxlLndpZHRoKCk7XG5cdFx0XHRcdC8vIG9ubHkgYWRkIGNvbCBmb3IgdmlzaWJsZSBjb2x1bW5zIC0gZml4ZXMgIzM3MVxuXHRcdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMuZmluZCggJ3RyOmZpcnN0JyApLmNoaWxkcmVuKCAnOnZpc2libGUnICk7XG5cdFx0XHRcdGxlbiA9ICR0Ym9kaWVzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRwZXJjZW50ID0gcGFyc2VJbnQoICggJHRib2RpZXMuZXEoIGluZGV4ICkud2lkdGgoKSAvIG92ZXJhbGxXaWR0aCApICogMTAwMCwgMTAgKSAvIDEwICsgJyUnO1xuXHRcdFx0XHRcdCRjb2xncm91cC5hcHBlbmQoICQoICc8Y29sPicgKS5jc3MoICd3aWR0aCcsIHBlcmNlbnQgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMuJHRhYmxlLnByZXBlbmQoICRjb2xncm91cCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBnZXQgc29ydGVyLCBzdHJpbmcsIGVtcHR5LCBldGMgb3B0aW9ucyBmb3IgZWFjaCBjb2x1bW4gZnJvbVxuXHRcdC8vIGpRdWVyeSBkYXRhLCBtZXRhZGF0YSwgaGVhZGVyIG9wdGlvbiBvciBoZWFkZXIgY2xhc3MgbmFtZSAoJ3NvcnRlci1mYWxzZScpXG5cdFx0Ly8gcHJpb3JpdHkgPSBqUXVlcnkgZGF0YSA+IG1ldGEgPiBoZWFkZXJzIG9wdGlvbiA+IGhlYWRlciBjbGFzcyBuYW1lXG5cdFx0Z2V0RGF0YSA6IGZ1bmN0aW9uKCBoZWFkZXIsIGNvbmZpZ0hlYWRlciwga2V5ICkge1xuXHRcdFx0dmFyIG1ldGEsIGNsNHNzLFxuXHRcdFx0XHR2YWwgPSAnJyxcblx0XHRcdFx0JGhlYWRlciA9ICQoIGhlYWRlciApO1xuXHRcdFx0aWYgKCAhJGhlYWRlci5sZW5ndGggKSB7IHJldHVybiAnJzsgfVxuXHRcdFx0bWV0YSA9ICQubWV0YWRhdGEgPyAkaGVhZGVyLm1ldGFkYXRhKCkgOiBmYWxzZTtcblx0XHRcdGNsNHNzID0gJyAnICsgKCAkaGVhZGVyLmF0dHIoICdjbGFzcycgKSB8fCAnJyApO1xuXHRcdFx0aWYgKCB0eXBlb2YgJGhlYWRlci5kYXRhKCBrZXkgKSAhPT0gJ3VuZGVmaW5lZCcgfHxcblx0XHRcdFx0dHlwZW9mICRoZWFkZXIuZGF0YSgga2V5LnRvTG93ZXJDYXNlKCkgKSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vICdkYXRhLWxvY2tlZE9yZGVyJyBpcyBhc3NpZ25lZCB0byAnbG9ja2Vkb3JkZXInOyBidXQgJ2RhdGEtbG9ja2VkLW9yZGVyJyBpcyBhc3NpZ25lZCB0byAnbG9ja2VkT3JkZXInXG5cdFx0XHRcdC8vICdkYXRhLXNvcnQtaW5pdGlhbC1vcmRlcicgaXMgYXNzaWduZWQgdG8gJ3NvcnRJbml0aWFsT3JkZXInXG5cdFx0XHRcdHZhbCArPSAkaGVhZGVyLmRhdGEoIGtleSApIHx8ICRoZWFkZXIuZGF0YSgga2V5LnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG1ldGEgJiYgdHlwZW9mIG1ldGFbIGtleSBdICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0dmFsICs9IG1ldGFbIGtleSBdO1xuXHRcdFx0fSBlbHNlIGlmICggY29uZmlnSGVhZGVyICYmIHR5cGVvZiBjb25maWdIZWFkZXJbIGtleSBdICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0dmFsICs9IGNvbmZpZ0hlYWRlclsga2V5IF07XG5cdFx0XHR9IGVsc2UgaWYgKCBjbDRzcyAhPT0gJyAnICYmIGNsNHNzLm1hdGNoKCAnICcgKyBrZXkgKyAnLScgKSApIHtcblx0XHRcdFx0Ly8gaW5jbHVkZSBzb3J0ZXIgY2xhc3MgbmFtZSAnc29ydGVyLXRleHQnLCBldGM7IG5vdyB3b3JrcyB3aXRoICdzb3J0ZXItbXktY3VzdG9tLXBhcnNlcidcblx0XHRcdFx0dmFsID0gY2w0c3MubWF0Y2goIG5ldyBSZWdFeHAoICdcXFxccycgKyBrZXkgKyAnLShbXFxcXHctXSspJyApIClbIDEgXSB8fCAnJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAkLnRyaW0oIHZhbCApO1xuXHRcdH0sXG5cblx0XHRnZXRDb2x1bW5EYXRhIDogZnVuY3Rpb24oIHRhYmxlLCBvYmosIGluZHgsIGdldENlbGwsICRoZWFkZXJzICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTtcblx0XHRcdHZhciAkaGVhZGVyLCBrZXksXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdCRjZWxscyA9ICggJGhlYWRlcnMgfHwgYy4kaGVhZGVycyApLFxuXHRcdFx0XHQvLyBjLiRoZWFkZXJJbmRleGVkIGlzIG5vdCBkZWZpbmVkIGluaXRpYWxseVxuXHRcdFx0XHQkY2VsbCA9IGMuJGhlYWRlckluZGV4ZWQgJiYgYy4kaGVhZGVySW5kZXhlZFsgaW5keCBdIHx8XG5cdFx0XHRcdFx0JGNlbGxzLmZpbmQoICdbZGF0YS1jb2x1bW49XCInICsgaW5keCArICdcIl06bGFzdCcgKTtcblx0XHRcdGlmICggdHlwZW9mIG9ialsgaW5keCBdICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0cmV0dXJuIGdldENlbGwgPyBvYmpbIGluZHggXSA6IG9ialsgJGNlbGxzLmluZGV4KCAkY2VsbCApIF07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdCRoZWFkZXIgPSAkY2VsbFxuXHRcdFx0XHRcdFx0Ly8gaGVhZGVyIGNlbGwgd2l0aCBjbGFzcy9pZFxuXHRcdFx0XHRcdFx0LmZpbHRlcigga2V5IClcblx0XHRcdFx0XHRcdC8vIGZpbmQgZWxlbWVudHMgd2l0aGluIHRoZSBoZWFkZXIgY2VsbCB3aXRoIGNlbGwvaWRcblx0XHRcdFx0XHRcdC5hZGQoICRjZWxsLmZpbmQoIGtleSApICk7XG5cdFx0XHRcdFx0aWYgKCAkaGVhZGVyLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBvYmpbIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH0sXG5cblx0XHQvLyAqKiogUHJvY2VzcyB0YWJsZSAqKipcblx0XHQvLyBhZGQgcHJvY2Vzc2luZyBpbmRpY2F0b3Jcblx0XHRpc1Byb2Nlc3NpbmcgOiBmdW5jdGlvbiggJHRhYmxlLCB0b2dnbGUsICRoZWFkZXJzICkge1xuXHRcdFx0JHRhYmxlID0gJCggJHRhYmxlICk7XG5cdFx0XHR2YXIgYyA9ICR0YWJsZVsgMCBdLmNvbmZpZyxcblx0XHRcdFx0Ly8gZGVmYXVsdCB0byBhbGwgaGVhZGVyc1xuXHRcdFx0XHQkaGVhZGVyID0gJGhlYWRlcnMgfHwgJHRhYmxlLmZpbmQoICcuJyArIHRzLmNzcy5oZWFkZXIgKTtcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHQvLyBkb24ndCB1c2Ugc29ydExpc3QgaWYgY3VzdG9tICRoZWFkZXJzIHVzZWRcblx0XHRcdFx0aWYgKCB0eXBlb2YgJGhlYWRlcnMgIT09ICd1bmRlZmluZWQnICYmIGMuc29ydExpc3QubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHQvLyBnZXQgaGVhZGVycyBmcm9tIHRoZSBzb3J0TGlzdFxuXHRcdFx0XHRcdCRoZWFkZXIgPSAkaGVhZGVyLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQvLyBnZXQgZGF0YS1jb2x1bW4gZnJvbSBhdHRyIHRvIGtlZXAgY29tcGF0aWJpbGl0eSB3aXRoIGpRdWVyeSAxLjIuNlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc29ydERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0ZmFsc2UgOlxuXHRcdFx0XHRcdFx0XHR0cy5pc1ZhbHVlSW5BcnJheSggcGFyc2VGbG9hdCggJCggdGhpcyApLmF0dHIoICdkYXRhLWNvbHVtbicgKSApLCBjLnNvcnRMaXN0ICkgPj0gMDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkdGFibGUuYWRkKCAkaGVhZGVyICkuYWRkQ2xhc3MoIHRzLmNzcy5wcm9jZXNzaW5nICsgJyAnICsgYy5jc3NQcm9jZXNzaW5nICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkdGFibGUuYWRkKCAkaGVhZGVyICkucmVtb3ZlQ2xhc3MoIHRzLmNzcy5wcm9jZXNzaW5nICsgJyAnICsgYy5jc3NQcm9jZXNzaW5nICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGRldGFjaCB0Ym9keSBidXQgc2F2ZSB0aGUgcG9zaXRpb25cblx0XHQvLyBkb24ndCB1c2UgdGJvZHkgYmVjYXVzZSB0aGVyZSBhcmUgcG9ydGlvbnMgdGhhdCBsb29rIGZvciBhIHRib2R5IGluZGV4ICh1cGRhdGVDZWxsKVxuXHRcdHByb2Nlc3NUYm9keSA6IGZ1bmN0aW9uKCB0YWJsZSwgJHRiLCBnZXRJdCApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVsgMCBdO1xuXHRcdFx0aWYgKCBnZXRJdCApIHtcblx0XHRcdFx0dGFibGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHRcdFx0JHRiLmJlZm9yZSggJzxjb2xncm91cCBjbGFzcz1cInRhYmxlc29ydGVyLXNhdmVteXBsYWNlXCIvPicgKTtcblx0XHRcdFx0cmV0dXJuICQuZm4uZGV0YWNoID8gJHRiLmRldGFjaCgpIDogJHRiLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhvbGRyID0gJCggdGFibGUgKS5maW5kKCAnY29sZ3JvdXAudGFibGVzb3J0ZXItc2F2ZW15cGxhY2UnICk7XG5cdFx0XHQkdGIuaW5zZXJ0QWZ0ZXIoIGhvbGRyICk7XG5cdFx0XHRob2xkci5yZW1vdmUoKTtcblx0XHRcdHRhYmxlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRjbGVhclRhYmxlQm9keSA6IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdCQoIHRhYmxlIClbIDAgXS5jb25maWcuJHRib2RpZXMuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHR9LFxuXG5cdFx0Ly8gdXNlZCB3aGVuIHJlcGxhY2luZyBhY2NlbnRlZCBjaGFyYWN0ZXJzIGR1cmluZyBzb3J0aW5nXG5cdFx0Y2hhcmFjdGVyRXF1aXZhbGVudHMgOiB7XG5cdFx0XHQnYScgOiAnXFx1MDBlMVxcdTAwZTBcXHUwMGUyXFx1MDBlM1xcdTAwZTRcXHUwMTA1XFx1MDBlNScsIC8vIMOhw6DDosOjw6TEhcOlXG5cdFx0XHQnQScgOiAnXFx1MDBjMVxcdTAwYzBcXHUwMGMyXFx1MDBjM1xcdTAwYzRcXHUwMTA0XFx1MDBjNScsIC8vIMOBw4DDgsODw4TEhMOFXG5cdFx0XHQnYycgOiAnXFx1MDBlN1xcdTAxMDdcXHUwMTBkJywgLy8gw6fEh8SNXG5cdFx0XHQnQycgOiAnXFx1MDBjN1xcdTAxMDZcXHUwMTBjJywgLy8gw4fEhsSMXG5cdFx0XHQnZScgOiAnXFx1MDBlOVxcdTAwZThcXHUwMGVhXFx1MDBlYlxcdTAxMWJcXHUwMTE5JywgLy8gw6nDqMOqw6vEm8SZXG5cdFx0XHQnRScgOiAnXFx1MDBjOVxcdTAwYzhcXHUwMGNhXFx1MDBjYlxcdTAxMWFcXHUwMTE4JywgLy8gw4nDiMOKw4vEmsSYXG5cdFx0XHQnaScgOiAnXFx1MDBlZFxcdTAwZWNcXHUwMTMwXFx1MDBlZVxcdTAwZWZcXHUwMTMxJywgLy8gw63DrMSww67Dr8SxXG5cdFx0XHQnSScgOiAnXFx1MDBjZFxcdTAwY2NcXHUwMTMwXFx1MDBjZVxcdTAwY2YnLCAvLyDDjcOMxLDDjsOPXG5cdFx0XHQnbycgOiAnXFx1MDBmM1xcdTAwZjJcXHUwMGY0XFx1MDBmNVxcdTAwZjZcXHUwMTRkJywgLy8gw7PDssO0w7XDtsWNXG5cdFx0XHQnTycgOiAnXFx1MDBkM1xcdTAwZDJcXHUwMGQ0XFx1MDBkNVxcdTAwZDZcXHUwMTRjJywgLy8gw5PDksOUw5XDlsWMXG5cdFx0XHQnc3MnOiAnXFx1MDBkZicsIC8vIMOfIChzIHNoYXJwKVxuXHRcdFx0J1NTJzogJ1xcdTFlOWUnLCAvLyDhup4gKENhcGl0YWwgc2hhcnAgcylcblx0XHRcdCd1JyA6ICdcXHUwMGZhXFx1MDBmOVxcdTAwZmJcXHUwMGZjXFx1MDE2ZicsIC8vIMO6w7nDu8O8xa9cblx0XHRcdCdVJyA6ICdcXHUwMGRhXFx1MDBkOVxcdTAwZGJcXHUwMGRjXFx1MDE2ZScgLy8gw5rDmcObw5zFrlxuXHRcdH0sXG5cblx0XHRyZXBsYWNlQWNjZW50cyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgY2hyLFxuXHRcdFx0XHRhY2MgPSAnWycsXG5cdFx0XHRcdGVxID0gdHMuY2hhcmFjdGVyRXF1aXZhbGVudHM7XG5cdFx0XHRpZiAoICF0cy5jaGFyYWN0ZXJSZWdleCApIHtcblx0XHRcdFx0dHMuY2hhcmFjdGVyUmVnZXhBcnJheSA9IHt9O1xuXHRcdFx0XHRmb3IgKCBjaHIgaW4gZXEgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY2hyID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGFjYyArPSBlcVsgY2hyIF07XG5cdFx0XHRcdFx0XHR0cy5jaGFyYWN0ZXJSZWdleEFycmF5WyBjaHIgXSA9IG5ldyBSZWdFeHAoICdbJyArIGVxWyBjaHIgXSArICddJywgJ2cnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRzLmNoYXJhY3RlclJlZ2V4ID0gbmV3IFJlZ0V4cCggYWNjICsgJ10nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmNoYXJhY3RlclJlZ2V4LnRlc3QoIHN0ciApICkge1xuXHRcdFx0XHRmb3IgKCBjaHIgaW4gZXEgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY2hyID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKCB0cy5jaGFyYWN0ZXJSZWdleEFycmF5WyBjaHIgXSwgY2hyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH0sXG5cblx0XHR2YWxpZGF0ZU9wdGlvbnMgOiBmdW5jdGlvbiggYyApIHtcblx0XHRcdHZhciBzZXR0aW5nLCBzZXR0aW5nMiwgdHlwLCB0aW1lcixcblx0XHRcdFx0Ly8gaWdub3JlIG9wdGlvbnMgY29udGFpbmluZyBhbiBhcnJheVxuXHRcdFx0XHRpZ25vcmUgPSAnaGVhZGVycyBzb3J0Rm9yY2Ugc29ydExpc3Qgc29ydEFwcGVuZCB3aWRnZXRzJy5zcGxpdCggJyAnICksXG5cdFx0XHRcdG9yaWcgPSBjLm9yaWdpbmFsU2V0dGluZ3M7XG5cdFx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHR0aW1lciA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggc2V0dGluZyBpbiBvcmlnICkge1xuXHRcdFx0XHRcdHR5cCA9IHR5cGVvZiB0cy5kZWZhdWx0c1tzZXR0aW5nXTtcblx0XHRcdFx0XHRpZiAoIHR5cCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUYWJsZXNvcnRlciBXYXJuaW5nISBcInRhYmxlLmNvbmZpZy4nICsgc2V0dGluZyArICdcIiBvcHRpb24gbm90IHJlY29nbml6ZWQnICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHNldHRpbmcyIGluIG9yaWdbc2V0dGluZ10gKSB7XG5cdFx0XHRcdFx0XHRcdHR5cCA9IHRzLmRlZmF1bHRzW3NldHRpbmddICYmIHR5cGVvZiB0cy5kZWZhdWx0c1tzZXR0aW5nXVtzZXR0aW5nMl07XG5cdFx0XHRcdFx0XHRcdGlmICggJC5pbkFycmF5KCBzZXR0aW5nLCBpZ25vcmUgKSA8IDAgJiYgdHlwID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUYWJsZXNvcnRlciBXYXJuaW5nISBcInRhYmxlLmNvbmZpZy4nICsgc2V0dGluZyArICcuJyArIHNldHRpbmcyICsgJ1wiIG9wdGlvbiBub3QgcmVjb2duaXplZCcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICd2YWxpZGF0ZSBvcHRpb25zIHRpbWU6JyArIHRzLmJlbmNobWFyayggdGltZXIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIHJlc3RvcmUgaGVhZGVyc1xuXHRcdHJlc3RvcmVIZWFkZXJzIDogZnVuY3Rpb24oIHRhYmxlICkge1xuXHRcdFx0dmFyIGluZGV4LCAkY2VsbCxcblx0XHRcdFx0YyA9ICQoIHRhYmxlIClbIDAgXS5jb25maWcsXG5cdFx0XHRcdCRoZWFkZXJzID0gYy4kdGFibGUuZmluZCggYy5zZWxlY3RvckhlYWRlcnMgKSxcblx0XHRcdFx0bGVuID0gJGhlYWRlcnMubGVuZ3RoO1xuXHRcdFx0Ly8gZG9uJ3QgdXNlIGMuJGhlYWRlcnMgaGVyZSBpbiBjYXNlIGhlYWRlciBjZWxscyB3ZXJlIHN3YXBwZWRcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdCRjZWxsID0gJGhlYWRlcnMuZXEoIGluZGV4ICk7XG5cdFx0XHRcdC8vIG9ubHkgcmVzdG9yZSBoZWFkZXIgY2VsbHMgaWYgaXQgaXMgd3JhcHBlZFxuXHRcdFx0XHQvLyBiZWNhdXNlIHRoaXMgaXMgYWxzbyB1c2VkIGJ5IHRoZSB1cGRhdGVBbGwgbWV0aG9kXG5cdFx0XHRcdGlmICggJGNlbGwuZmluZCggJy4nICsgdHMuY3NzLmhlYWRlckluICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdCRjZWxsLmh0bWwoIGMuaGVhZGVyQ29udGVudFsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3kgOiBmdW5jdGlvbiggdGFibGUsIHJlbW92ZUNsYXNzZXMsIGNhbGxiYWNrICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWyAwIF07XG5cdFx0XHRpZiAoICF0YWJsZS5oYXNJbml0aWFsaXplZCApIHsgcmV0dXJuOyB9XG5cdFx0XHQvLyByZW1vdmUgYWxsIHdpZGdldHNcblx0XHRcdHRzLnJlbW92ZVdpZGdldCggdGFibGUsIHRydWUsIGZhbHNlICk7XG5cdFx0XHR2YXIgZXZlbnRzLFxuXHRcdFx0XHQkdCA9ICQoIHRhYmxlICksXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdCRoID0gJHQuZmluZCggJ3RoZWFkOmZpcnN0JyApLFxuXHRcdFx0XHQkciA9ICRoLmZpbmQoICd0ci4nICsgdHMuY3NzLmhlYWRlclJvdyApLnJlbW92ZUNsYXNzKCB0cy5jc3MuaGVhZGVyUm93ICsgJyAnICsgYy5jc3NIZWFkZXJSb3cgKSxcblx0XHRcdFx0JGYgPSAkdC5maW5kKCAndGZvb3Q6Zmlyc3QgPiB0cicgKS5jaGlsZHJlbiggJ3RoLCB0ZCcgKTtcblx0XHRcdGlmICggcmVtb3ZlQ2xhc3NlcyA9PT0gZmFsc2UgJiYgJC5pbkFycmF5KCAndWl0aGVtZScsIGMud2lkZ2V0cyApID49IDAgKSB7XG5cdFx0XHRcdC8vIHJlYXBwbHkgdWl0aGVtZSBjbGFzc2VzLCBpbiBjYXNlIHdlIHdhbnQgdG8gbWFpbnRhaW4gYXBwZWFyYW5jZVxuXHRcdFx0XHQkdC50cmlnZ2VySGFuZGxlciggJ2FwcGx5V2lkZ2V0SWQnLCBbICd1aXRoZW1lJyBdICk7XG5cdFx0XHRcdCR0LnRyaWdnZXJIYW5kbGVyKCAnYXBwbHlXaWRnZXRJZCcsIFsgJ3plYnJhJyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZW1vdmUgd2lkZ2V0IGFkZGVkIHJvd3MsIGp1c3QgaW4gY2FzZVxuXHRcdFx0JGguZmluZCggJ3RyJyApLm5vdCggJHIgKS5yZW1vdmUoKTtcblx0XHRcdC8vIGRpc2FibGUgdGFibGVzb3J0ZXIgLSBub3QgdXNpbmcgLnVuYmluZCggbmFtZXNwYWNlICkgYmVjYXVzZSBuYW1lc3BhY2luZyB3YXNcblx0XHRcdC8vIGFkZGVkIGluIGpRdWVyeSB2MS40LjMgLSBzZWUgaHR0cDovL2FwaS5qcXVlcnkuY29tL2V2ZW50Lm5hbWVzcGFjZS9cblx0XHRcdGV2ZW50cyA9ICdzb3J0UmVzZXQgdXBkYXRlIHVwZGF0ZVJvd3MgdXBkYXRlQWxsIHVwZGF0ZUhlYWRlcnMgdXBkYXRlQ2VsbCBhZGRSb3dzIHVwZGF0ZUNvbXBsZXRlIHNvcnRvbiAnICtcblx0XHRcdFx0J2FwcGVuZENhY2hlIHVwZGF0ZUNhY2hlIGFwcGx5V2lkZ2V0SWQgYXBwbHlXaWRnZXRzIHJlZnJlc2hXaWRnZXRzIHJlbW92ZVdpZGdldCBkZXN0cm95IG1vdXNldXAgbW91c2VsZWF2ZSAnICtcblx0XHRcdFx0J2tleXByZXNzIHNvcnRCZWdpbiBzb3J0RW5kIHJlc2V0VG9Mb2FkU3RhdGUgJy5zcGxpdCggJyAnIClcblx0XHRcdFx0LmpvaW4oIGMubmFtZXNwYWNlICsgJyAnICk7XG5cdFx0XHQkdFxuXHRcdFx0XHQucmVtb3ZlRGF0YSggJ3RhYmxlc29ydGVyJyApXG5cdFx0XHRcdC51bmJpbmQoIGV2ZW50cy5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApICk7XG5cdFx0XHRjLiRoZWFkZXJzXG5cdFx0XHRcdC5hZGQoICRmIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBbIHRzLmNzcy5oZWFkZXIsIGMuY3NzSGVhZGVyLCBjLmNzc0FzYywgYy5jc3NEZXNjLCB0cy5jc3Muc29ydEFzYywgdHMuY3NzLnNvcnREZXNjLCB0cy5jc3Muc29ydE5vbmUgXS5qb2luKCAnICcgKSApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCAnZGF0YS1jb2x1bW4nIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoICdhcmlhLWxhYmVsJyApXG5cdFx0XHRcdC5hdHRyKCAnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyApO1xuXHRcdFx0JHJcblx0XHRcdFx0LmZpbmQoIGMuc2VsZWN0b3JTb3J0IClcblx0XHRcdFx0LnVuYmluZCggKCAnbW91c2Vkb3duIG1vdXNldXAga2V5cHJlc3MgJy5zcGxpdCggJyAnICkuam9pbiggYy5uYW1lc3BhY2UgKyAnICcgKSApLnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnICkgKTtcblx0XHRcdHRzLnJlc3RvcmVIZWFkZXJzKCB0YWJsZSApO1xuXHRcdFx0JHQudG9nZ2xlQ2xhc3MoIHRzLmNzcy50YWJsZSArICcgJyArIGMudGFibGVDbGFzcyArICcgdGFibGVzb3J0ZXItJyArIGMudGhlbWUsIHJlbW92ZUNsYXNzZXMgPT09IGZhbHNlICk7XG5cdFx0XHQkdC5yZW1vdmVDbGFzcyhjLm5hbWVzcGFjZS5zbGljZSgxKSk7XG5cdFx0XHQvLyBjbGVhciBmbGFnIGluIGNhc2UgdGhlIHBsdWdpbiBpcyBpbml0aWFsaXplZCBhZ2FpblxuXHRcdFx0dGFibGUuaGFzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0XHRcdGRlbGV0ZSB0YWJsZS5jb25maWcuY2FjaGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Y2FsbGJhY2soIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAndGFibGVzb3J0ZXIgaGFzIGJlZW4gcmVtb3ZlZCcgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fTtcblxuXHQkLmZuLnRhYmxlc29ydGVyID0gZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlID0gdGhpcyxcblx0XHRcdC8vIG1lcmdlICYgZXh0ZW5kIGNvbmZpZyBvcHRpb25zXG5cdFx0XHRjID0gJC5leHRlbmQoIHRydWUsIHt9LCB0cy5kZWZhdWx0cywgc2V0dGluZ3MsIHRzLmluc3RhbmNlTWV0aG9kcyApO1xuXHRcdFx0Ly8gc2F2ZSBpbml0aWFsIHNldHRpbmdzXG5cdFx0XHRjLm9yaWdpbmFsU2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHRcdC8vIGNyZWF0ZSBhIHRhYmxlIGZyb20gZGF0YSAoYnVpbGQgdGFibGUgd2lkZ2V0KVxuXHRcdFx0aWYgKCAhdGFibGUuaGFzSW5pdGlhbGl6ZWQgJiYgdHMuYnVpbGRUYWJsZSAmJiB0aGlzLm5vZGVOYW1lICE9PSAnVEFCTEUnICkge1xuXHRcdFx0XHQvLyByZXR1cm4gdGhlIHRhYmxlIChpbiBjYXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQgaXMgdGhlIHRhYmxlJ3MgY29udGFpbmVyKVxuXHRcdFx0XHR0cy5idWlsZFRhYmxlKCB0YWJsZSwgYyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHMuc2V0dXAoIHRhYmxlLCBjICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0Ly8gc2V0IHVwIGRlYnVnIGxvZ3Ncblx0aWYgKCAhKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cgKSApIHtcblx0XHQvLyBhY2Nlc3MgJC50YWJsZXNvcnRlci5sb2dzIGZvciBicm93c2VycyB0aGF0IGRvbid0IGhhdmUgYSBjb25zb2xlLi4uXG5cdFx0dHMubG9ncyA9IFtdO1xuXHRcdC8qanNoaW50IC1XMDIwICovXG5cdFx0Y29uc29sZSA9IHt9O1xuXHRcdGNvbnNvbGUubG9nID0gY29uc29sZS53YXJuID0gY29uc29sZS5lcnJvciA9IGNvbnNvbGUudGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXTtcblx0XHRcdHRzLmxvZ3NbIHRzLmxvZ3MubGVuZ3RoIF0gPSB7IGRhdGU6IERhdGUubm93KCksIGxvZzogYXJnIH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIGFkZCBkZWZhdWx0IHBhcnNlcnNcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICduby1wYXJzZXInLFxuXHRcdGlzIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXHRcdHR5cGUgOiAndGV4dCdcblx0fSk7XG5cblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICd0ZXh0Jyxcblx0XHRpcyA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSApIHtcblx0XHRcdHZhciBjID0gdGFibGUuY29uZmlnO1xuXHRcdFx0aWYgKCBzdHIgKSB7XG5cdFx0XHRcdHN0ciA9ICQudHJpbSggYy5pZ25vcmVDYXNlID8gc3RyLnRvTG9jYWxlTG93ZXJDYXNlKCkgOiBzdHIgKTtcblx0XHRcdFx0c3RyID0gYy5zb3J0TG9jYWxlQ29tcGFyZSA/IHRzLnJlcGxhY2VBY2NlbnRzKCBzdHIgKSA6IHN0cjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fSxcblx0XHR0eXBlIDogJ3RleHQnXG5cdH0pO1xuXG5cdHRzLnJlZ2V4Lm5vbmRpZ2l0ID0gL1teXFx3LC4gXFwtKCldL2c7XG5cdHRzLmFkZFBhcnNlcih7XG5cdFx0aWQgOiAnZGlnaXQnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiB0cy5pc0RpZ2l0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlICkge1xuXHRcdFx0dmFyIG51bSA9IHRzLmZvcm1hdEZsb2F0KCAoIHN0ciB8fCAnJyApLnJlcGxhY2UoIHRzLnJlZ2V4Lm5vbmRpZ2l0LCAnJyApLCB0YWJsZSApO1xuXHRcdFx0cmV0dXJuIHN0ciAmJiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyA/IG51bSA6XG5cdFx0XHRcdHN0ciA/ICQudHJpbSggc3RyICYmIHRhYmxlLmNvbmZpZy5pZ25vcmVDYXNlID8gc3RyLnRvTG9jYWxlTG93ZXJDYXNlKCkgOiBzdHIgKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0dHMucmVnZXguY3VycmVuY3lSZXBsYWNlID0gL1srXFwtLC4gXS9nO1xuXHR0cy5yZWdleC5jdXJyZW5jeVRlc3QgPSAvXlxcKD9cXGQrW1xcdTAwYTMkXFx1MjBhY1xcdTAwYTRcXHUwMGE1XFx1MDBhMj8uXXxbXFx1MDBhMyRcXHUyMGFjXFx1MDBhNFxcdTAwYTVcXHUwMGEyPy5dXFxkK1xcKT8kLztcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdjdXJyZW5jeScsXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0c3RyID0gKCBzdHIgfHwgJycgKS5yZXBsYWNlKCB0cy5yZWdleC5jdXJyZW5jeVJlcGxhY2UsICcnICk7XG5cdFx0XHQvLyB0ZXN0IGZvciDCoyTigqzCpMKlwqJcblx0XHRcdHJldHVybiB0cy5yZWdleC5jdXJyZW5jeVRlc3QudGVzdCggc3RyICk7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSApIHtcblx0XHRcdHZhciBudW0gPSB0cy5mb3JtYXRGbG9hdCggKCBzdHIgfHwgJycgKS5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSwgdGFibGUgKTtcblx0XHRcdHJldHVybiBzdHIgJiYgdHlwZW9mIG51bSA9PT0gJ251bWJlcicgPyBudW0gOlxuXHRcdFx0XHRzdHIgPyAkLnRyaW0oIHN0ciAmJiB0YWJsZS5jb25maWcuaWdub3JlQ2FzZSA/IHN0ci50b0xvY2FsZUxvd2VyQ2FzZSgpIDogc3RyICkgOiBzdHI7XG5cdFx0fSxcblx0XHR0eXBlIDogJ251bWVyaWMnXG5cdH0pO1xuXG5cdC8vIHRvbyBtYW55IHByb3RvY29scyB0byBhZGQgdGhlbSBhbGwgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJJX3NjaGVtZVxuXHQvLyBub3csIHRoaXMgcmVnZXggY2FuIGJlIHVwZGF0ZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uXG5cdHRzLnJlZ2V4LnVybFByb3RvY29sVGVzdCA9IC9eKGh0dHBzP3xmdHB8ZmlsZSk6XFwvXFwvLztcblx0dHMucmVnZXgudXJsUHJvdG9jb2xSZXBsYWNlID0gLyhodHRwcz98ZnRwfGZpbGUpOlxcL1xcLyh3d3dcXC4pPy87XG5cdHRzLmFkZFBhcnNlcih7XG5cdFx0aWQgOiAndXJsJyxcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gdHMucmVnZXgudXJsUHJvdG9jb2xUZXN0LnRlc3QoIHN0ciApO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIgPyAkLnRyaW0oIHN0ci5yZXBsYWNlKCB0cy5yZWdleC51cmxQcm90b2NvbFJlcGxhY2UsICcnICkgKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAndGV4dCdcblx0fSk7XG5cblx0dHMucmVnZXguZGFzaCA9IC8tL2c7XG5cdHRzLnJlZ2V4Lmlzb0RhdGUgPSAvXlxcZHs0fVtcXC9cXC1dXFxkezEsMn1bXFwvXFwtXVxcZHsxLDJ9Lztcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdpc29EYXRlJyxcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gdHMucmVnZXguaXNvRGF0ZS50ZXN0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHN0ciA/IG5ldyBEYXRlKCBzdHIucmVwbGFjZSggdHMucmVnZXguZGFzaCwgJy8nICkgKSA6IHN0cjtcblx0XHRcdHJldHVybiBkYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBpc0Zpbml0ZSggZGF0ZSApID8gZGF0ZS5nZXRUaW1lKCkgOiBzdHI7XG5cdFx0fSxcblx0XHR0eXBlIDogJ251bWVyaWMnXG5cdH0pO1xuXG5cdHRzLnJlZ2V4LnBlcmNlbnQgPSAvJS9nO1xuXHR0cy5yZWdleC5wZXJjZW50VGVzdCA9IC8oXFxkXFxzKj8lfCVcXHMqP1xcZCkvO1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ3BlcmNlbnQnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiB0cy5yZWdleC5wZXJjZW50VGVzdC50ZXN0KCBzdHIgKSAmJiBzdHIubGVuZ3RoIDwgMTU7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSApIHtcblx0XHRcdHJldHVybiBzdHIgPyB0cy5mb3JtYXRGbG9hdCggc3RyLnJlcGxhY2UoIHRzLnJlZ2V4LnBlcmNlbnQsICcnICksIHRhYmxlICkgOiBzdHI7XG5cdFx0fSxcblx0XHR0eXBlIDogJ251bWVyaWMnXG5cdH0pO1xuXG5cdC8vIGFkZGVkIGltYWdlIHBhcnNlciB0byBjb3JlIHYyLjE3Ljlcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdpbWFnZScsXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSwgbm9kZSwgJG5vZGUgKSB7XG5cdFx0XHRyZXR1cm4gJG5vZGUuZmluZCggJ2ltZycgKS5sZW5ndGggPiAwO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciwgdGFibGUsIGNlbGwgKSB7XG5cdFx0XHRyZXR1cm4gJCggY2VsbCApLmZpbmQoICdpbWcnICkuYXR0ciggdGFibGUuY29uZmlnLmltZ0F0dHIgfHwgJ2FsdCcgKSB8fCBzdHI7XG5cdFx0fSxcblx0XHRwYXJzZWQgOiB0cnVlLCAvLyBmaWx0ZXIgd2lkZ2V0IGZsYWdcblx0XHR0eXBlIDogJ3RleHQnXG5cdH0pO1xuXG5cdHRzLnJlZ2V4LmRhdGVSZXBsYWNlID0gLyhcXFMpKFtBUF1NKSQvaTsgLy8gdXNlZCBieSB1c0xvbmdEYXRlICYgdGltZSBwYXJzZXJcblx0dHMucmVnZXgudXNMb25nRGF0ZVRlc3QxID0gL15bQS1aXXszLDEwfVxcLj9cXHMrXFxkezEsMn0sP1xccysoXFxkezR9KShcXHMrXFxkezEsMn06XFxkezJ9KDpcXGR7Mn0pPyhcXHMrW0FQXU0pPyk/JC9pO1xuXHR0cy5yZWdleC51c0xvbmdEYXRlVGVzdDIgPSAvXlxcZHsxLDJ9XFxzK1tBLVpdezMsMTB9XFxzK1xcZHs0fS9pO1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ3VzTG9uZ0RhdGUnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdC8vIHR3byBkaWdpdCB5ZWFycyBhcmUgbm90IGFsbG93ZWQgY3Jvc3MtYnJvd3NlclxuXHRcdFx0Ly8gSmFuIDAxLCAyMDEzIDEyOjM0OjU2IFBNIG9yIDAxIEphbiAyMDEzXG5cdFx0XHRyZXR1cm4gdHMucmVnZXgudXNMb25nRGF0ZVRlc3QxLnRlc3QoIHN0ciApIHx8IHRzLnJlZ2V4LnVzTG9uZ0RhdGVUZXN0Mi50ZXN0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IHN0ciA/IG5ldyBEYXRlKCBzdHIucmVwbGFjZSggdHMucmVnZXguZGF0ZVJlcGxhY2UsICckMSAkMicgKSApIDogc3RyO1xuXHRcdFx0cmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGlzRmluaXRlKCBkYXRlICkgPyBkYXRlLmdldFRpbWUoKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0Ly8gdGVzdGluZyBmb3IgIyMtIyMtIyMjIyBvciAjIyMjLSMjLSMjLCBzbyBpdCdzIG5vdCBwZXJmZWN0OyB0aW1lIGNhbiBiZSBpbmNsdWRlZFxuXHR0cy5yZWdleC5zaG9ydERhdGVUZXN0ID0gLyheXFxkezEsMn1bXFwvXFxzXVxcZHsxLDJ9W1xcL1xcc11cXGR7NH0pfCheXFxkezR9W1xcL1xcc11cXGR7MSwyfVtcXC9cXHNdXFxkezEsMn0pLztcblx0Ly8gZXNjYXBlZCBcIi1cIiBiZWNhdXNlIEpTSGludCBpbiBGaXJlZm94IHdhcyBzaG93aW5nIGl0IGFzIGFuIGVycm9yXG5cdHRzLnJlZ2V4LnNob3J0RGF0ZVJlcGxhY2UgPSAvW1xcLS4sXS9nO1xuXHQvLyBYWFkgY292ZXJzIE1EWSAmIERNWSBmb3JtYXRzXG5cdHRzLnJlZ2V4LnNob3J0RGF0ZVhYWSA9IC8oXFxkezEsMn0pW1xcL1xcc10oXFxkezEsMn0pW1xcL1xcc10oXFxkezR9KS87XG5cdHRzLnJlZ2V4LnNob3J0RGF0ZVlNRCA9IC8oXFxkezR9KVtcXC9cXHNdKFxcZHsxLDJ9KVtcXC9cXHNdKFxcZHsxLDJ9KS87XG5cdHRzLmNvbnZlcnRGb3JtYXQgPSBmdW5jdGlvbiggZGF0ZVN0cmluZywgZm9ybWF0ICkge1xuXHRcdGRhdGVTdHJpbmcgPSAoIGRhdGVTdHJpbmcgfHwgJycgKVxuXHRcdFx0LnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnIClcblx0XHRcdC5yZXBsYWNlKCB0cy5yZWdleC5zaG9ydERhdGVSZXBsYWNlLCAnLycgKTtcblx0XHRpZiAoIGZvcm1hdCA9PT0gJ21tZGR5eXl5JyApIHtcblx0XHRcdGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnJlcGxhY2UoIHRzLnJlZ2V4LnNob3J0RGF0ZVhYWSwgJyQzLyQxLyQyJyApO1xuXHRcdH0gZWxzZSBpZiAoIGZvcm1hdCA9PT0gJ2RkbW15eXl5JyApIHtcblx0XHRcdGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnJlcGxhY2UoIHRzLnJlZ2V4LnNob3J0RGF0ZVhYWSwgJyQzLyQyLyQxJyApO1xuXHRcdH0gZWxzZSBpZiAoIGZvcm1hdCA9PT0gJ3l5eXltbWRkJyApIHtcblx0XHRcdGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnJlcGxhY2UoIHRzLnJlZ2V4LnNob3J0RGF0ZVlNRCwgJyQxLyQyLyQzJyApO1xuXHRcdH1cblx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKCBkYXRlU3RyaW5nICk7XG5cdFx0cmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGlzRmluaXRlKCBkYXRlICkgPyBkYXRlLmdldFRpbWUoKSA6ICcnO1xuXHR9O1xuXG5cdHRzLmFkZFBhcnNlcih7XG5cdFx0aWQgOiAnc2hvcnREYXRlJywgLy8gJ21tZGR5eXl5JywgJ2RkbW15eXl5JyBvciAneXl5eW1tZGQnXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0c3RyID0gKCBzdHIgfHwgJycgKS5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApLnJlcGxhY2UoIHRzLnJlZ2V4LnNob3J0RGF0ZVJlcGxhY2UsICcvJyApO1xuXHRcdFx0cmV0dXJuIHRzLnJlZ2V4LnNob3J0RGF0ZVRlc3QudGVzdCggc3RyICk7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSwgY2VsbCwgY2VsbEluZGV4ICkge1xuXHRcdFx0aWYgKCBzdHIgKSB7XG5cdFx0XHRcdHZhciBjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJJbmRleGVkWyBjZWxsSW5kZXggXSxcblx0XHRcdFx0XHRmb3JtYXQgPSAkaGVhZGVyLmxlbmd0aCAmJiAkaGVhZGVyLmRhdGEoICdkYXRlRm9ybWF0JyApIHx8XG5cdFx0XHRcdFx0XHR0cy5nZXREYXRhKCAkaGVhZGVyLCB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgYy5oZWFkZXJzLCBjZWxsSW5kZXggKSwgJ2RhdGVGb3JtYXQnICkgfHxcblx0XHRcdFx0XHRcdGMuZGF0ZUZvcm1hdDtcblx0XHRcdFx0Ly8gc2F2ZSBmb3JtYXQgYmVjYXVzZSBnZXREYXRhIGNhbiBiZSBzbG93Li4uXG5cdFx0XHRcdGlmICggJGhlYWRlci5sZW5ndGggKSB7XG5cdFx0XHRcdFx0JGhlYWRlci5kYXRhKCAnZGF0ZUZvcm1hdCcsIGZvcm1hdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cy5jb252ZXJ0Rm9ybWF0KCBzdHIsIGZvcm1hdCApIHx8IHN0cjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fSxcblx0XHR0eXBlIDogJ251bWVyaWMnXG5cdH0pO1xuXG5cdC8vIG1hdGNoIDI0IGhvdXIgdGltZSAmIDEyIGhvdXJzIHRpbWUgKyBhbS9wbSAtIHNlZSBodHRwOi8vcmVnZXhyLmNvbS8zYzN0a1xuXHR0cy5yZWdleC50aW1lVGVzdCA9IC9eKDA/WzEtOV18MVswLTJdKTooWzAtNV1cXGQpKFxcc1tBUF1NKSR8XigoPzpbMDFdXFxkfFsyXVswLTRdKTpbMC01XVxcZCkkL2k7XG5cdHRzLnJlZ2V4LnRpbWVNYXRjaCA9IC8oMD9bMS05XXwxWzAtMl0pOihbMC01XVxcZCkoXFxzW0FQXU0pfCgoPzpbMDFdXFxkfFsyXVswLTRdKTpbMC01XVxcZCkvaTtcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICd0aW1lJyxcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gdHMucmVnZXgudGltZVRlc3QudGVzdCggc3RyICk7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0Ly8gaXNvbGF0ZSB0aW1lLi4uIGlnbm9yZSBtb250aCwgZGF5IGFuZCB5ZWFyXG5cdFx0XHR2YXIgdGVtcCxcblx0XHRcdFx0dGltZVBhcnQgPSAoIHN0ciB8fCAnJyApLm1hdGNoKCB0cy5yZWdleC50aW1lTWF0Y2ggKSxcblx0XHRcdFx0b3JpZyA9IG5ldyBEYXRlKCBzdHIgKSxcblx0XHRcdFx0Ly8gbm8gdGltZSBjb21wb25lbnQ/IGRlZmF1bHQgdG8gMDA6MDAgYnkgbGVhdmluZyBpdCBvdXQsIGJ1dCBvbmx5IGlmIHN0ciBpcyBkZWZpbmVkXG5cdFx0XHRcdHRpbWUgPSBzdHIgJiYgKCB0aW1lUGFydCAhPT0gbnVsbCA/IHRpbWVQYXJ0WyAwIF0gOiAnMDA6MDAgQU0nICksXG5cdFx0XHRcdGRhdGUgPSB0aW1lID8gbmV3IERhdGUoICcyMDAwLzAxLzAxICcgKyB0aW1lLnJlcGxhY2UoIHRzLnJlZ2V4LmRhdGVSZXBsYWNlLCAnJDEgJDInICkgKSA6IHRpbWU7XG5cdFx0XHRpZiAoIGRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGlzRmluaXRlKCBkYXRlICkgKSB7XG5cdFx0XHRcdHRlbXAgPSBvcmlnIGluc3RhbmNlb2YgRGF0ZSAmJiBpc0Zpbml0ZSggb3JpZyApID8gb3JpZy5nZXRUaW1lKCkgOiAwO1xuXHRcdFx0XHQvLyBpZiBvcmlnaW5hbCBzdHJpbmcgd2FzIGEgdmFsaWQgZGF0ZSwgYWRkIGl0IHRvIHRoZSBkZWNpbWFsIHNvIHRoZSBjb2x1bW4gc29ydHMgaW4gc29tZSBraW5kIG9mIG9yZGVyXG5cdFx0XHRcdC8vIGx1Y2tpbHkgbmV3IERhdGUoKSBpZ25vcmVzIHRoZSBkZWNpbWFsc1xuXHRcdFx0XHRyZXR1cm4gdGVtcCA/IHBhcnNlRmxvYXQoIGRhdGUuZ2V0VGltZSgpICsgJy4nICsgb3JpZy5nZXRUaW1lKCkgKSA6IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdtZXRhZGF0YScsXG5cdFx0aXMgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlLCBjZWxsICkge1xuXHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRwID0gKCAhYy5wYXJzZXJNZXRhZGF0YU5hbWUgKSA/ICdzb3J0VmFsdWUnIDogYy5wYXJzZXJNZXRhZGF0YU5hbWU7XG5cdFx0XHRyZXR1cm4gJCggY2VsbCApLm1ldGFkYXRhKClbIHAgXTtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0Lypcblx0XHTilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWhCDilojilojilojilojilojiloQg4paE4paI4paI4paI4paI4paEXG5cdFx0ICDiloTilojiloAgIOKWiOKWiOKWhOKWhCAgIOKWiOKWiOKWhOKWhOKWiOKWiCDilojilojiloTiloTilojilogg4paI4paI4paE4paE4paI4paIXG5cdFx04paE4paI4paAICAgIOKWiOKWiOKWgOKWgCAgIOKWiOKWiOKWgOKWgOKWiOKWiCDilojilojiloDiloDiloggIOKWiOKWiOKWgOKWgOKWiOKWiFxuXHRcdOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIIOKWiOKWiCAg4paI4paIXG5cdFx0Ki9cblx0Ly8gYWRkIGRlZmF1bHQgd2lkZ2V0c1xuXHR0cy5hZGRXaWRnZXQoe1xuXHRcdGlkIDogJ3plYnJhJyxcblx0XHRwcmlvcml0eSA6IDkwLFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCB0YWJsZSwgYywgd28gKSB7XG5cdFx0XHR2YXIgJHZpc2libGVSb3dzLCAkcm93LCBjb3VudCwgaXNFdmVuLCB0Ym9keUluZGV4LCByb3dJbmRleCwgbGVuLFxuXHRcdFx0XHRjaGlsZCA9IG5ldyBSZWdFeHAoIGMuY3NzQ2hpbGRSb3csICdpJyApLFxuXHRcdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMuYWRkKCAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfdGFibGUnICkuY2hpbGRyZW4oICd0Ym9keTpub3QoLicgKyBjLmNzc0luZm9CbG9jayArICcpJyApICk7XG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8ICR0Ym9kaWVzLmxlbmd0aDsgdGJvZHlJbmRleCsrICkge1xuXHRcdFx0XHQvLyBsb29wIHRocm91Z2ggdGhlIHZpc2libGUgcm93c1xuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRcdCR2aXNpYmxlUm93cyA9ICR0Ym9kaWVzLmVxKCB0Ym9keUluZGV4ICkuY2hpbGRyZW4oICd0cjp2aXNpYmxlJyApLm5vdCggYy5zZWxlY3RvclJlbW92ZSApO1xuXHRcdFx0XHRsZW4gPSAkdmlzaWJsZVJvd3MubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgbGVuOyByb3dJbmRleCsrICkge1xuXHRcdFx0XHRcdCRyb3cgPSAkdmlzaWJsZVJvd3MuZXEoIHJvd0luZGV4ICk7XG5cdFx0XHRcdFx0Ly8gc3R5bGUgY2hpbGQgcm93cyB0aGUgc2FtZSB3YXkgdGhlIHBhcmVudCByb3cgd2FzIHN0eWxlZFxuXHRcdFx0XHRcdGlmICggIWNoaWxkLnRlc3QoICRyb3dbIDAgXS5jbGFzc05hbWUgKSApIHsgY291bnQrKzsgfVxuXHRcdFx0XHRcdGlzRXZlbiA9ICggY291bnQgJSAyID09PSAwICk7XG5cdFx0XHRcdFx0JHJvd1xuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB3by56ZWJyYVsgaXNFdmVuID8gMSA6IDAgXSApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIHdvLnplYnJhWyBpc0V2ZW4gPyAwIDogMSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbW92ZSA6IGZ1bmN0aW9uKCB0YWJsZSwgYywgd28sIHJlZnJlc2hpbmcgKSB7XG5cdFx0XHRpZiAoIHJlZnJlc2hpbmcgKSB7IHJldHVybjsgfVxuXHRcdFx0dmFyIHRib2R5SW5kZXgsICR0Ym9keSxcblx0XHRcdFx0JHRib2RpZXMgPSBjLiR0Ym9kaWVzLFxuXHRcdFx0XHR0b1JlbW92ZSA9ICggd28uemVicmEgfHwgWyAnZXZlbicsICdvZGQnIF0gKS5qb2luKCAnICcgKTtcblx0XHRcdGZvciAoIHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgJHRib2RpZXMubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdCR0Ym9keSA9IHRzLnByb2Nlc3NUYm9keSggdGFibGUsICR0Ym9kaWVzLmVxKCB0Ym9keUluZGV4ICksIHRydWUgKTsgLy8gcmVtb3ZlIHRib2R5XG5cdFx0XHRcdCR0Ym9keS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCB0b1JlbW92ZSApO1xuXHRcdFx0XHR0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCAkdGJvZHksIGZhbHNlICk7IC8vIHJlc3RvcmUgdGJvZHlcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cclxuLyohIFdpZGdldDogc3RvcmFnZSAtIHVwZGF0ZWQgMjAxOC0wMy0xOCAodjIuMzAuMCkgKi9cbi8qZ2xvYmFsIEpTT046ZmFsc2UgKi9cbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB0cyA9ICQudGFibGVzb3J0ZXIgfHwge307XG5cblx0Ly8gdXBkYXRlIGRlZmF1bHRzIGZvciB2YWxpZGF0b3I7IHRoZXNlIHZhbHVlcyBtdXN0IGJlIGZhbHN5IVxuXHQkLmV4dGVuZCh0cnVlLCB0cy5kZWZhdWx0cywge1xuXHRcdGZpeGVkVXJsOiAnJyxcblx0XHR3aWRnZXRPcHRpb25zOiB7XG5cdFx0XHRzdG9yYWdlX2ZpeGVkVXJsOiAnJyxcblx0XHRcdHN0b3JhZ2VfZ3JvdXA6ICcnLFxuXHRcdFx0c3RvcmFnZV9wYWdlOiAnJyxcblx0XHRcdHN0b3JhZ2Vfc3RvcmFnZVR5cGU6ICcnLFxuXHRcdFx0c3RvcmFnZV90YWJsZUlkOiAnJyxcblx0XHRcdHN0b3JhZ2VfdXNlU2Vzc2lvblN0b3JhZ2U6ICcnXG5cdFx0fVxuXHR9KTtcblxuXHQvLyAqKiogU3RvcmUgZGF0YSBpbiBsb2NhbCBzdG9yYWdlLCB3aXRoIGEgY29va2llIGZhbGxiYWNrICoqKlxuXHQvKiBJRTcgbmVlZHMgSlNPTiBsaWJyYXJ5IGZvciBKU09OLnN0cmluZ2lmeSAtIChodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1qc29uKVxuXHQgICBpZiB5b3UgbmVlZCBpdCwgdGhlbiBpbmNsdWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanNcblxuXHQgICAkLnBhcnNlSlNPTiBpcyBub3QgYXZhaWxhYmxlIGlzIGpRdWVyeSB2ZXJzaW9ucyBvbGRlciB0aGFuIDEuNC4xLCB1c2luZyBvbGRlclxuXHQgICB2ZXJzaW9ucyB3aWxsIG9ubHkgYWxsb3cgc3RvcmluZyBpbmZvcm1hdGlvbiBmb3Igb25lIHBhZ2UgYXQgYSB0aW1lXG5cblx0ICAgLy8gKioqIFNhdmUgZGF0YSAoSlNPTiBmb3JtYXQgb25seSkgKioqXG5cdCAgIC8vIHZhbCBtdXN0IGJlIHZhbGlkIEpTT04uLi4gdXNlIGh0dHA6Ly9qc29ubGludC5jb20vIHRvIGVuc3VyZSBpdCBpcyB2YWxpZFxuXHQgICB2YXIgdmFsID0geyBcIm15d2lkZ2V0XCIgOiBcImRhdGExXCIgfTsgLy8gdmFsaWQgSlNPTiB1c2VzIGRvdWJsZSBxdW90ZXNcblx0ICAgLy8gJC50YWJsZXNvcnRlci5zdG9yYWdlKHRhYmxlLCBrZXksIHZhbCk7XG5cdCAgICQudGFibGVzb3J0ZXIuc3RvcmFnZSh0YWJsZSwgJ3RhYmxlc29ydGVyLW15d2lkZ2V0JywgdmFsKTtcblxuXHQgICAvLyAqKiogR2V0IGRhdGE6ICQudGFibGVzb3J0ZXIuc3RvcmFnZSh0YWJsZSwga2V5KTsgKioqXG5cdCAgIHYgPSAkLnRhYmxlc29ydGVyLnN0b3JhZ2UodGFibGUsICd0YWJsZXNvcnRlci1teXdpZGdldCcpO1xuXHQgICAvLyB2YWwgbWF5IGJlIGVtcHR5LCBzbyBhbHNvIGNoZWNrIGZvciB5b3VyIGRhdGFcblx0ICAgdmFsID0gKHYgJiYgdi5oYXNPd25Qcm9wZXJ0eSgnbXl3aWRnZXQnKSkgPyB2Lm15d2lkZ2V0IDogJyc7XG5cdCAgIGFsZXJ0KHZhbCk7IC8vICdkYXRhMScgaWYgc2F2ZWQsIG9yICcnIGlmIG5vdFxuXHQqL1xuXHR0cy5zdG9yYWdlID0gZnVuY3Rpb24odGFibGUsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcblx0XHR0YWJsZSA9ICQodGFibGUpWzBdO1xuXHRcdHZhciBjb29raWVJbmRleCwgY29va2llcywgZGF0ZSxcblx0XHRcdGhhc1N0b3JhZ2UgPSBmYWxzZSxcblx0XHRcdHZhbHVlcyA9IHt9LFxuXHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdHdvID0gYyAmJiBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdzdG9yYWdlJyksXG5cdFx0XHRzdG9yYWdlVHlwZSA9IChcblx0XHRcdFx0KCBvcHRpb25zICYmIG9wdGlvbnMuc3RvcmFnZVR5cGUgKSB8fCAoIHdvICYmIHdvLnN0b3JhZ2Vfc3RvcmFnZVR5cGUgKVxuXHRcdFx0KS50b1N0cmluZygpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0Ly8gZGVwcmVjYXRpbmcgXCJ1c2VTZXNzaW9uU3RvcmFnZVwiOyBhbnkgc3RvcmFnZVR5cGUgc2V0dGluZyBvdmVycmlkZXMgaXRcblx0XHRcdHNlc3Npb24gPSBzdG9yYWdlVHlwZSA/ICcnIDpcblx0XHRcdFx0KCBvcHRpb25zICYmIG9wdGlvbnMudXNlU2Vzc2lvblN0b3JhZ2UgKSB8fCAoIHdvICYmIHdvLnN0b3JhZ2VfdXNlU2Vzc2lvblN0b3JhZ2UgKSxcblx0XHRcdCR0YWJsZSA9ICQodGFibGUpLFxuXHRcdFx0Ly8gaWQgZnJvbSAoMSkgb3B0aW9ucyBJRCwgKDIpIHRhYmxlICdkYXRhLXRhYmxlLWdyb3VwJyBhdHRyaWJ1dGUsICgzKSB3aWRnZXRPcHRpb25zLnN0b3JhZ2VfdGFibGVJZCxcblx0XHRcdC8vICg0KSB0YWJsZSBJRCwgdGhlbiAoNSkgdGFibGUgaW5kZXhcblx0XHRcdGlkID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkIHx8XG5cdFx0XHRcdCR0YWJsZS5hdHRyKCBvcHRpb25zICYmIG9wdGlvbnMuZ3JvdXAgfHwgd28gJiYgd28uc3RvcmFnZV9ncm91cCB8fCAnZGF0YS10YWJsZS1ncm91cCcpIHx8XG5cdFx0XHRcdHdvICYmIHdvLnN0b3JhZ2VfdGFibGVJZCB8fCB0YWJsZS5pZCB8fCAkKCcudGFibGVzb3J0ZXInKS5pbmRleCggJHRhYmxlICksXG5cdFx0XHQvLyB1cmwgZnJvbSAoMSkgb3B0aW9ucyB1cmwsICgyKSB0YWJsZSAnZGF0YS10YWJsZS1wYWdlJyBhdHRyaWJ1dGUsICgzKSB3aWRnZXRPcHRpb25zLnN0b3JhZ2VfZml4ZWRVcmwsXG5cdFx0XHQvLyAoNCkgdGFibGUuY29uZmlnLmZpeGVkVXJsIChkZXByZWNhdGVkKSwgdGhlbiAoNSkgd2luZG93IGxvY2F0aW9uIHBhdGhcblx0XHRcdHVybCA9IG9wdGlvbnMgJiYgb3B0aW9ucy51cmwgfHxcblx0XHRcdFx0JHRhYmxlLmF0dHIob3B0aW9ucyAmJiBvcHRpb25zLnBhZ2UgfHwgd28gJiYgd28uc3RvcmFnZV9wYWdlIHx8ICdkYXRhLXRhYmxlLXBhZ2UnKSB8fFxuXHRcdFx0XHR3byAmJiB3by5zdG9yYWdlX2ZpeGVkVXJsIHx8IGMgJiYgYy5maXhlZFVybCB8fCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG5cblx0XHQvLyBza2lwIGlmIHVzaW5nIGNvb2tpZXNcblx0XHRpZiAoc3RvcmFnZVR5cGUgIT09ICdjJykge1xuXHRcdFx0c3RvcmFnZVR5cGUgPSAoc3RvcmFnZVR5cGUgPT09ICdzJyB8fCBzZXNzaW9uKSA/ICdzZXNzaW9uU3RvcmFnZScgOiAnbG9jYWxTdG9yYWdlJztcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81NTU4NTU3XG5cdFx0XHRpZiAoc3RvcmFnZVR5cGUgaW4gd2luZG93KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0d2luZG93W3N0b3JhZ2VUeXBlXS5zZXRJdGVtKCdfdG1wdGVzdCcsICd0ZW1wJyk7XG5cdFx0XHRcdFx0aGFzU3RvcmFnZSA9IHRydWU7XG5cdFx0XHRcdFx0d2luZG93W3N0b3JhZ2VUeXBlXS5yZW1vdmVJdGVtKCdfdG1wdGVzdCcpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybiggc3RvcmFnZVR5cGUgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChkZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1N0b3JhZ2UgPj4gVXNpbmcnLCBoYXNTdG9yYWdlID8gc3RvcmFnZVR5cGUgOiAnY29va2llcycpO1xuXHRcdH1cblx0XHQvLyAqKiogZ2V0IHZhbHVlICoqKlxuXHRcdGlmICgkLnBhcnNlSlNPTikge1xuXHRcdFx0aWYgKGhhc1N0b3JhZ2UpIHtcblx0XHRcdFx0dmFsdWVzID0gJC5wYXJzZUpTT04oIHdpbmRvd1tzdG9yYWdlVHlwZV1ba2V5XSB8fCAnbnVsbCcgKSB8fCB7fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG9sZCBicm93c2VyLCB1c2luZyBjb29raWVzXG5cdFx0XHRcdGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoL1s7XFxzfD1dLyk7XG5cdFx0XHRcdC8vIGFkZCBvbmUgdG8gZ2V0IGZyb20gdGhlIGtleSB0byB0aGUgdmFsdWVcblx0XHRcdFx0Y29va2llSW5kZXggPSAkLmluQXJyYXkoa2V5LCBjb29raWVzKSArIDE7XG5cdFx0XHRcdHZhbHVlcyA9IChjb29raWVJbmRleCAhPT0gMCkgPyAkLnBhcnNlSlNPTihjb29raWVzW2Nvb2tpZUluZGV4XSB8fCAnbnVsbCcpIHx8IHt9IDoge307XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGFsbG93IHZhbHVlIHRvIGJlIGFuIGVtcHR5IHN0cmluZyB0b29cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuSlNPTiAmJiBKU09OLmhhc093blByb3BlcnR5KCdzdHJpbmdpZnknKSkge1xuXHRcdFx0Ly8gYWRkIHVuaXF1ZSBpZGVudGlmaWVycyA9IHVybCBwYXRobmFtZSA+IHRhYmxlIElEL2luZGV4IG9uIHBhZ2UgPiBkYXRhXG5cdFx0XHRpZiAoIXZhbHVlc1t1cmxdKSB7XG5cdFx0XHRcdHZhbHVlc1t1cmxdID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXNbdXJsXVtpZF0gPSB2YWx1ZTtcblx0XHRcdC8vICoqKiBzZXQgdmFsdWUgKioqXG5cdFx0XHRpZiAoaGFzU3RvcmFnZSkge1xuXHRcdFx0XHR3aW5kb3dbc3RvcmFnZVR5cGVdW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgzMTUzNmUrNikpOyAvLyAzNjUgZGF5c1xuXHRcdFx0XHRkb2N1bWVudC5jb29raWUgPSBrZXkgKyAnPScgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWVzKSkucmVwbGFjZSgvXFxcIi9nLCAnXFxcIicpICsgJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpICsgJzsgcGF0aD0vJztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXNbdXJsXSA/IHZhbHVlc1t1cmxdW2lkXSA6ICcnO1xuXHRcdH1cblx0fTtcblxufSkoalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxyXG4vKiEgV2lkZ2V0OiB1aXRoZW1lIC0gdXBkYXRlZCAyMDE4LTAzLTE4ICh2Mi4zMC4wKSAqL1xuOyhmdW5jdGlvbiAoJCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciB0cyA9ICQudGFibGVzb3J0ZXIgfHwge307XG5cblx0dHMudGhlbWVzID0ge1xuXHRcdCdib290c3RyYXAnIDoge1xuXHRcdFx0dGFibGUgICAgICAgIDogJ3RhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXN0cmlwZWQnLFxuXHRcdFx0Y2FwdGlvbiAgICAgIDogJ2NhcHRpb24nLFxuXHRcdFx0Ly8gaGVhZGVyIGNsYXNzIG5hbWVzXG5cdFx0XHRoZWFkZXIgICAgICAgOiAnYm9vdHN0cmFwLWhlYWRlcicsIC8vIGdpdmUgdGhlIGhlYWRlciBhIGdyYWRpZW50IGJhY2tncm91bmQgKHRoZW1lLmJvb3RzdHJhcF8yLmNzcylcblx0XHRcdHNvcnROb25lICAgICA6ICcnLFxuXHRcdFx0c29ydEFzYyAgICAgIDogJycsXG5cdFx0XHRzb3J0RGVzYyAgICAgOiAnJyxcblx0XHRcdGFjdGl2ZSAgICAgICA6ICcnLCAvLyBhcHBsaWVkIHdoZW4gY29sdW1uIGlzIHNvcnRlZFxuXHRcdFx0aG92ZXIgICAgICAgIDogJycsIC8vIGN1c3RvbSBjc3MgcmVxdWlyZWQgLSBhIGRlZmluZWQgYm9vdHN0cmFwIHN0eWxlIG1heSBub3Qgb3ZlcnJpZGUgb3RoZXIgY2xhc3Nlc1xuXHRcdFx0Ly8gaWNvbiBjbGFzcyBuYW1lc1xuXHRcdFx0aWNvbnMgICAgICAgIDogJycsIC8vIGFkZCAnYm9vdHN0cmFwLWljb24td2hpdGUnIHRvIG1ha2UgdGhlbSB3aGl0ZTsgdGhpcyBpY29uIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSA8aT4gaW4gdGhlIGhlYWRlclxuXHRcdFx0aWNvblNvcnROb25lIDogJ2Jvb3RzdHJhcC1pY29uLXVuc29ydGVkJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBpY29uIHdoZW4gY29sdW1uIGlzIG5vdCBzb3J0ZWRcblx0XHRcdGljb25Tb3J0QXNjICA6ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXAnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIGljb24gd2hlbiBjb2x1bW4gaGFzIGFzY2VuZGluZyBzb3J0XG5cdFx0XHRpY29uU29ydERlc2MgOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd24nLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIGljb24gd2hlbiBjb2x1bW4gaGFzIGRlc2NlbmRpbmcgc29ydFxuXHRcdFx0ZmlsdGVyUm93ICAgIDogJycsIC8vIGZpbHRlciByb3cgY2xhc3Ncblx0XHRcdGZvb3RlclJvdyAgICA6ICcnLFxuXHRcdFx0Zm9vdGVyQ2VsbHMgIDogJycsXG5cdFx0XHRldmVuICAgICAgICAgOiAnJywgLy8gZXZlbiByb3cgemVicmEgc3RyaXBpbmdcblx0XHRcdG9kZCAgICAgICAgICA6ICcnICAvLyBvZGQgcm93IHplYnJhIHN0cmlwaW5nXG5cdFx0fSxcblx0XHQnanVpJyA6IHtcblx0XHRcdHRhYmxlICAgICAgICA6ICd1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCcsIC8vIHRhYmxlIGNsYXNzZXNcblx0XHRcdGNhcHRpb24gICAgICA6ICd1aS13aWRnZXQtY29udGVudCcsXG5cdFx0XHQvLyBoZWFkZXIgY2xhc3MgbmFtZXNcblx0XHRcdGhlYWRlciAgICAgICA6ICd1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGVmYXVsdCcsIC8vIGhlYWRlciBjbGFzc2VzXG5cdFx0XHRzb3J0Tm9uZSAgICAgOiAnJyxcblx0XHRcdHNvcnRBc2MgICAgICA6ICcnLFxuXHRcdFx0c29ydERlc2MgICAgIDogJycsXG5cdFx0XHRhY3RpdmUgICAgICAgOiAndWktc3RhdGUtYWN0aXZlJywgLy8gYXBwbGllZCB3aGVuIGNvbHVtbiBpcyBzb3J0ZWRcblx0XHRcdGhvdmVyICAgICAgICA6ICd1aS1zdGF0ZS1ob3ZlcicsICAvLyBob3ZlciBjbGFzc1xuXHRcdFx0Ly8gaWNvbiBjbGFzcyBuYW1lc1xuXHRcdFx0aWNvbnMgICAgICAgIDogJ3VpLWljb24nLCAvLyBpY29uIGNsYXNzIGFkZGVkIHRvIHRoZSA8aT4gaW4gdGhlIGhlYWRlclxuXHRcdFx0aWNvblNvcnROb25lIDogJ3VpLWljb24tY2FyYXQtMi1uLXMgdWktaWNvbi1jYXJldC0yLW4tcycsIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gaWNvbiB3aGVuIGNvbHVtbiBpcyBub3Qgc29ydGVkXG5cdFx0XHRpY29uU29ydEFzYyAgOiAndWktaWNvbi1jYXJhdC0xLW4gdWktaWNvbi1jYXJldC0xLW4nLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIGljb24gd2hlbiBjb2x1bW4gaGFzIGFzY2VuZGluZyBzb3J0XG5cdFx0XHRpY29uU29ydERlc2MgOiAndWktaWNvbi1jYXJhdC0xLXMgdWktaWNvbi1jYXJldC0xLXMnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIGljb24gd2hlbiBjb2x1bW4gaGFzIGRlc2NlbmRpbmcgc29ydFxuXHRcdFx0ZmlsdGVyUm93ICAgIDogJycsXG5cdFx0XHRmb290ZXJSb3cgICAgOiAnJyxcblx0XHRcdGZvb3RlckNlbGxzICA6ICcnLFxuXHRcdFx0ZXZlbiAgICAgICAgIDogJ3VpLXdpZGdldC1jb250ZW50JywgLy8gZXZlbiByb3cgemVicmEgc3RyaXBpbmdcblx0XHRcdG9kZCAgICAgICAgICA6ICd1aS1zdGF0ZS1kZWZhdWx0JyAgIC8vIG9kZCByb3cgemVicmEgc3RyaXBpbmdcblx0XHR9XG5cdH07XG5cblx0JC5leHRlbmQodHMuY3NzLCB7XG5cdFx0d3JhcHBlciA6ICd0YWJsZXNvcnRlci13cmFwcGVyJyAvLyB1aSB0aGVtZSAmIHJlc2l6YWJsZVxuXHR9KTtcblxuXHR0cy5hZGRXaWRnZXQoe1xuXHRcdGlkOiAndWl0aGVtZScsXG5cdFx0cHJpb3JpdHk6IDEwLFxuXHRcdGZvcm1hdDogZnVuY3Rpb24odGFibGUsIGMsIHdvKSB7XG5cdFx0XHR2YXIgaSwgdG1wLCBoZHIsIGljb24sIHRpbWUsICRoZWFkZXIsICRpY29uLCAkdGZvb3QsICRoLCBvbGR0aGVtZSwgb2xkcmVtb3ZlLCBvbGRJY29uUm12LCBoYXNPbGRUaGVtZSxcblx0XHRcdFx0dGhlbWVzQWxsID0gdHMudGhlbWVzLFxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZS5hZGQoICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV90YWJsZScgKSApLFxuXHRcdFx0XHQkaGVhZGVycyA9IGMuJGhlYWRlcnMuYWRkKCAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfaGVhZGVycycgKSApLFxuXHRcdFx0XHR0aGVtZSA9IGMudGhlbWUgfHwgJ2p1aScsXG5cdFx0XHRcdHRoZW1lcyA9IHRoZW1lc0FsbFt0aGVtZV0gfHwge30sXG5cdFx0XHRcdHJlbW92ZSA9ICQudHJpbSggWyB0aGVtZXMuc29ydE5vbmUsIHRoZW1lcy5zb3J0RGVzYywgdGhlbWVzLnNvcnRBc2MsIHRoZW1lcy5hY3RpdmUgXS5qb2luKCAnICcgKSApLFxuXHRcdFx0XHRpY29uUm12ID0gJC50cmltKCBbIHRoZW1lcy5pY29uU29ydE5vbmUsIHRoZW1lcy5pY29uU29ydERlc2MsIHRoZW1lcy5pY29uU29ydEFzYyBdLmpvaW4oICcgJyApICksXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ3VpdGhlbWUnKTtcblx0XHRcdGlmIChkZWJ1ZykgeyB0aW1lID0gbmV3IERhdGUoKTsgfVxuXHRcdFx0Ly8gaW5pdGlhbGl6YXRpb24gY29kZSAtIHJ1biBvbmNlXG5cdFx0XHRpZiAoISR0YWJsZS5oYXNDbGFzcygndGFibGVzb3J0ZXItJyArIHRoZW1lKSB8fCBjLnRoZW1lICE9PSBjLmFwcGxpZWRUaGVtZSB8fCAhd28udWl0aGVtZV9hcHBsaWVkKSB7XG5cdFx0XHRcdHdvLnVpdGhlbWVfYXBwbGllZCA9IHRydWU7XG5cdFx0XHRcdG9sZHRoZW1lID0gdGhlbWVzQWxsW2MuYXBwbGllZFRoZW1lXSB8fCB7fTtcblx0XHRcdFx0aGFzT2xkVGhlbWUgPSAhJC5pc0VtcHR5T2JqZWN0KG9sZHRoZW1lKTtcblx0XHRcdFx0b2xkcmVtb3ZlID0gIGhhc09sZFRoZW1lID8gWyBvbGR0aGVtZS5zb3J0Tm9uZSwgb2xkdGhlbWUuc29ydERlc2MsIG9sZHRoZW1lLnNvcnRBc2MsIG9sZHRoZW1lLmFjdGl2ZSBdLmpvaW4oICcgJyApIDogJyc7XG5cdFx0XHRcdG9sZEljb25SbXYgPSBoYXNPbGRUaGVtZSA/IFsgb2xkdGhlbWUuaWNvblNvcnROb25lLCBvbGR0aGVtZS5pY29uU29ydERlc2MsIG9sZHRoZW1lLmljb25Tb3J0QXNjIF0uam9pbiggJyAnICkgOiAnJztcblx0XHRcdFx0aWYgKGhhc09sZFRoZW1lKSB7XG5cdFx0XHRcdFx0d28uemVicmFbMF0gPSAkLnRyaW0oICcgJyArIHdvLnplYnJhWzBdLnJlcGxhY2UoJyAnICsgb2xkdGhlbWUuZXZlbiwgJycpICk7XG5cdFx0XHRcdFx0d28uemVicmFbMV0gPSAkLnRyaW0oICcgJyArIHdvLnplYnJhWzFdLnJlcGxhY2UoJyAnICsgb2xkdGhlbWUub2RkLCAnJykgKTtcblx0XHRcdFx0XHRjLiR0Ym9kaWVzLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoIFsgb2xkdGhlbWUuZXZlbiwgb2xkdGhlbWUub2RkIF0uam9pbignICcpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdXBkYXRlIHplYnJhIHN0cmlwZXNcblx0XHRcdFx0aWYgKHRoZW1lcy5ldmVuKSB7IHdvLnplYnJhWzBdICs9ICcgJyArIHRoZW1lcy5ldmVuOyB9XG5cdFx0XHRcdGlmICh0aGVtZXMub2RkKSB7IHdvLnplYnJhWzFdICs9ICcgJyArIHRoZW1lcy5vZGQ7IH1cblx0XHRcdFx0Ly8gYWRkIGNhcHRpb24gc3R5bGVcblx0XHRcdFx0JHRhYmxlLmNoaWxkcmVuKCdjYXB0aW9uJylcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3Mob2xkdGhlbWUuY2FwdGlvbiB8fCAnJylcblx0XHRcdFx0XHQuYWRkQ2xhc3ModGhlbWVzLmNhcHRpb24pO1xuXHRcdFx0XHQvLyBhZGQgdGFibGUvZm9vdGVyIGNsYXNzIG5hbWVzXG5cdFx0XHRcdCR0Zm9vdCA9ICR0YWJsZVxuXHRcdFx0XHRcdC8vIHJlbW92ZSBvdGhlciBzZWxlY3RlZCB0aGVtZXNcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIChjLmFwcGxpZWRUaGVtZSA/ICd0YWJsZXNvcnRlci0nICsgKGMuYXBwbGllZFRoZW1lIHx8ICcnKSA6ICcnKSArICcgJyArIChvbGR0aGVtZS50YWJsZSB8fCAnJykgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcygndGFibGVzb3J0ZXItJyArIHRoZW1lICsgJyAnICsgKHRoZW1lcy50YWJsZSB8fCAnJykpIC8vIGFkZCB0aGVtZSB3aWRnZXQgY2xhc3MgbmFtZVxuXHRcdFx0XHRcdC5jaGlsZHJlbigndGZvb3QnKTtcblx0XHRcdFx0Yy5hcHBsaWVkVGhlbWUgPSBjLnRoZW1lO1xuXG5cdFx0XHRcdGlmICgkdGZvb3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JHRmb290XG5cdFx0XHRcdFx0XHQvLyBpZiBvbGR0aGVtZS5mb290ZXJSb3cgb3Igb2xkdGhlbWUuZm9vdGVyQ2VsbHMgYXJlIHVuZGVmaW5lZCwgYWxsIGNsYXNzIG5hbWVzIGFyZSByZW1vdmVkXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oJ3RyJykucmVtb3ZlQ2xhc3Mob2xkdGhlbWUuZm9vdGVyUm93IHx8ICcnKS5hZGRDbGFzcyh0aGVtZXMuZm9vdGVyUm93KVxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKCd0aCwgdGQnKS5yZW1vdmVDbGFzcyhvbGR0aGVtZS5mb290ZXJDZWxscyB8fCAnJykuYWRkQ2xhc3ModGhlbWVzLmZvb3RlckNlbGxzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1cGRhdGUgaGVhZGVyIGNsYXNzZXNcblx0XHRcdFx0JGhlYWRlcnNcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIChoYXNPbGRUaGVtZSA/IFsgb2xkdGhlbWUuaGVhZGVyLCBvbGR0aGVtZS5ob3Zlciwgb2xkcmVtb3ZlIF0uam9pbignICcpIDogJycpIHx8ICcnIClcblx0XHRcdFx0XHQuYWRkQ2xhc3ModGhlbWVzLmhlYWRlcilcblx0XHRcdFx0XHQubm90KCcuc29ydGVyLWZhbHNlJylcblx0XHRcdFx0XHQudW5iaW5kKCdtb3VzZWVudGVyLnRzdWl0aGVtZSBtb3VzZWxlYXZlLnRzdWl0aGVtZScpXG5cdFx0XHRcdFx0LmJpbmQoJ21vdXNlZW50ZXIudHN1aXRoZW1lIG1vdXNlbGVhdmUudHN1aXRoZW1lJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdC8vIHRvZ2dsZUNsYXNzIHdpdGggc3dpdGNoIGFkZGVkIGluIGpRdWVyeSAxLjNcblx0XHRcdFx0XHRcdCQodGhpcylbIGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnIF0odGhlbWVzLmhvdmVyIHx8ICcnKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQkaGVhZGVycy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHRcdFx0aWYgKCEkdGhpcy5maW5kKCcuJyArIHRzLmNzcy53cmFwcGVyKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIEZpcmVmb3ggbmVlZHMgdGhpcyBpbm5lciBkaXYgdG8gcG9zaXRpb24gdGhlIGljb24gJiByZXNpemVyIGNvcnJlY3RseVxuXHRcdFx0XHRcdFx0JHRoaXMud3JhcElubmVyKCc8ZGl2IGNsYXNzPVwiJyArIHRzLmNzcy53cmFwcGVyICsgJ1wiIHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJVwiPjwvZGl2PicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChjLmNzc0ljb24pIHtcblx0XHRcdFx0XHQvLyBpZiBjLmNzc0ljb24gaXMgJycsIHRoZW4gbm8gPGk+IGlzIGFkZGVkIHRvIHRoZSBoZWFkZXJcblx0XHRcdFx0XHQkaGVhZGVyc1xuXHRcdFx0XHRcdFx0LmZpbmQoJy4nICsgdHMuY3NzLmljb24pXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoaGFzT2xkVGhlbWUgPyBbIG9sZHRoZW1lLmljb25zLCBvbGRJY29uUm12IF0uam9pbignICcpIDogJycpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3ModGhlbWVzLmljb25zIHx8ICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBmaWx0ZXIgd2lkZ2V0IGluaXRpYWxpemVzIGFmdGVyIHVpdGhlbWVcblx0XHRcdFx0aWYgKHRzLmhhc1dpZGdldCggYy50YWJsZSwgJ2ZpbHRlcicgKSkge1xuXHRcdFx0XHRcdHRtcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmNoaWxkcmVuKCcuJyArIHRzLmNzcy5maWx0ZXJSb3cpXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhoYXNPbGRUaGVtZSA/IG9sZHRoZW1lLmZpbHRlclJvdyB8fCAnJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3ModGhlbWVzLmZpbHRlclJvdyB8fCAnJyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAod28uZmlsdGVyX2luaXRpYWxpemVkKSB7XG5cdFx0XHRcdFx0XHR0bXAoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JHRhYmxlLm9uZSgnZmlsdGVySW5pdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0bXAoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGMuY29sdW1uczsgaSsrKSB7XG5cdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzXG5cdFx0XHRcdFx0LmFkZCgkKGMubmFtZXNwYWNlICsgJ19leHRyYV9oZWFkZXJzJykpXG5cdFx0XHRcdFx0Lm5vdCgnLnNvcnRlci1mYWxzZScpXG5cdFx0XHRcdFx0LmZpbHRlcignW2RhdGEtY29sdW1uPVwiJyArIGkgKyAnXCJdJyk7XG5cdFx0XHRcdCRpY29uID0gKHRzLmNzcy5pY29uKSA/ICRoZWFkZXIuZmluZCgnLicgKyB0cy5jc3MuaWNvbikgOiAkKCk7XG5cdFx0XHRcdCRoID0gJGhlYWRlcnMubm90KCcuc29ydGVyLWZhbHNlJykuZmlsdGVyKCdbZGF0YS1jb2x1bW49XCInICsgaSArICdcIl06bGFzdCcpO1xuXHRcdFx0XHRpZiAoJGgubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JGhlYWRlci5yZW1vdmVDbGFzcyhyZW1vdmUpO1xuXHRcdFx0XHRcdCRpY29uLnJlbW92ZUNsYXNzKGljb25SbXYpO1xuXHRcdFx0XHRcdGlmICgkaFswXS5zb3J0RGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdC8vIG5vIHNvcnQgYXJyb3dzIGZvciBkaXNhYmxlZCBjb2x1bW5zIVxuXHRcdFx0XHRcdFx0JGljb24ucmVtb3ZlQ2xhc3ModGhlbWVzLmljb25zIHx8ICcnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aGRyID0gdGhlbWVzLnNvcnROb25lO1xuXHRcdFx0XHRcdFx0aWNvbiA9IHRoZW1lcy5pY29uU29ydE5vbmU7XG5cdFx0XHRcdFx0XHRpZiAoJGguaGFzQ2xhc3ModHMuY3NzLnNvcnRBc2MpKSB7XG5cdFx0XHRcdFx0XHRcdGhkciA9IFsgdGhlbWVzLnNvcnRBc2MsIHRoZW1lcy5hY3RpdmUgXS5qb2luKCcgJyk7XG5cdFx0XHRcdFx0XHRcdGljb24gPSB0aGVtZXMuaWNvblNvcnRBc2M7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCRoLmhhc0NsYXNzKHRzLmNzcy5zb3J0RGVzYykpIHtcblx0XHRcdFx0XHRcdFx0aGRyID0gWyB0aGVtZXMuc29ydERlc2MsIHRoZW1lcy5hY3RpdmUgXS5qb2luKCcgJyk7XG5cdFx0XHRcdFx0XHRcdGljb24gPSB0aGVtZXMuaWNvblNvcnREZXNjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0JGhlYWRlci5hZGRDbGFzcyhoZHIpO1xuXHRcdFx0XHRcdFx0JGljb24uYWRkQ2xhc3MoaWNvbiB8fCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVidWcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ3VpdGhlbWUgPj4gQXBwbGllZCAnICsgdGhlbWUgKyAnIHRoZW1lJyArIHRzLmJlbmNobWFyayh0aW1lKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bywgcmVmcmVzaGluZykge1xuXHRcdFx0aWYgKCF3by51aXRoZW1lX2FwcGxpZWQpIHsgcmV0dXJuOyB9XG5cdFx0XHR2YXIgJHRhYmxlID0gYy4kdGFibGUsXG5cdFx0XHRcdHRoZW1lID0gYy5hcHBsaWVkVGhlbWUgfHwgJ2p1aScsXG5cdFx0XHRcdHRoZW1lcyA9IHRzLnRoZW1lc1sgdGhlbWUgXSB8fCB0cy50aGVtZXMuanVpLFxuXHRcdFx0XHQkaGVhZGVycyA9ICR0YWJsZS5jaGlsZHJlbigndGhlYWQnKS5jaGlsZHJlbigpLFxuXHRcdFx0XHRyZW1vdmUgPSB0aGVtZXMuc29ydE5vbmUgKyAnICcgKyB0aGVtZXMuc29ydERlc2MgKyAnICcgKyB0aGVtZXMuc29ydEFzYyxcblx0XHRcdFx0aWNvblJtdiA9IHRoZW1lcy5pY29uU29ydE5vbmUgKyAnICcgKyB0aGVtZXMuaWNvblNvcnREZXNjICsgJyAnICsgdGhlbWVzLmljb25Tb3J0QXNjO1xuXHRcdFx0JHRhYmxlLnJlbW92ZUNsYXNzKCd0YWJsZXNvcnRlci0nICsgdGhlbWUgKyAnICcgKyB0aGVtZXMudGFibGUpO1xuXHRcdFx0d28udWl0aGVtZV9hcHBsaWVkID0gZmFsc2U7XG5cdFx0XHRpZiAocmVmcmVzaGluZykgeyByZXR1cm47IH1cblx0XHRcdCR0YWJsZS5maW5kKHRzLmNzcy5oZWFkZXIpLnJlbW92ZUNsYXNzKHRoZW1lcy5oZWFkZXIpO1xuXHRcdFx0JGhlYWRlcnNcblx0XHRcdFx0LnVuYmluZCgnbW91c2VlbnRlci50c3VpdGhlbWUgbW91c2VsZWF2ZS50c3VpdGhlbWUnKSAvLyByZW1vdmUgaG92ZXJcblx0XHRcdFx0LnJlbW92ZUNsYXNzKHRoZW1lcy5ob3ZlciArICcgJyArIHJlbW92ZSArICcgJyArIHRoZW1lcy5hY3RpdmUpXG5cdFx0XHRcdC5maWx0ZXIoJy4nICsgdHMuY3NzLmZpbHRlclJvdylcblx0XHRcdFx0LnJlbW92ZUNsYXNzKHRoZW1lcy5maWx0ZXJSb3cpO1xuXHRcdFx0JGhlYWRlcnMuZmluZCgnLicgKyB0cy5jc3MuaWNvbikucmVtb3ZlQ2xhc3ModGhlbWVzLmljb25zICsgJyAnICsgaWNvblJtdik7XG5cdFx0fVxuXHR9KTtcblxufSkoalF1ZXJ5KTtcblxyXG4vKiEgV2lkZ2V0OiBjb2x1bW5zIC0gdXBkYXRlZCA1LzI0LzIwMTcgKHYyLjI4LjExKSAqL1xuOyhmdW5jdGlvbiAoJCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciB0cyA9ICQudGFibGVzb3J0ZXIgfHwge307XG5cblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ2NvbHVtbnMnLFxuXHRcdHByaW9yaXR5OiA2NSxcblx0XHRvcHRpb25zIDoge1xuXHRcdFx0Y29sdW1ucyA6IFsgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ3RlcnRpYXJ5JyBdXG5cdFx0fSxcblx0XHRmb3JtYXQ6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bykge1xuXHRcdFx0dmFyICR0Ym9keSwgdGJvZHlJbmRleCwgJHJvd3MsIHJvd3MsICRyb3csICRjZWxscywgcmVtb3ZlLCBpbmR4LFxuXHRcdFx0JHRhYmxlID0gYy4kdGFibGUsXG5cdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMsXG5cdFx0XHRzb3J0TGlzdCA9IGMuc29ydExpc3QsXG5cdFx0XHRsZW4gPSBzb3J0TGlzdC5sZW5ndGgsXG5cdFx0XHQvLyByZW1vdmVkIGMud2lkZ2V0Q29sdW1ucyBzdXBwb3J0XG5cdFx0XHRjc3MgPSB3byAmJiB3by5jb2x1bW5zIHx8IFsgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ3RlcnRpYXJ5JyBdLFxuXHRcdFx0bGFzdCA9IGNzcy5sZW5ndGggLSAxO1xuXHRcdFx0cmVtb3ZlID0gY3NzLmpvaW4oJyAnKTtcblx0XHRcdC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgc29ydCAob24gaW5pdGlhbGl6YXRpb24gdGhlcmUgbWF5IG5vdCBiZSBvbmUpXG5cdFx0XHRmb3IgKHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgJHRib2RpZXMubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdCR0Ym9keSA9IHRzLnByb2Nlc3NUYm9keSh0YWJsZSwgJHRib2RpZXMuZXEodGJvZHlJbmRleCksIHRydWUpOyAvLyBkZXRhY2ggdGJvZHlcblx0XHRcdFx0JHJvd3MgPSAkdGJvZHkuY2hpbGRyZW4oJ3RyJyk7XG5cdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCB0aGUgdmlzaWJsZSByb3dzXG5cdFx0XHRcdCRyb3dzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JHJvdyA9ICQodGhpcyk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgYWxsIGNvbHVtbnMgY2xhc3MgbmFtZXNcblx0XHRcdFx0XHRcdCRjZWxscyA9ICRyb3cuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhyZW1vdmUpO1xuXHRcdFx0XHRcdFx0Ly8gYWRkIGFwcHJvcHJpYXRlIGNvbHVtbiBjbGFzcyBuYW1lc1xuXHRcdFx0XHRcdFx0aWYgKHNvcnRMaXN0ICYmIHNvcnRMaXN0WzBdKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHByaW1hcnkgc29ydCBjb2x1bW4gY2xhc3Ncblx0XHRcdFx0XHRcdFx0JGNlbGxzLmVxKHNvcnRMaXN0WzBdWzBdKS5hZGRDbGFzcyhjc3NbMF0pO1xuXHRcdFx0XHRcdFx0XHRpZiAobGVuID4gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaW5keCA9IDE7IGluZHggPCBsZW47IGluZHgrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc2Vjb25kYXJ5LCB0ZXJ0aWFyeSwgZXRjIHNvcnQgY29sdW1uIGNsYXNzZXNcblx0XHRcdFx0XHRcdFx0XHRcdCRjZWxscy5lcShzb3J0TGlzdFtpbmR4XVswXSkuYWRkQ2xhc3MoIGNzc1tpbmR4XSB8fCBjc3NbbGFzdF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0cy5wcm9jZXNzVGJvZHkodGFibGUsICR0Ym9keSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGNsYXNzZXMgdG8gdGhlYWQgYW5kIHRmb290XG5cdFx0XHRyb3dzID0gd28uY29sdW1uc190aGVhZCAhPT0gZmFsc2UgPyBbICd0aGVhZCB0cicgXSA6IFtdO1xuXHRcdFx0aWYgKHdvLmNvbHVtbnNfdGZvb3QgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHJvd3MucHVzaCgndGZvb3QgdHInKTtcblx0XHRcdH1cblx0XHRcdGlmIChyb3dzLmxlbmd0aCkge1xuXHRcdFx0XHQkcm93cyA9ICR0YWJsZS5maW5kKCByb3dzLmpvaW4oJywnKSApLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MocmVtb3ZlKTtcblx0XHRcdFx0aWYgKGxlbikge1xuXHRcdFx0XHRcdGZvciAoaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKykge1xuXHRcdFx0XHRcdFx0Ly8gYWRkIHByaW1hcnkuIHNlY29uZGFyeSwgdGVydGlhcnksIGV0YyBzb3J0IGNvbHVtbiBjbGFzc2VzXG5cdFx0XHRcdFx0XHQkcm93cy5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicgKyBzb3J0TGlzdFtpbmR4XVswXSArICdcIl0nKS5hZGRDbGFzcyhjc3NbaW5keF0gfHwgY3NzW2xhc3RdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24odGFibGUsIGMsIHdvKSB7XG5cdFx0XHR2YXIgdGJvZHlJbmRleCwgJHRib2R5LFxuXHRcdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMsXG5cdFx0XHRcdHJlbW92ZSA9ICh3by5jb2x1bW5zIHx8IFsgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ3RlcnRpYXJ5JyBdKS5qb2luKCcgJyk7XG5cdFx0XHRjLiRoZWFkZXJzLnJlbW92ZUNsYXNzKHJlbW92ZSk7XG5cdFx0XHRjLiR0YWJsZS5jaGlsZHJlbigndGZvb3QnKS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykucmVtb3ZlQ2xhc3MocmVtb3ZlKTtcblx0XHRcdGZvciAodGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0JHRib2R5ID0gdHMucHJvY2Vzc1Rib2R5KHRhYmxlLCAkdGJvZGllcy5lcSh0Ym9keUluZGV4KSwgdHJ1ZSk7IC8vIHJlbW92ZSB0Ym9keVxuXHRcdFx0XHQkdGJvZHkuY2hpbGRyZW4oJ3RyJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MocmVtb3ZlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRzLnByb2Nlc3NUYm9keSh0YWJsZSwgJHRib2R5LCBmYWxzZSk7IC8vIHJlc3RvcmUgdGJvZHlcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpO1xuXHJcbi8qISBXaWRnZXQ6IGZpbHRlciAtIHVwZGF0ZWQgMjAxOC0wMy0xOCAodjIuMzAuMCkgKi8vKlxyXG4gKiBSZXF1aXJlcyB0YWJsZXNvcnRlciB2Mi44KyBhbmQgalF1ZXJ5IDEuNytcclxuICogYnkgUm9iIEdhcnJpc29uXHJcbiAqL1xyXG47KCBmdW5jdGlvbiAoICQgKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdHZhciB0c2YsIHRzZlJlZ2V4LFxyXG5cdFx0dHMgPSAkLnRhYmxlc29ydGVyIHx8IHt9LFxyXG5cdFx0dHNjc3MgPSB0cy5jc3MsXHJcblx0XHR0c2tleUNvZGVzID0gdHMua2V5Q29kZXM7XHJcblxyXG5cdCQuZXh0ZW5kKCB0c2Nzcywge1xyXG5cdFx0ZmlsdGVyUm93ICAgICAgOiAndGFibGVzb3J0ZXItZmlsdGVyLXJvdycsXHJcblx0XHRmaWx0ZXIgICAgICAgICA6ICd0YWJsZXNvcnRlci1maWx0ZXInLFxyXG5cdFx0ZmlsdGVyRGlzYWJsZWQgOiAnZGlzYWJsZWQnLFxyXG5cdFx0ZmlsdGVyUm93SGlkZSAgOiAnaGlkZW1lJ1xyXG5cdH0pO1xyXG5cclxuXHQkLmV4dGVuZCggdHNrZXlDb2Rlcywge1xyXG5cdFx0YmFja1NwYWNlIDogOCxcclxuXHRcdGVzY2FwZSA6IDI3LFxyXG5cdFx0c3BhY2UgOiAzMixcclxuXHRcdGxlZnQgOiAzNyxcclxuXHRcdGRvd24gOiA0MFxyXG5cdH0pO1xyXG5cclxuXHR0cy5hZGRXaWRnZXQoe1xyXG5cdFx0aWQ6ICdmaWx0ZXInLFxyXG5cdFx0cHJpb3JpdHk6IDUwLFxyXG5cdFx0b3B0aW9ucyA6IHtcclxuXHRcdFx0ZmlsdGVyX2NlbGxGaWx0ZXIgICAgOiAnJywgICAgLy8gY3NzIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGZpbHRlciBjZWxsICggc3RyaW5nIG9yIGFycmF5IClcclxuXHRcdFx0ZmlsdGVyX2NoaWxkUm93cyAgICAgOiBmYWxzZSwgLy8gaWYgdHJ1ZSwgZmlsdGVyIGluY2x1ZGVzIGNoaWxkIHJvdyBjb250ZW50IGluIHRoZSBzZWFyY2hcclxuXHRcdFx0ZmlsdGVyX2NoaWxkQnlDb2x1bW4gOiBmYWxzZSwgLy8gKCBmaWx0ZXJfY2hpbGRSb3dzIG11c3QgYmUgdHJ1ZSApIGlmIHRydWUgPSBzZWFyY2ggY2hpbGQgcm93cyBieSBjb2x1bW47IGZhbHNlID0gc2VhcmNoIGFsbCBjaGlsZCByb3cgdGV4dCBncm91cGVkXHJcblx0XHRcdGZpbHRlcl9jaGlsZFdpdGhTaWJzIDogdHJ1ZSwgIC8vIGlmIHRydWUsIGluY2x1ZGUgbWF0Y2hpbmcgY2hpbGQgcm93IHNpYmxpbmdzXHJcblx0XHRcdGZpbHRlcl9jb2x1bW5BbnlNYXRjaDogdHJ1ZSwgIC8vIGlmIHRydWUsIGFsbG93cyB1c2luZyAnIzp7cXVlcnl9JyBpbiBBbnlNYXRjaCBzZWFyY2hlcyAoIGNvbHVtbjpxdWVyeSApXHJcblx0XHRcdGZpbHRlcl9jb2x1bW5GaWx0ZXJzIDogdHJ1ZSwgIC8vIGlmIHRydWUsIGEgZmlsdGVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiBlYWNoIHRhYmxlIGNvbHVtblxyXG5cdFx0XHRmaWx0ZXJfY3NzRmlsdGVyICAgICA6ICcnLCAgICAvLyBjc3MgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgZmlsdGVyIHJvdyAmIGVhY2ggaW5wdXQgaW4gdGhlIHJvdyAoIHRhYmxlc29ydGVyLWZpbHRlciBpcyBBTFdBWVMgYWRkZWQgKVxyXG5cdFx0XHRmaWx0ZXJfZGVmYXVsdEF0dHJpYiA6ICdkYXRhLXZhbHVlJywgLy8gZGF0YSBhdHRyaWJ1dGUgaW4gdGhlIGhlYWRlciBjZWxsIHRoYXQgY29udGFpbnMgdGhlIGRlZmF1bHQgZmlsdGVyIHZhbHVlXHJcblx0XHRcdGZpbHRlcl9kZWZhdWx0RmlsdGVyIDoge30sICAgIC8vIGFkZCBhIGRlZmF1bHQgY29sdW1uIGZpbHRlciB0eXBlICd+e3F1ZXJ5fScgdG8gbWFrZSBmdXp6eSBzZWFyY2hlcyBkZWZhdWx0OyAne3ExfSBBTkQge3EyfScgdG8gbWFrZSBhbGwgc2VhcmNoZXMgdXNlIGEgbG9naWNhbCBBTkQuXHJcblx0XHRcdGZpbHRlcl9leGNsdWRlRmlsdGVyIDoge30sICAgIC8vIGZpbHRlcnMgdG8gZXhjbHVkZSwgcGVyIGNvbHVtblxyXG5cdFx0XHRmaWx0ZXJfZXh0ZXJuYWwgICAgICA6ICcnLCAgICAvLyBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nICggb3IgalF1ZXJ5IG9iamVjdCApIG9mIGV4dGVybmFsIGZpbHRlcnNcclxuXHRcdFx0ZmlsdGVyX2ZpbHRlcmVkUm93ICAgOiAnZmlsdGVyZWQnLCAvLyBjbGFzcyBhZGRlZCB0byBmaWx0ZXJlZCByb3dzOyBkZWZpbmUgaW4gY3NzIHdpdGggXCJkaXNwbGF5Om5vbmVcIiB0byBoaWRlIHRoZSBmaWx0ZXJlZC1vdXQgcm93c1xyXG5cdFx0XHRmaWx0ZXJfZmlsdGVyTGFiZWwgICA6ICdGaWx0ZXIgXCJ7e2xhYmVsfX1cIiBjb2x1bW4gYnkuLi4nLCAvLyBBcmlhLWxhYmVsIGFkZGVkIHRvIGZpbHRlciBpbnB1dC9zZWxlY3Q7IHNlZSAjMTQ5NVxyXG5cdFx0XHRmaWx0ZXJfZm9ybWF0dGVyICAgICA6IG51bGwsICAvLyBhZGQgY3VzdG9tIGZpbHRlciBlbGVtZW50cyB0byB0aGUgZmlsdGVyIHJvd1xyXG5cdFx0XHRmaWx0ZXJfZnVuY3Rpb25zICAgICA6IG51bGwsICAvLyBhZGQgY3VzdG9tIGZpbHRlciBmdW5jdGlvbnMgdXNpbmcgdGhpcyBvcHRpb25cclxuXHRcdFx0ZmlsdGVyX2hpZGVFbXB0eSAgICAgOiB0cnVlLCAgLy8gaGlkZSBmaWx0ZXIgcm93IHdoZW4gdGFibGUgaXMgZW1wdHlcclxuXHRcdFx0ZmlsdGVyX2hpZGVGaWx0ZXJzICAgOiBmYWxzZSwgLy8gY29sbGFwc2UgZmlsdGVyIHJvdyB3aGVuIG1vdXNlIGxlYXZlcyB0aGUgYXJlYVxyXG5cdFx0XHRmaWx0ZXJfaWdub3JlQ2FzZSAgICA6IHRydWUsICAvLyBpZiB0cnVlLCBtYWtlIGFsbCBzZWFyY2hlcyBjYXNlLWluc2Vuc2l0aXZlXHJcblx0XHRcdGZpbHRlcl9saXZlU2VhcmNoICAgIDogdHJ1ZSwgIC8vIGlmIHRydWUsIHNlYXJjaCBjb2x1bW4gY29udGVudCB3aGlsZSB0aGUgdXNlciB0eXBlcyAoIHdpdGggYSBkZWxheSApXHJcblx0XHRcdGZpbHRlcl9tYXRjaFR5cGUgICAgIDogeyAnaW5wdXQnOiAnZXhhY3QnLCAnc2VsZWN0JzogJ2V4YWN0JyB9LCAvLyBnbG9iYWwgcXVlcnkgc2V0dGluZ3MgKCdleGFjdCcgb3IgJ21hdGNoJyk7IG92ZXJyaWRkZW4gYnkgXCJmaWx0ZXItbWF0Y2hcIiBvciBcImZpbHRlci1leGFjdFwiIGNsYXNzXHJcblx0XHRcdGZpbHRlcl9vbmx5QXZhaWwgICAgIDogJ2ZpbHRlci1vbmx5QXZhaWwnLCAvLyBhIGhlYWRlciB3aXRoIGEgc2VsZWN0IGRyb3Bkb3duICYgdGhpcyBjbGFzcyBuYW1lIHdpbGwgb25seSBzaG93IGF2YWlsYWJsZSAoIHZpc2libGUgKSBvcHRpb25zIHdpdGhpbiB0aGUgZHJvcCBkb3duXHJcblx0XHRcdGZpbHRlcl9wbGFjZWhvbGRlciAgIDogeyBzZWFyY2ggOiAnJywgc2VsZWN0IDogJycgfSwgLy8gZGVmYXVsdCBwbGFjZWhvbGRlciB0ZXh0ICggb3ZlcnJpZGRlbiBieSBhbnkgaGVhZGVyICdkYXRhLXBsYWNlaG9sZGVyJyBzZXR0aW5nIClcclxuXHRcdFx0ZmlsdGVyX3Jlc2V0ICAgICAgICAgOiBudWxsLCAgLy8galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvZiBhbiBlbGVtZW50IHVzZWQgdG8gcmVzZXQgdGhlIGZpbHRlcnNcclxuXHRcdFx0ZmlsdGVyX3Jlc2V0T25Fc2MgICAgOiB0cnVlLCAgLy8gUmVzZXQgZmlsdGVyIGlucHV0IHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlc2NhcGUgLSBub3JtYWxpemVkIGFjcm9zcyBicm93c2Vyc1xyXG5cdFx0XHRmaWx0ZXJfc2F2ZUZpbHRlcnMgICA6IGZhbHNlLCAvLyBVc2UgdGhlICQudGFibGVzb3J0ZXIuc3RvcmFnZSB1dGlsaXR5IHRvIHNhdmUgdGhlIG1vc3QgcmVjZW50IGZpbHRlcnNcclxuXHRcdFx0ZmlsdGVyX3NlYXJjaERlbGF5ICAgOiAzMDAsICAgLy8gdHlwaW5nIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgc3RhcnRpbmcgYSBzZWFyY2hcclxuXHRcdFx0ZmlsdGVyX3NlYXJjaEZpbHRlcmVkOiB0cnVlLCAgLy8gYWxsb3cgc2VhcmNoaW5nIHRocm91Z2ggYWxyZWFkeSBmaWx0ZXJlZCByb3dzIGluIHNwZWNpYWwgY2lyY3Vtc3RhbmNlczsgd2lsbCBzcGVlZCB1cCBzZWFyY2hpbmcgaW4gbGFyZ2UgdGFibGVzIGlmIHRydWVcclxuXHRcdFx0ZmlsdGVyX3NlbGVjdFNvdXJjZSAgOiBudWxsLCAgLy8gaW5jbHVkZSBhIGZ1bmN0aW9uIHRvIHJldHVybiBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGNvbHVtbiBmaWx0ZXIgc2VsZWN0XHJcblx0XHRcdGZpbHRlcl9zZWxlY3RTb3VyY2VTZXBhcmF0b3IgOiAnfCcsIC8vIGZpbHRlcl9zZWxlY3RTb3VyY2UgYXJyYXkgdGV4dCBsZWZ0IG9mIHRoZSBzZXBhcmF0b3IgaXMgYWRkZWQgdG8gdGhlIG9wdGlvbiB2YWx1ZSwgcmlnaHQgaW50byB0aGUgb3B0aW9uIHRleHRcclxuXHRcdFx0ZmlsdGVyX3NlcnZlcnNpZGVGaWx0ZXJpbmcgOiBmYWxzZSwgLy8gaWYgdHJ1ZSwgbXVzdCBwZXJmb3JtIHNlcnZlci1zaWRlIGZpbHRlcmluZyBiL2MgY2xpZW50LXNpZGUgZmlsdGVyaW5nIGlzIGRpc2FibGVkLCBidXQgdGhlIHVpIGFuZCBldmVudHMgd2lsbCBzdGlsbCBiZSB1c2VkLlxyXG5cdFx0XHRmaWx0ZXJfc3RhcnRzV2l0aCAgICA6IGZhbHNlLCAvLyBpZiB0cnVlLCBmaWx0ZXIgc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjZWxsIGNvbnRlbnRzXHJcblx0XHRcdGZpbHRlcl91c2VQYXJzZWREYXRhIDogZmFsc2UgIC8vIGZpbHRlciBhbGwgZGF0YSB1c2luZyBwYXJzZWQgY29udGVudFxyXG5cdFx0fSxcclxuXHRcdGZvcm1hdDogZnVuY3Rpb24oIHRhYmxlLCBjLCB3byApIHtcclxuXHRcdFx0aWYgKCAhYy4kdGFibGUuaGFzQ2xhc3MoICdoYXNGaWx0ZXJzJyApICkge1xyXG5cdFx0XHRcdHRzZi5pbml0KCB0YWJsZSwgYywgd28gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHJlbW92ZTogZnVuY3Rpb24oIHRhYmxlLCBjLCB3bywgcmVmcmVzaGluZyApIHtcclxuXHRcdFx0dmFyIHRib2R5SW5kZXgsICR0Ym9keSxcclxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcclxuXHRcdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMsXHJcblx0XHRcdFx0ZXZlbnRzID0gKFxyXG5cdFx0XHRcdFx0J2FkZFJvd3MgdXBkYXRlQ2VsbCB1cGRhdGUgdXBkYXRlUm93cyB1cGRhdGVDb21wbGV0ZSBhcHBlbmRDYWNoZSBmaWx0ZXJSZXNldCAnICtcclxuXHRcdFx0XHRcdCdmaWx0ZXJBbmRTb3J0UmVzZXQgZmlsdGVyRm9tYXR0ZXJVcGRhdGUgZmlsdGVyRW5kIHNlYXJjaCBzdGlja3lIZWFkZXJzSW5pdCAnXHJcblx0XHRcdFx0KS5zcGxpdCggJyAnICkuam9pbiggYy5uYW1lc3BhY2UgKyAnZmlsdGVyICcgKTtcclxuXHRcdFx0JHRhYmxlXHJcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCAnaGFzRmlsdGVycycgKVxyXG5cdFx0XHRcdC8vIGFkZCBmaWx0ZXIgbmFtZXNwYWNlIHRvIGFsbCBCVVQgc2VhcmNoXHJcblx0XHRcdFx0LnVuYmluZCggZXZlbnRzLnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnICkgKVxyXG5cdFx0XHRcdC8vIHJlbW92ZSB0aGUgZmlsdGVyIHJvdyBldmVuIGlmIHJlZnJlc2hpbmcsIGJlY2F1c2UgdGhlIGNvbHVtbiBtaWdodCBoYXZlIGJlZW4gbW92ZWRcclxuXHRcdFx0XHQuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyUm93ICkucmVtb3ZlKCk7XHJcblx0XHRcdHdvLmZpbHRlcl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoIHJlZnJlc2hpbmcgKSB7IHJldHVybjsgfVxyXG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8ICR0Ym9kaWVzLmxlbmd0aDsgdGJvZHlJbmRleCsrICkge1xyXG5cdFx0XHRcdCR0Ym9keSA9IHRzLnByb2Nlc3NUYm9keSggdGFibGUsICR0Ym9kaWVzLmVxKCB0Ym9keUluZGV4ICksIHRydWUgKTsgLy8gcmVtb3ZlIHRib2R5XHJcblx0XHRcdFx0JHRib2R5LmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApLnNob3coKTtcclxuXHRcdFx0XHR0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCAkdGJvZHksIGZhbHNlICk7IC8vIHJlc3RvcmUgdGJvZHlcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9yZXNldCApIHtcclxuXHRcdFx0XHQkKCBkb2N1bWVudCApLnVuZGVsZWdhdGUoIHdvLmZpbHRlcl9yZXNldCwgJ2NsaWNrJyArIGMubmFtZXNwYWNlICsgJ2ZpbHRlcicgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHR0c2YgPSB0cy5maWx0ZXIgPSB7XHJcblxyXG5cdFx0Ly8gcmVnZXggdXNlZCBpbiBmaWx0ZXIgJ2NoZWNrJyBmdW5jdGlvbnMgLSBub3QgZm9yIGdlbmVyYWwgdXNlIGFuZCBub3QgZG9jdW1lbnRlZFxyXG5cdFx0cmVnZXg6IHtcclxuXHRcdFx0cmVnZXggICAgIDogL15cXC8oKD86XFxcXFxcL3xbXlxcL10pKylcXC8oW21pZ3l1XXswLDV9KT8kLywgLy8gcmVnZXggdG8gdGVzdCBmb3IgcmVnZXhcclxuXHRcdFx0Y2hpbGQgICAgIDogL3RhYmxlc29ydGVyLWNoaWxkUm93LywgLy8gY2hpbGQgcm93IGNsYXNzIG5hbWU7IHRoaXMgZ2V0cyB1cGRhdGVkIGluIHRoZSBzY3JpcHRcclxuXHRcdFx0ZmlsdGVyZWQgIDogL2ZpbHRlcmVkLywgLy8gZmlsdGVyZWQgKGhpZGRlbikgcm93IGNsYXNzIG5hbWU7IHVwZGF0ZWQgaW4gdGhlIHNjcmlwdFxyXG5cdFx0XHR0eXBlICAgICAgOiAvdW5kZWZpbmVkfG51bWJlci8sIC8vIGNoZWNrIHR5cGVcclxuXHRcdFx0ZXhhY3QgICAgIDogLyheW1xcXCJcXCc9XSspfChbXFxcIlxcJz1dKyQpL2csIC8vIGV4YWN0IG1hdGNoIChhbGxvdyAnPT0nKVxyXG5cdFx0XHRvcGVyYXRvcnMgOiAvWzw+PV0vZywgLy8gcmVwbGFjZSBvcGVyYXRvcnNcclxuXHRcdFx0cXVlcnkgICAgIDogJyhxfHF1ZXJ5KScsIC8vIHJlcGxhY2UgZmlsdGVyIHF1ZXJpZXNcclxuXHRcdFx0d2lsZDAxICAgIDogL1xcPy9nLCAvLyB3aWxkIGNhcmQgbWF0Y2ggMCBvciAxXHJcblx0XHRcdHdpbGQwTW9yZSA6IC9cXCovZywgLy8gd2lsZCBjYXJlIG1hdGNoIDAgb3IgbW9yZVxyXG5cdFx0XHRxdW90ZSAgICAgOiAvXFxcIi9nLFxyXG5cdFx0XHRpc05lZzEgICAgOiAvKD49P1xccyotXFxkKS8sXHJcblx0XHRcdGlzTmVnMiAgICA6IC8oPD0/XFxzKlxcZCkvXHJcblx0XHR9LFxyXG5cdFx0Ly8gZnVuY3Rpb24oIGMsIGRhdGEgKSB7IH1cclxuXHRcdC8vIGMgPSB0YWJsZS5jb25maWdcclxuXHRcdC8vIGRhdGEuJHJvdyA9IGpRdWVyeSBvYmplY3Qgb2YgdGhlIHJvdyBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkXHJcblx0XHQvLyBkYXRhLiRjZWxscyA9IGpRdWVyeSBvYmplY3Qgb2YgYWxsIGNlbGxzIHdpdGhpbiB0aGUgY3VycmVudCByb3dcclxuXHRcdC8vIGRhdGEuZmlsdGVycyA9IGFycmF5IG9mIGZpbHRlcnMgZm9yIGFsbCBjb2x1bW5zICggc29tZSBtYXkgYmUgdW5kZWZpbmVkIClcclxuXHRcdC8vIGRhdGEuZmlsdGVyID0gZmlsdGVyIGZvciB0aGUgY3VycmVudCBjb2x1bW5cclxuXHRcdC8vIGRhdGEuaUZpbHRlciA9IHNhbWUgYXMgZGF0YS5maWx0ZXIsIGV4Y2VwdCBsb3dlcmNhc2UgKCBpZiB3by5maWx0ZXJfaWdub3JlQ2FzZSBpcyB0cnVlIClcclxuXHRcdC8vIGRhdGEuZXhhY3QgPSB0YWJsZSBjZWxsIHRleHQgKCBvciBwYXJzZWQgZGF0YSBpZiBjb2x1bW4gcGFyc2VyIGVuYWJsZWQ7IG1heSBiZSBhIG51bWJlciAmIG5vdCBhIHN0cmluZyApXHJcblx0XHQvLyBkYXRhLmlFeGFjdCA9IHNhbWUgYXMgZGF0YS5leGFjdCwgZXhjZXB0IGxvd2VyY2FzZSAoIGlmIHdvLmZpbHRlcl9pZ25vcmVDYXNlIGlzIHRydWU7IG1heSBiZSBhIG51bWJlciAmIG5vdCBhIHN0cmluZyApXHJcblx0XHQvLyBkYXRhLmNhY2hlID0gdGFibGUgY2VsbCB0ZXh0IGZyb20gY2FjaGUsIHNvIGl0IGhhcyBiZWVuIHBhcnNlZCAoICYgaW4gYWxsIGxvd2VyIGNhc2UgaWYgYy5pZ25vcmVDYXNlIGlzIHRydWUgKVxyXG5cdFx0Ly8gZGF0YS5jYWNoZUFycmF5ID0gQW4gYXJyYXkgb2YgcGFyc2VkIGNvbnRlbnQgZnJvbSBlYWNoIHRhYmxlIGNlbGwgaW4gdGhlIHJvdyBiZWluZyBwcm9jZXNzZWRcclxuXHRcdC8vIGRhdGEuaW5kZXggPSBjb2x1bW4gaW5kZXg7IHRhYmxlID0gdGFibGUgZWxlbWVudCAoIERPTSApXHJcblx0XHQvLyBkYXRhLnBhcnNlZCA9IGFycmF5ICggYnkgY29sdW1uICkgb2YgYm9vbGVhbiB2YWx1ZXMgKCBmcm9tIGZpbHRlcl91c2VQYXJzZWREYXRhIG9yICdmaWx0ZXItcGFyc2VkJyBjbGFzcyApXHJcblx0XHR0eXBlczoge1xyXG5cdFx0XHRvciA6IGZ1bmN0aW9uKCBjLCBkYXRhLCB2YXJzICkge1xyXG5cdFx0XHRcdC8vIGxvb2sgZm9yIFwifFwiLCBidXQgbm90IGlmIGl0IGlzIGluc2lkZSBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG5cdFx0XHRcdGlmICggKCB0c2ZSZWdleC5vclRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgfHwgdHNmUmVnZXgub3JTcGxpdC50ZXN0KCBkYXRhLmZpbHRlciApICkgJiZcclxuXHRcdFx0XHRcdC8vIHRoaXMgdGVzdCBmb3IgcmVnZXggaGFzIHBvdGVudGlhbCB0byBzbG93IGRvd24gdGhlIG92ZXJhbGwgc2VhcmNoXHJcblx0XHRcdFx0XHQhdHNmUmVnZXgucmVnZXgudGVzdCggZGF0YS5maWx0ZXIgKSApIHtcclxuXHRcdFx0XHRcdHZhciBpbmR4LCBmaWx0ZXJNYXRjaGVkLCBxdWVyeSwgcmVnZXgsXHJcblx0XHRcdFx0XHRcdC8vIGR1cGxpY2F0ZSBkYXRhIGJ1dCBzcGxpdCBmaWx0ZXJcclxuXHRcdFx0XHRcdFx0ZGF0YTIgPSAkLmV4dGVuZCgge30sIGRhdGEgKSxcclxuXHRcdFx0XHRcdFx0ZmlsdGVyID0gZGF0YS5maWx0ZXIuc3BsaXQoIHRzZlJlZ2V4Lm9yU3BsaXQgKSxcclxuXHRcdFx0XHRcdFx0aUZpbHRlciA9IGRhdGEuaUZpbHRlci5zcGxpdCggdHNmUmVnZXgub3JTcGxpdCApLFxyXG5cdFx0XHRcdFx0XHRsZW4gPSBmaWx0ZXIubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdFx0ZGF0YTIubmVzdGVkRmlsdGVycyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGRhdGEyLmZpbHRlciA9ICcnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGZpbHRlclsgaW5keCBdLCBkYXRhICkgfHwgJycgKTtcclxuXHRcdFx0XHRcdFx0ZGF0YTIuaUZpbHRlciA9ICcnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGlGaWx0ZXJbIGluZHggXSwgZGF0YSApIHx8ICcnICk7XHJcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gJygnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEyLmZpbHRlciwgZGF0YSApIHx8ICcnICkgKyAnKSc7XHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHRyeS9jYXRjaCwgYmVjYXVzZSBxdWVyeSBtYXkgbm90IGJlIGEgdmFsaWQgcmVnZXggaWYgXCJ8XCIgaXMgY29udGFpbmVkIHdpdGhpbiBhIHBhcnRpYWwgcmVnZXggc2VhcmNoLFxyXG5cdFx0XHRcdFx0XHRcdC8vIGUuZyBcIi8oQWxleHxBYXJcIiAtPiBVbmNhdWdodCBTeW50YXhFcnJvcjogSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oLyhBbGV4KS86IFVudGVybWluYXRlZCBncm91cFxyXG5cdFx0XHRcdFx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggZGF0YS5pc01hdGNoID8gcXVlcnkgOiAnXicgKyBxdWVyeSArICckJywgYy53aWRnZXRPcHRpb25zLmZpbHRlcl9pZ25vcmVDYXNlID8gJ2knIDogJycgKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBmaWx0ZXJNYXRjaGVkID0gZGF0YTIuZmlsdGVyID09PSAnJyAmJiBpbmR4ID4gMCA/IHRydWVcclxuXHRcdFx0XHRcdFx0XHQvLyBsb29rIGZvciBhbiBleGFjdCBtYXRjaCB3aXRoIHRoZSAnb3InIHVubGVzcyB0aGUgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcclxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gcmVnZXgudGVzdCggZGF0YTIuZXhhY3QgKSB8fCB0c2YucHJvY2Vzc1R5cGVzKCBjLCBkYXRhMiwgdmFycyApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggZmlsdGVyTWF0Y2hlZCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmaWx0ZXJNYXRjaGVkO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyBtYXkgYmUgbnVsbCBmcm9tIHByb2Nlc3NpbmcgdHlwZXNcclxuXHRcdFx0XHRcdHJldHVybiBmaWx0ZXJNYXRjaGVkIHx8IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gTG9vayBmb3IgYW4gQU5EIG9yICYmIG9wZXJhdG9yICggbG9naWNhbCBhbmQgKVxyXG5cdFx0XHRhbmQgOiBmdW5jdGlvbiggYywgZGF0YSwgdmFycyApIHtcclxuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4LmFuZFRlc3QudGVzdCggZGF0YS5maWx0ZXIgKSApIHtcclxuXHRcdFx0XHRcdHZhciBpbmR4LCBmaWx0ZXJNYXRjaGVkLCByZXN1bHQsIHF1ZXJ5LCByZWdleCxcclxuXHRcdFx0XHRcdFx0Ly8gZHVwbGljYXRlIGRhdGEgYnV0IHNwbGl0IGZpbHRlclxyXG5cdFx0XHRcdFx0XHRkYXRhMiA9ICQuZXh0ZW5kKCB7fSwgZGF0YSApLFxyXG5cdFx0XHRcdFx0XHRmaWx0ZXIgPSBkYXRhLmZpbHRlci5zcGxpdCggdHNmUmVnZXguYW5kU3BsaXQgKSxcclxuXHRcdFx0XHRcdFx0aUZpbHRlciA9IGRhdGEuaUZpbHRlci5zcGxpdCggdHNmUmVnZXguYW5kU3BsaXQgKSxcclxuXHRcdFx0XHRcdFx0bGVuID0gZmlsdGVyLmxlbmd0aDtcclxuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XHJcblx0XHRcdFx0XHRcdGRhdGEyLm5lc3RlZEZpbHRlcnMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRkYXRhMi5maWx0ZXIgPSAnJyArICggdHNmLnBhcnNlRmlsdGVyKCBjLCBmaWx0ZXJbIGluZHggXSwgZGF0YSApIHx8ICcnICk7XHJcblx0XHRcdFx0XHRcdGRhdGEyLmlGaWx0ZXIgPSAnJyArICggdHNmLnBhcnNlRmlsdGVyKCBjLCBpRmlsdGVyWyBpbmR4IF0sIGRhdGEgKSB8fCAnJyApO1xyXG5cdFx0XHRcdFx0XHRxdWVyeSA9ICggJygnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEyLmZpbHRlciwgZGF0YSApIHx8ICcnICkgKyAnKScgKVxyXG5cdFx0XHRcdFx0XHRcdC8vIHJlcGxhY2Ugd2lsZCBjYXJkcyBzaW5jZSAvKGEqKS9pIHdpbGwgbWF0Y2ggYW55dGhpbmdcclxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSggdHNmUmVnZXgud2lsZDAxLCAnXFxcXFN7MX0nICkucmVwbGFjZSggdHNmUmVnZXgud2lsZDBNb3JlLCAnXFxcXFMqJyApO1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0cnkvY2F0Y2gganVzdCBpbiBjYXNlIFJlZ0V4cCBpcyBpbnZhbGlkXHJcblx0XHRcdFx0XHRcdFx0cmVnZXggPSBuZXcgUmVnRXhwKCBkYXRhLmlzTWF0Y2ggPyBxdWVyeSA6ICdeJyArIHF1ZXJ5ICsgJyQnLCBjLndpZGdldE9wdGlvbnMuZmlsdGVyX2lnbm9yZUNhc2UgPyAnaScgOiAnJyApO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGxvb2sgZm9yIGFuIGV4YWN0IG1hdGNoIHdpdGggdGhlICdhbmQnIHVubGVzcyB0aGUgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSAoIHJlZ2V4LnRlc3QoIGRhdGEyLmV4YWN0ICkgfHwgdHNmLnByb2Nlc3NUeXBlcyggYywgZGF0YTIsIHZhcnMgKSApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaW5keCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSByZXN1bHQ7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSBmaWx0ZXJNYXRjaGVkICYmIHJlc3VsdDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gbWF5IGJlIG51bGwgZnJvbSBwcm9jZXNzaW5nIHR5cGVzXHJcblx0XHRcdFx0XHRyZXR1cm4gZmlsdGVyTWF0Y2hlZCB8fCBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIExvb2sgZm9yIHJlZ2V4XHJcblx0XHRcdHJlZ2V4OiBmdW5jdGlvbiggYywgZGF0YSApIHtcclxuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4LnJlZ2V4LnRlc3QoIGRhdGEuZmlsdGVyICkgKSB7XHJcblx0XHRcdFx0XHR2YXIgbWF0Y2hlcyxcclxuXHRcdFx0XHRcdFx0Ly8gY2FjaGUgcmVnZXggcGVyIGNvbHVtbiBmb3Igb3B0aW1hbCBzcGVlZFxyXG5cdFx0XHRcdFx0XHRyZWdleCA9IGRhdGEuZmlsdGVyX3JlZ2V4Q2FjaGVbIGRhdGEuaW5kZXggXSB8fCB0c2ZSZWdleC5yZWdleC5leGVjKCBkYXRhLmZpbHRlciApLFxyXG5cdFx0XHRcdFx0XHRpc1JlZ2V4ID0gcmVnZXggaW5zdGFuY2VvZiBSZWdFeHA7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRpZiAoICFpc1JlZ2V4ICkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGZvcmNlIGNhc2UgaW5zZW5zaXRpdmUgc2VhcmNoIGlmIGlnbm9yZUNhc2Ugb3B0aW9uIHNldD9cclxuXHRcdFx0XHRcdFx0XHQvLyBpZiAoIGMuaWdub3JlQ2FzZSAmJiAhcmVnZXhbMl0gKSB7IHJlZ2V4WzJdID0gJ2knOyB9XHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5maWx0ZXJfcmVnZXhDYWNoZVsgZGF0YS5pbmRleCBdID0gcmVnZXggPSBuZXcgUmVnRXhwKCByZWdleFsxXSwgcmVnZXhbMl0gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRtYXRjaGVzID0gcmVnZXgudGVzdCggZGF0YS5leGFjdCApO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cdFx0XHRcdFx0XHRtYXRjaGVzID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIExvb2sgZm9yIG9wZXJhdG9ycyA+LCA+PSwgPCBvciA8PVxyXG5cdFx0XHRvcGVyYXRvcnM6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xyXG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzLi4uIGJlY2F1c2UgJycgPCAxMCBpcyB0cnVlXHJcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC5vcGVyVGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSAmJiBkYXRhLmlFeGFjdCAhPT0gJycgKSB7XHJcblx0XHRcdFx0XHR2YXIgY2FjaGVkVmFsdWUsIHJlc3VsdCwgdHh0LFxyXG5cdFx0XHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXHJcblx0XHRcdFx0XHRcdHBhcnNlZCA9IGRhdGEucGFyc2VkWyBkYXRhLmluZGV4IF0sXHJcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gdHMuZm9ybWF0RmxvYXQoIGRhdGEuaUZpbHRlci5yZXBsYWNlKCB0c2ZSZWdleC5vcGVyYXRvcnMsICcnICksIHRhYmxlICksXHJcblx0XHRcdFx0XHRcdHBhcnNlciA9IGMucGFyc2Vyc1sgZGF0YS5pbmRleCBdIHx8IHt9LFxyXG5cdFx0XHRcdFx0XHRzYXZlZFNlYXJjaCA9IHF1ZXJ5O1xyXG5cdFx0XHRcdFx0Ly8gcGFyc2UgZmlsdGVyIHZhbHVlIGluIGNhc2Ugd2UncmUgY29tcGFyaW5nIG51bWJlcnMgKCBkYXRlcyApXHJcblx0XHRcdFx0XHRpZiAoIHBhcnNlZCB8fCBwYXJzZXIudHlwZSA9PT0gJ251bWVyaWMnICkge1xyXG5cdFx0XHRcdFx0XHR0eHQgPSAkLnRyaW0oICcnICsgZGF0YS5pRmlsdGVyLnJlcGxhY2UoIHRzZlJlZ2V4Lm9wZXJhdG9ycywgJycgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB0c2YucGFyc2VGaWx0ZXIoIGMsIHR4dCwgZGF0YSwgdHJ1ZSApO1xyXG5cdFx0XHRcdFx0XHRxdWVyeSA9ICggdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgJiYgcmVzdWx0ICE9PSAnJyAmJiAhaXNOYU4oIHJlc3VsdCApICkgPyByZXN1bHQgOiBxdWVyeTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIGlFeGFjdCBtYXkgYmUgbnVtZXJpYyAtIHNlZSBpc3N1ZSAjMTQ5O1xyXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgY2FjaGVkIGlzIGRlZmluZWQsIGJlY2F1c2Ugc29tZXRpbWVzIGogZ29lcyBvdXQgb2YgcmFuZ2U/ICggbnVtZXJpYyBjb2x1bW5zIClcclxuXHRcdFx0XHRcdGlmICggKCBwYXJzZWQgfHwgcGFyc2VyLnR5cGUgPT09ICdudW1lcmljJyApICYmICFpc05hTiggcXVlcnkgKSAmJlxyXG5cdFx0XHRcdFx0XHR0eXBlb2YgZGF0YS5jYWNoZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0XHRcdFx0XHRcdGNhY2hlZFZhbHVlID0gZGF0YS5jYWNoZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHR4dCA9IGlzTmFOKCBkYXRhLmlFeGFjdCApID8gZGF0YS5pRXhhY3QucmVwbGFjZSggdHMucmVnZXgubm9uZGlnaXQsICcnICkgOiBkYXRhLmlFeGFjdDtcclxuXHRcdFx0XHRcdFx0Y2FjaGVkVmFsdWUgPSB0cy5mb3JtYXRGbG9hdCggdHh0LCB0YWJsZSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCB0c2ZSZWdleC5ndFRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRzZlJlZ2V4Lmd0ZVRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgPyBjYWNoZWRWYWx1ZSA+PSBxdWVyeSA6IGNhY2hlZFZhbHVlID4gcXVlcnk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0c2ZSZWdleC5sdFRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRzZlJlZ2V4Lmx0ZVRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgPyBjYWNoZWRWYWx1ZSA8PSBxdWVyeSA6IGNhY2hlZFZhbHVlIDwgcXVlcnk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyBrZWVwIHNob3dpbmcgYWxsIHJvd3MgaWYgbm90aGluZyBmb2xsb3dzIHRoZSBvcGVyYXRvclxyXG5cdFx0XHRcdFx0aWYgKCAhcmVzdWx0ICYmIHNhdmVkU2VhcmNoID09PSAnJyApIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBMb29rIGZvciBhIG5vdCBtYXRjaFxyXG5cdFx0XHRub3RNYXRjaDogZnVuY3Rpb24oIGMsIGRhdGEgKSB7XHJcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC5ub3RUZXN0LnRlc3QoIGRhdGEuaUZpbHRlciApICkge1xyXG5cdFx0XHRcdFx0dmFyIGluZHgsXHJcblx0XHRcdFx0XHRcdHR4dCA9IGRhdGEuaUZpbHRlci5yZXBsYWNlKCAnIScsICcnICksXHJcblx0XHRcdFx0XHRcdGZpbHRlciA9IHRzZi5wYXJzZUZpbHRlciggYywgdHh0LCBkYXRhICkgfHwgJyc7XHJcblx0XHRcdFx0XHRpZiAoIHRzZlJlZ2V4LmV4YWN0LnRlc3QoIGZpbHRlciApICkge1xyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGZvciBleGFjdCBub3QgbWF0Y2hlcyAtIHNlZSAjNjI4XHJcblx0XHRcdFx0XHRcdGZpbHRlciA9IGZpbHRlci5yZXBsYWNlKCB0c2ZSZWdleC5leGFjdCwgJycgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZpbHRlciA9PT0gJycgPyB0cnVlIDogJC50cmltKCBmaWx0ZXIgKSAhPT0gZGF0YS5pRXhhY3Q7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpbmR4ID0gZGF0YS5pRXhhY3Quc2VhcmNoKCAkLnRyaW0oIGZpbHRlciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmaWx0ZXIgPT09ICcnID8gdHJ1ZSA6XHJcblx0XHRcdFx0XHRcdFx0Ly8gcmV0dXJuIHRydWUgaWYgbm90IGZvdW5kXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaCA/IGluZHggPCAwIDpcclxuXHRcdFx0XHRcdFx0XHQvLyByZXR1cm4gZmFsc2UgaWYgZm91bmRcclxuXHRcdFx0XHRcdFx0XHQhKCBjLndpZGdldE9wdGlvbnMuZmlsdGVyX3N0YXJ0c1dpdGggPyBpbmR4ID09PSAwIDogaW5keCA+PSAwICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBMb29rIGZvciBxdW90ZXMgb3IgZXF1YWxzIHRvIGdldCBhbiBleGFjdCBtYXRjaDsgaWdub3JlIHR5cGUgc2luY2UgaUV4YWN0IGNvdWxkIGJlIG51bWVyaWNcclxuXHRcdFx0ZXhhY3Q6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xyXG5cdFx0XHRcdC8qanNoaW50IGVxZXFlcTpmYWxzZSAqL1xyXG5cdFx0XHRcdGlmICggdHNmUmVnZXguZXhhY3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XHJcblx0XHRcdFx0XHR2YXIgdHh0ID0gZGF0YS5pRmlsdGVyLnJlcGxhY2UoIHRzZlJlZ2V4LmV4YWN0LCAnJyApLFxyXG5cdFx0XHRcdFx0XHRmaWx0ZXIgPSB0c2YucGFyc2VGaWx0ZXIoIGMsIHR4dCwgZGF0YSApIHx8ICcnO1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuYW55TWF0Y2ggPyAkLmluQXJyYXkoIGZpbHRlciwgZGF0YS5yb3dBcnJheSApID49IDAgOiBmaWx0ZXIgPT0gZGF0YS5pRXhhY3Q7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBMb29rIGZvciBhIHJhbmdlICggdXNpbmcgJyB0byAnIG9yICcgLSAnICkgLSBzZWUgaXNzdWUgIzE2NjsgdGhhbmtzIG1hdHpodSFcclxuXHRcdFx0cmFuZ2UgOiBmdW5jdGlvbiggYywgZGF0YSApIHtcclxuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4LnRvVGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSApIHtcclxuXHRcdFx0XHRcdHZhciByZXN1bHQsIHRtcCwgcmFuZ2UxLCByYW5nZTIsXHJcblx0XHRcdFx0XHRcdHRhYmxlID0gYy50YWJsZSxcclxuXHRcdFx0XHRcdFx0aW5kZXggPSBkYXRhLmluZGV4LFxyXG5cdFx0XHRcdFx0XHRwYXJzZWQgPSBkYXRhLnBhcnNlZFtpbmRleF0sXHJcblx0XHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgZGFzaCBpcyBmb3IgYSByYW5nZSBhbmQgbm90IGluZGljYXRpbmcgYSBuZWdhdGl2ZSBudW1iZXJcclxuXHRcdFx0XHRcdFx0cXVlcnkgPSBkYXRhLmlGaWx0ZXIuc3BsaXQoIHRzZlJlZ2V4LnRvU3BsaXQgKTtcclxuXHJcblx0XHRcdFx0XHR0bXAgPSBxdWVyeVswXS5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSB8fCAnJztcclxuXHRcdFx0XHRcdHJhbmdlMSA9IHRzLmZvcm1hdEZsb2F0KCB0c2YucGFyc2VGaWx0ZXIoIGMsIHRtcCwgZGF0YSApLCB0YWJsZSApO1xyXG5cdFx0XHRcdFx0dG1wID0gcXVlcnlbMV0ucmVwbGFjZSggdHMucmVnZXgubm9uZGlnaXQsICcnICkgfHwgJyc7XHJcblx0XHRcdFx0XHRyYW5nZTIgPSB0cy5mb3JtYXRGbG9hdCggdHNmLnBhcnNlRmlsdGVyKCBjLCB0bXAsIGRhdGEgKSwgdGFibGUgKTtcclxuXHRcdFx0XHRcdC8vIHBhcnNlIGZpbHRlciB2YWx1ZSBpbiBjYXNlIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzICggZGF0ZXMgKVxyXG5cdFx0XHRcdFx0aWYgKCBwYXJzZWQgfHwgYy5wYXJzZXJzWyBpbmRleCBdLnR5cGUgPT09ICdudW1lcmljJyApIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gYy5wYXJzZXJzWyBpbmRleCBdLmZvcm1hdCggJycgKyBxdWVyeVswXSwgdGFibGUsIGMuJGhlYWRlcnMuZXEoIGluZGV4ICksIGluZGV4ICk7XHJcblx0XHRcdFx0XHRcdHJhbmdlMSA9ICggcmVzdWx0ICE9PSAnJyAmJiAhaXNOYU4oIHJlc3VsdCApICkgPyByZXN1bHQgOiByYW5nZTE7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGMucGFyc2Vyc1sgaW5kZXggXS5mb3JtYXQoICcnICsgcXVlcnlbMV0sIHRhYmxlLCBjLiRoZWFkZXJzLmVxKCBpbmRleCApLCBpbmRleCApO1xyXG5cdFx0XHRcdFx0XHRyYW5nZTIgPSAoIHJlc3VsdCAhPT0gJycgJiYgIWlzTmFOKCByZXN1bHQgKSApID8gcmVzdWx0IDogcmFuZ2UyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCAoIHBhcnNlZCB8fCBjLnBhcnNlcnNbIGluZGV4IF0udHlwZSA9PT0gJ251bWVyaWMnICkgJiYgIWlzTmFOKCByYW5nZTEgKSAmJiAhaXNOYU4oIHJhbmdlMiApICkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhLmNhY2hlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dG1wID0gaXNOYU4oIGRhdGEuaUV4YWN0ICkgPyBkYXRhLmlFeGFjdC5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSA6IGRhdGEuaUV4YWN0O1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB0cy5mb3JtYXRGbG9hdCggdG1wLCB0YWJsZSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCByYW5nZTEgPiByYW5nZTIgKSB7XHJcblx0XHRcdFx0XHRcdHRtcCA9IHJhbmdlMTsgcmFuZ2UxID0gcmFuZ2UyOyByYW5nZTIgPSB0bXA7IC8vIHN3YXBcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAoIHJlc3VsdCA+PSByYW5nZTEgJiYgcmVzdWx0IDw9IHJhbmdlMiApIHx8ICggcmFuZ2UxID09PSAnJyB8fCByYW5nZTIgPT09ICcnICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBMb29rIGZvciB3aWxkIGNhcmQ6ID8gPSBzaW5nbGUsICogPSBtdWx0aXBsZSwgb3IgfCA9IGxvZ2ljYWwgT1JcclxuXHRcdFx0d2lsZCA6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xyXG5cdFx0XHRcdGlmICggdHNmUmVnZXgud2lsZE9yVGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSApIHtcclxuXHRcdFx0XHRcdHZhciBxdWVyeSA9ICcnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEuaUZpbHRlciwgZGF0YSApIHx8ICcnICk7XHJcblx0XHRcdFx0XHQvLyBsb29rIGZvciBhbiBleGFjdCBtYXRjaCB3aXRoIHRoZSAnb3InIHVubGVzcyB0aGUgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcclxuXHRcdFx0XHRcdGlmICggIXRzZlJlZ2V4LndpbGRUZXN0LnRlc3QoIHF1ZXJ5ICkgJiYgZGF0YS5uZXN0ZWRGaWx0ZXJzICkge1xyXG5cdFx0XHRcdFx0XHRxdWVyeSA9IGRhdGEuaXNNYXRjaCA/IHF1ZXJ5IDogJ14oJyArIHF1ZXJ5ICsgJykkJztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHBhcnNpbmcgdGhlIGZpbHRlciBtYXkgbm90IHdvcmsgcHJvcGVybHkgd2hlbiB1c2luZyB3aWxkY2FyZHMgPS9cclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKFxyXG5cdFx0XHRcdFx0XHRcdHF1ZXJ5LnJlcGxhY2UoIHRzZlJlZ2V4LndpbGQwMSwgJ1xcXFxTezF9JyApLnJlcGxhY2UoIHRzZlJlZ2V4LndpbGQwTW9yZSwgJ1xcXFxTKicgKSxcclxuXHRcdFx0XHRcdFx0XHRjLndpZGdldE9wdGlvbnMuZmlsdGVyX2lnbm9yZUNhc2UgPyAnaScgOiAnJ1xyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRcdC50ZXN0KCBkYXRhLmV4YWN0ICk7XHJcblx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gZnV6enkgdGV4dCBzZWFyY2g7IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHR5b3JrL2Z1enp5ICggTUlUIGxpY2Vuc2UgKVxyXG5cdFx0XHRmdXp6eTogZnVuY3Rpb24oIGMsIGRhdGEgKSB7XHJcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC5mdXp6eVRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XHJcblx0XHRcdFx0XHR2YXIgaW5keCxcclxuXHRcdFx0XHRcdFx0cGF0dGVybkluZHggPSAwLFxyXG5cdFx0XHRcdFx0XHRsZW4gPSBkYXRhLmlFeGFjdC5sZW5ndGgsXHJcblx0XHRcdFx0XHRcdHR4dCA9IGRhdGEuaUZpbHRlci5zbGljZSggMSApLFxyXG5cdFx0XHRcdFx0XHRwYXR0ZXJuID0gdHNmLnBhcnNlRmlsdGVyKCBjLCB0eHQsIGRhdGEgKSB8fCAnJztcclxuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggZGF0YS5pRXhhY3RbIGluZHggXSA9PT0gcGF0dGVyblsgcGF0dGVybkluZHggXSApIHtcclxuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuSW5keCArPSAxO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybkluZHggPT09IHBhdHRlcm4ubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGluaXQ6IGZ1bmN0aW9uKCB0YWJsZSApIHtcclxuXHRcdFx0Ly8gZmlsdGVyIGxhbmd1YWdlIG9wdGlvbnNcclxuXHRcdFx0dHMubGFuZ3VhZ2UgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHtcclxuXHRcdFx0XHR0byAgOiAndG8nLFxyXG5cdFx0XHRcdG9yICA6ICdvcicsXHJcblx0XHRcdFx0YW5kIDogJ2FuZCdcclxuXHRcdFx0fSwgdHMubGFuZ3VhZ2UgKTtcclxuXHJcblx0XHRcdHZhciBvcHRpb25zLCBzdHJpbmcsIHR4dCwgJGhlYWRlciwgY29sdW1uLCB2YWwsIGZ4biwgbm9TZWxlY3QsXHJcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcclxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcclxuXHRcdFx0XHRwcm9jZXNzU3RyID0gZnVuY3Rpb24ocHJlZml4LCBzdHIsIHN1ZmZpeCkge1xyXG5cdFx0XHRcdFx0c3RyID0gc3RyLnRyaW0oKTtcclxuXHRcdFx0XHRcdC8vIGRvbid0IGluY2x1ZGUgcHJlZml4L3N1ZmZpeCBpZiBzdHIgaXMgZW1wdHlcclxuXHRcdFx0XHRcdHJldHVybiBzdHIgPT09ICcnID8gJycgOiAocHJlZml4IHx8ICcnKSArIHN0ciArIChzdWZmaXggfHwgJycpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdGMuJHRhYmxlLmFkZENsYXNzKCAnaGFzRmlsdGVycycgKTtcclxuXHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XHJcblxyXG5cdFx0XHQvLyBkZWZpbmUgdGltZXJzIHNvIHVzaW5nIGNsZWFyVGltZW91dCB3b24ndCBjYXVzZSBhbiB1bmRlZmluZWQgZXJyb3JcclxuXHRcdFx0d28uZmlsdGVyX3NlYXJjaFRpbWVyID0gbnVsbDtcclxuXHRcdFx0d28uZmlsdGVyX2luaXRUaW1lciA9IG51bGw7XHJcblx0XHRcdHdvLmZpbHRlcl9mb3JtYXR0ZXJDb3VudCA9IDA7XHJcblx0XHRcdHdvLmZpbHRlcl9mb3JtYXR0ZXJJbml0ID0gW107XHJcblx0XHRcdHdvLmZpbHRlcl9hbnlDb2x1bW5TZWxlY3RvciA9ICdbZGF0YS1jb2x1bW49XCJhbGxcIl0sW2RhdGEtY29sdW1uPVwiYW55XCJdJztcclxuXHRcdFx0d28uZmlsdGVyX211bHRpcGxlQ29sdW1uU2VsZWN0b3IgPSAnW2RhdGEtY29sdW1uKj1cIi1cIl0sW2RhdGEtY29sdW1uKj1cIixcIl0nO1xyXG5cclxuXHRcdFx0dmFsID0gJ1xcXFx7JyArIHRzZlJlZ2V4LnF1ZXJ5ICsgJ1xcXFx9JztcclxuXHRcdFx0JC5leHRlbmQoIHRzZlJlZ2V4LCB7XHJcblx0XHRcdFx0Y2hpbGQgOiBuZXcgUmVnRXhwKCBjLmNzc0NoaWxkUm93ICksXHJcblx0XHRcdFx0ZmlsdGVyZWQgOiBuZXcgUmVnRXhwKCB3by5maWx0ZXJfZmlsdGVyZWRSb3cgKSxcclxuXHRcdFx0XHRhbHJlYWR5RmlsdGVyZWQgOiBuZXcgUmVnRXhwKCAnKFxcXFxzKygtJyArIHByb2Nlc3NTdHIoJ3wnLCB0cy5sYW5ndWFnZS5vcikgKyBwcm9jZXNzU3RyKCd8JywgdHMubGFuZ3VhZ2UudG8pICsgJylcXFxccyspJywgJ2knICksXHJcblx0XHRcdFx0dG9UZXN0IDogbmV3IFJlZ0V4cCggJ1xcXFxzKygtJyArIHByb2Nlc3NTdHIoJ3wnLCB0cy5sYW5ndWFnZS50bykgKyAnKVxcXFxzKycsICdpJyApLFxyXG5cdFx0XHRcdHRvU3BsaXQgOiBuZXcgUmVnRXhwKCAnKD86XFxcXHMrKD86LScgKyBwcm9jZXNzU3RyKCd8JywgdHMubGFuZ3VhZ2UudG8pICsgJylcXFxccyspJywgJ2dpJyApLFxyXG5cdFx0XHRcdGFuZFRlc3QgOiBuZXcgUmVnRXhwKCAnXFxcXHMrKCcgKyBwcm9jZXNzU3RyKCcnLCB0cy5sYW5ndWFnZS5hbmQsICd8JykgKyAnJiYpXFxcXHMrJywgJ2knICksXHJcblx0XHRcdFx0YW5kU3BsaXQgOiBuZXcgUmVnRXhwKCAnKD86XFxcXHMrKD86JyArIHByb2Nlc3NTdHIoJycsIHRzLmxhbmd1YWdlLmFuZCwgJ3wnKSArICcmJilcXFxccyspJywgJ2dpJyApLFxyXG5cdFx0XHRcdG9yVGVzdCA6IG5ldyBSZWdFeHAoICcoXFxcXHwnICsgcHJvY2Vzc1N0cignfFxcXFxzKycsIHRzLmxhbmd1YWdlLm9yLCAnXFxcXHMrJykgKyAnKScsICdpJyApLFxyXG5cdFx0XHRcdG9yU3BsaXQgOiBuZXcgUmVnRXhwKCAnKD86XFxcXHwnICsgcHJvY2Vzc1N0cignfFxcXFxzKyg/OicsIHRzLmxhbmd1YWdlLm9yLCAnKVxcXFxzKycpICsgJyknLCAnZ2knICksXHJcblx0XHRcdFx0aVF1ZXJ5IDogbmV3IFJlZ0V4cCggdmFsLCAnaScgKSxcclxuXHRcdFx0XHRpZ1F1ZXJ5IDogbmV3IFJlZ0V4cCggdmFsLCAnaWcnICksXHJcblx0XHRcdFx0b3BlclRlc3QgOiAvXls8Pl09Py8sXHJcblx0XHRcdFx0Z3RUZXN0ICA6IC8+LyxcclxuXHRcdFx0XHRndGVUZXN0IDogLz49LyxcclxuXHRcdFx0XHRsdFRlc3QgIDogLzwvLFxyXG5cdFx0XHRcdGx0ZVRlc3QgOiAvPD0vLFxyXG5cdFx0XHRcdG5vdFRlc3QgOiAvXlxcIS8sXHJcblx0XHRcdFx0d2lsZE9yVGVzdCA6IC9bXFw/XFwqXFx8XS8sXHJcblx0XHRcdFx0d2lsZFRlc3QgOiAvXFw/XFwqLyxcclxuXHRcdFx0XHRmdXp6eVRlc3QgOiAvXn4vLFxyXG5cdFx0XHRcdGV4YWN0VGVzdCA6IC9bPVxcXCJcXHwhXS9cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBkb24ndCBidWlsZCBmaWx0ZXIgcm93IGlmIGNvbHVtbkZpbHRlcnMgaXMgZmFsc2Ugb3IgYWxsIGNvbHVtbnMgYXJlIHNldCB0byAnZmlsdGVyLWZhbHNlJ1xyXG5cdFx0XHQvLyBzZWUgaXNzdWUgIzE1NlxyXG5cdFx0XHR2YWwgPSBjLiRoZWFkZXJzLmZpbHRlciggJy5maWx0ZXItZmFsc2UsIC5wYXJzZXItZmFsc2UnICkubGVuZ3RoO1xyXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9jb2x1bW5GaWx0ZXJzICE9PSBmYWxzZSAmJiB2YWwgIT09IGMuJGhlYWRlcnMubGVuZ3RoICkge1xyXG5cdFx0XHRcdC8vIGJ1aWxkIGZpbHRlciByb3dcclxuXHRcdFx0XHR0c2YuYnVpbGRSb3coIHRhYmxlLCBjLCB3byApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0eHQgPSAnYWRkUm93cyB1cGRhdGVDZWxsIHVwZGF0ZSB1cGRhdGVSb3dzIHVwZGF0ZUNvbXBsZXRlIGFwcGVuZENhY2hlIGZpbHRlclJlc2V0ICcgK1xyXG5cdFx0XHRcdCdmaWx0ZXJBbmRTb3J0UmVzZXQgZmlsdGVyUmVzZXRTYXZlZCBmaWx0ZXJFbmQgc2VhcmNoICcuc3BsaXQoICcgJyApLmpvaW4oIGMubmFtZXNwYWNlICsgJ2ZpbHRlciAnICk7XHJcblx0XHRcdGMuJHRhYmxlLmJpbmQoIHR4dCwgZnVuY3Rpb24oIGV2ZW50LCBmaWx0ZXIgKSB7XHJcblx0XHRcdFx0dmFsID0gd28uZmlsdGVyX2hpZGVFbXB0eSAmJlxyXG5cdFx0XHRcdFx0JC5pc0VtcHR5T2JqZWN0KCBjLmNhY2hlICkgJiZcclxuXHRcdFx0XHRcdCEoIGMuZGVsYXlJbml0ICYmIGV2ZW50LnR5cGUgPT09ICdhcHBlbmRDYWNoZScgKTtcclxuXHRcdFx0XHQvLyBoaWRlIGZpbHRlciByb3cgdXNpbmcgdGhlICdmaWx0ZXJlZCcgY2xhc3MgbmFtZVxyXG5cdFx0XHRcdGMuJHRhYmxlLmZpbmQoICcuJyArIHRzY3NzLmZpbHRlclJvdyApLnRvZ2dsZUNsYXNzKCB3by5maWx0ZXJfZmlsdGVyZWRSb3csIHZhbCApOyAvLyBmaXhlcyAjNDUwXHJcblx0XHRcdFx0aWYgKCAhLyhzZWFyY2h8ZmlsdGVyKS8udGVzdCggZXZlbnQudHlwZSApICkge1xyXG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHR0c2YuYnVpbGREZWZhdWx0KCB0YWJsZSwgdHJ1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBBZGQgZmlsdGVyQW5kU29ydFJlc2V0IC0gc2VlICMxMzYxXHJcblx0XHRcdFx0aWYgKCBldmVudC50eXBlID09PSAnZmlsdGVyUmVzZXQnIHx8IGV2ZW50LnR5cGUgPT09ICdmaWx0ZXJBbmRTb3J0UmVzZXQnICkge1xyXG5cdFx0XHRcdFx0Yy4kdGFibGUuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyICkuYWRkKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApLnZhbCggJycgKTtcclxuXHRcdFx0XHRcdGlmICggZXZlbnQudHlwZSA9PT0gJ2ZpbHRlckFuZFNvcnRSZXNldCcgKSB7XHJcblx0XHRcdFx0XHRcdHRzLnNvcnRSZXNldCggdGhpcy5jb25maWcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdHRzZi5zZWFyY2hpbmcoIHRhYmxlLCBbXSApO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRzZi5zZWFyY2hpbmcoIHRhYmxlLCBbXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LnR5cGUgPT09ICdmaWx0ZXJSZXNldFNhdmVkJyApIHtcclxuXHRcdFx0XHRcdHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItZmlsdGVycycsICcnICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICggZXZlbnQudHlwZSA9PT0gJ2ZpbHRlckVuZCcgKSB7XHJcblx0XHRcdFx0XHR0c2YuYnVpbGREZWZhdWx0KCB0YWJsZSwgdHJ1ZSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBzZW5kIGZhbHNlIGFyZ3VtZW50IHRvIGZvcmNlIGEgbmV3IHNlYXJjaDsgb3RoZXJ3aXNlIGlmIHRoZSBmaWx0ZXIgaGFzbid0IGNoYW5nZWQsXHJcblx0XHRcdFx0XHQvLyBpdCB3aWxsIHJldHVyblxyXG5cdFx0XHRcdFx0ZmlsdGVyID0gZXZlbnQudHlwZSA9PT0gJ3NlYXJjaCcgPyBmaWx0ZXIgOlxyXG5cdFx0XHRcdFx0XHRldmVudC50eXBlID09PSAndXBkYXRlQ29tcGxldGUnID8gYy4kdGFibGUuZGF0YSggJ2xhc3RTZWFyY2gnICkgOiAnJztcclxuXHRcdFx0XHRcdGlmICggLyh1cGRhdGV8YWRkKS8udGVzdCggZXZlbnQudHlwZSApICYmIGV2ZW50LnR5cGUgIT09ICd1cGRhdGVDb21wbGV0ZScgKSB7XHJcblx0XHRcdFx0XHRcdC8vIGZvcmNlIGEgbmV3IHNlYXJjaCBzaW5jZSBjb250ZW50IGhhcyBjaGFuZ2VkXHJcblx0XHRcdFx0XHRcdGMubGFzdENvbWJpbmVkRmlsdGVyID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XHJcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBmaWx0ZXJGb3JtYXR0ZXJzIGFmdGVyIHVwZGF0ZSAoJiBzbWFsbCBkZWxheSkgLSBGaXhlcyAjMTIzN1xyXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyRm9tYXR0ZXJVcGRhdGUnICk7XHJcblx0XHRcdFx0XHRcdH0sIDEwMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyBwYXNzIHRydWUgKCBza2lwRmlyc3QgKSB0byBwcmV2ZW50IHRoZSB0YWJsZXNvcnRlci5zZXRGaWx0ZXJzIGZ1bmN0aW9uIGZyb20gc2tpcHBpbmcgdGhlIGZpcnN0XHJcblx0XHRcdFx0XHQvLyBpbnB1dCBlbnN1cmVzIGFsbCBpbnB1dHMgYXJlIHVwZGF0ZWQgd2hlbiBhIHNlYXJjaCBpcyB0cmlnZ2VyZWQgb24gdGhlIHRhYmxlXHJcblx0XHRcdFx0XHQvLyAkKCAndGFibGUnICkudHJpZ2dlciggJ3NlYXJjaCcsIFsuLi5dICk7XHJcblx0XHRcdFx0XHR0c2Yuc2VhcmNoaW5nKCB0YWJsZSwgZmlsdGVyLCB0cnVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyByZXNldCBidXR0b24vbGlua1xyXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9yZXNldCApIHtcclxuXHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9yZXNldCBpbnN0YW5jZW9mICQgKSB7XHJcblx0XHRcdFx0XHQvLyByZXNldCBjb250YWlucyBhIGpRdWVyeSBvYmplY3QsIGJpbmQgdG8gaXRcclxuXHRcdFx0XHRcdHdvLmZpbHRlcl9yZXNldC5jbGljayggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyUmVzZXQnICk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAkKCB3by5maWx0ZXJfcmVzZXQgKS5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHQvLyByZXNldCBpcyBhIGpRdWVyeSBzZWxlY3RvciwgdXNlIGV2ZW50IGRlbGVnYXRpb25cclxuXHRcdFx0XHRcdCQoIGRvY3VtZW50IClcclxuXHRcdFx0XHRcdFx0LnVuZGVsZWdhdGUoIHdvLmZpbHRlcl9yZXNldCwgJ2NsaWNrJyArIGMubmFtZXNwYWNlICsgJ2ZpbHRlcicgKVxyXG5cdFx0XHRcdFx0XHQuZGVsZWdhdGUoIHdvLmZpbHRlcl9yZXNldCwgJ2NsaWNrJyArIGMubmFtZXNwYWNlICsgJ2ZpbHRlcicsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgYSByZXNldCBldmVudCwgc28gb3RoZXIgZnVuY3Rpb25zICggZmlsdGVyX2Zvcm1hdHRlciApIGtub3cgd2hlbiB0byByZXNldFxyXG5cdFx0XHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyUmVzZXQnICk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9mdW5jdGlvbnMgKSB7XHJcblx0XHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgYy5jb2x1bW5zOyBjb2x1bW4rKyApIHtcclxuXHRcdFx0XHRcdGZ4biA9IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfZnVuY3Rpb25zLCBjb2x1bW4gKTtcclxuXHRcdFx0XHRcdGlmICggZnhuICkge1xyXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgJ2ZpbHRlci1zZWxlY3QnIGZyb20gaGVhZGVyIG90aGVyd2lzZSB0aGUgb3B0aW9ucyBhZGRlZCBoZXJlIGFyZSByZXBsYWNlZCB3aXRoXHJcblx0XHRcdFx0XHRcdC8vIGFsbCBvcHRpb25zXHJcblx0XHRcdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXS5yZW1vdmVDbGFzcyggJ2ZpbHRlci1zZWxlY3QnICk7XHJcblx0XHRcdFx0XHRcdC8vIGRvbid0IGJ1aWxkIHNlbGVjdCBpZiAnZmlsdGVyLWZhbHNlJyBvciAncGFyc2VyLWZhbHNlJyBzZXRcclxuXHRcdFx0XHRcdFx0bm9TZWxlY3QgPSAhKCAkaGVhZGVyLmhhc0NsYXNzKCAnZmlsdGVyLWZhbHNlJyApIHx8ICRoZWFkZXIuaGFzQ2xhc3MoICdwYXJzZXItZmFsc2UnICkgKTtcclxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9ICcnO1xyXG5cdFx0XHRcdFx0XHRpZiAoIGZ4biA9PT0gdHJ1ZSAmJiBub1NlbGVjdCApIHtcclxuXHRcdFx0XHRcdFx0XHR0c2YuYnVpbGRTZWxlY3QoIHRhYmxlLCBjb2x1bW4gKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIGZ4biA9PT0gJ29iamVjdCcgJiYgbm9TZWxlY3QgKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYWRkIGN1c3RvbSBkcm9wIGRvd24gbGlzdFxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHN0cmluZyBpbiBmeG4gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zICs9IG9wdGlvbnMgPT09ICcnID9cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnPG9wdGlvbiB2YWx1ZT1cIlwiPicgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCAkaGVhZGVyLmRhdGEoICdwbGFjZWhvbGRlcicgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkaGVhZGVyLmF0dHIoICdkYXRhLXBsYWNlaG9sZGVyJyApIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvLmZpbHRlcl9wbGFjZWhvbGRlci5zZWxlY3QgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JydcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCc8L29wdGlvbj4nIDogJyc7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IHN0cmluZztcclxuXHRcdFx0XHRcdFx0XHRcdFx0dHh0ID0gc3RyaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0cmluZy5pbmRleE9mKCB3by5maWx0ZXJfc2VsZWN0U291cmNlU2VwYXJhdG9yICkgPj0gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSBzdHJpbmcuc3BsaXQoIHdvLmZpbHRlcl9zZWxlY3RTb3VyY2VTZXBhcmF0b3IgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eHQgPSB2YWxbMV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gdmFsWzBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMgKz0gJzxvcHRpb24gJyArXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eHQgPT09IHZhbCA/ICcnIDogJ2RhdGEtZnVuY3Rpb24tbmFtZT1cIicgKyBzdHJpbmcgKyAnXCIgJyApICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQndmFsdWU9XCInICsgdmFsICsgJ1wiPicgKyB0eHQgKyAnPC9vcHRpb24+JztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Yy4kdGFibGVcclxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCAndGhlYWQnIClcclxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCAnc2VsZWN0LicgKyB0c2Nzcy5maWx0ZXIgKyAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICdcIl0nIClcclxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIG9wdGlvbnMgKTtcclxuXHRcdFx0XHRcdFx0XHR0eHQgPSB3by5maWx0ZXJfc2VsZWN0U291cmNlO1xyXG5cdFx0XHRcdFx0XHRcdGZ4biA9IHR5cGVvZiB0eHQgPT09ICdmdW5jdGlvbicgPyB0cnVlIDogdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHR4dCwgY29sdW1uICk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBmeG4gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyB1cGRhdGluZyBzbyB0aGUgZXh0cmEgb3B0aW9ucyBhcmUgYXBwZW5kZWRcclxuXHRcdFx0XHRcdFx0XHRcdHRzZi5idWlsZFNlbGVjdCggYy50YWJsZSwgY29sdW1uLCAnJywgdHJ1ZSwgJGhlYWRlci5oYXNDbGFzcyggd28uZmlsdGVyX29ubHlBdmFpbCApICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIG5vdCByZWFsbHkgdXBkYXRpbmcsIGJ1dCBpZiB0aGUgY29sdW1uIGhhcyBib3RoIHRoZSAnZmlsdGVyLXNlbGVjdCcgY2xhc3MgJlxyXG5cdFx0XHQvLyBmaWx0ZXJfZnVuY3Rpb25zIHNldCB0byB0cnVlLCBpdCB3b3VsZCBhcHBlbmQgdGhlIHNhbWUgb3B0aW9ucyB0d2ljZS5cclxuXHRcdFx0dHNmLmJ1aWxkRGVmYXVsdCggdGFibGUsIHRydWUgKTtcclxuXHJcblx0XHRcdHRzZi5iaW5kU2VhcmNoKCB0YWJsZSwgYy4kdGFibGUuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyICksIHRydWUgKTtcclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfZXh0ZXJuYWwgKSB7XHJcblx0XHRcdFx0dHNmLmJpbmRTZWFyY2goIHRhYmxlLCB3by5maWx0ZXJfZXh0ZXJuYWwgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfaGlkZUZpbHRlcnMgKSB7XHJcblx0XHRcdFx0dHNmLmhpZGVGaWx0ZXJzKCBjICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNob3cgcHJvY2Vzc2luZyBpY29uXHJcblx0XHRcdGlmICggYy5zaG93UHJvY2Vzc2luZyApIHtcclxuXHRcdFx0XHR0eHQgPSAnZmlsdGVyU3RhcnQgZmlsdGVyRW5kICcuc3BsaXQoICcgJyApLmpvaW4oIGMubmFtZXNwYWNlICsgJ2ZpbHRlci1zcCAnICk7XHJcblx0XHRcdFx0Yy4kdGFibGVcclxuXHRcdFx0XHRcdC51bmJpbmQoIHR4dC5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApIClcclxuXHRcdFx0XHRcdC5iaW5kKCB0eHQsIGZ1bmN0aW9uKCBldmVudCwgY29sdW1ucyApIHtcclxuXHRcdFx0XHRcdC8vIG9ubHkgYWRkIHByb2Nlc3NpbmcgdG8gY2VydGFpbiBjb2x1bW5zIHRvIGFsbCBjb2x1bW5zXHJcblx0XHRcdFx0XHQkaGVhZGVyID0gKCBjb2x1bW5zICkgP1xyXG5cdFx0XHRcdFx0XHRjLiR0YWJsZVxyXG5cdFx0XHRcdFx0XHRcdC5maW5kKCAnLicgKyB0c2Nzcy5oZWFkZXIgKVxyXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoICdbZGF0YS1jb2x1bW5dJyApXHJcblx0XHRcdFx0XHRcdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sdW1uc1sgJCggdGhpcyApLmRhdGEoICdjb2x1bW4nICkgXSAhPT0gJyc7XHJcblx0XHRcdFx0XHRcdFx0fSkgOiAnJztcclxuXHRcdFx0XHRcdHRzLmlzUHJvY2Vzc2luZyggdGFibGUsIGV2ZW50LnR5cGUgPT09ICdmaWx0ZXJTdGFydCcsIGNvbHVtbnMgPyAkaGVhZGVyIDogJycgKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2V0IGZpbHRlcmVkIHJvd3MgY291bnQgKCBpbnRpYWxseSB1bmZpbHRlcmVkIClcclxuXHRcdFx0Yy5maWx0ZXJlZFJvd3MgPSBjLnRvdGFsUm93cztcclxuXHJcblx0XHRcdC8vIGFkZCBkZWZhdWx0IHZhbHVlc1xyXG5cdFx0XHR0eHQgPSAndGFibGVzb3J0ZXItaW5pdGlhbGl6ZWQgcGFnZXJCZWZvcmVJbml0aWFsaXplZCAnLnNwbGl0KCAnICcgKS5qb2luKCBjLm5hbWVzcGFjZSArICdmaWx0ZXIgJyApO1xyXG5cdFx0XHRjLiR0YWJsZVxyXG5cdFx0XHQudW5iaW5kKCB0eHQucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKSApXHJcblx0XHRcdC5iaW5kKCB0eHQsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRzZi5jb21wbGV0ZUluaXQoIHRoaXMgKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdC8vIGlmIGZpbHRlciB3aWRnZXQgaXMgYWRkZWQgYWZ0ZXIgcGFnZXIgaGFzIGluaXRpYWxpemVkOyB0aGVuIHNldCBmaWx0ZXIgaW5pdCBmbGFnXHJcblx0XHRcdGlmICggYy5wYWdlciAmJiBjLnBhZ2VyLmluaXRpYWxpemVkICYmICF3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XHJcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJGb21hdHRlclVwZGF0ZScgKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHRzZi5maWx0ZXJJbml0Q29tcGxldGUoIGMgKTtcclxuXHRcdFx0XHR9LCAxMDAgKTtcclxuXHRcdFx0fSBlbHNlIGlmICggIXdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcclxuXHRcdFx0XHR0c2YuY29tcGxldGVJbml0KCB0YWJsZSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Y29tcGxldGVJbml0OiBmdW5jdGlvbiggdGFibGUgKSB7XHJcblx0XHRcdC8vIHJlZGVmaW5lICdjJyAmICd3bycgc28gdGhleSB1cGRhdGUgcHJvcGVybHkgaW5zaWRlIHRoaXMgY2FsbGJhY2tcclxuXHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0ZmlsdGVycyA9IHRzZi5zZXREZWZhdWx0cyggdGFibGUsIGMsIHdvICkgfHwgW107XHJcblx0XHRcdGlmICggZmlsdGVycy5sZW5ndGggKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCBkZWxheUluaXQgZnJvbSB0cmlnZ2VyaW5nIGEgY2FjaGUgYnVpbGQgaWYgZmlsdGVycyBhcmUgZW1wdHlcclxuXHRcdFx0XHRpZiAoICEoIGMuZGVsYXlJbml0ICYmIGZpbHRlcnMuam9pbiggJycgKSA9PT0gJycgKSApIHtcclxuXHRcdFx0XHRcdHRzLnNldEZpbHRlcnMoIHRhYmxlLCBmaWx0ZXJzLCB0cnVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyRm9tYXR0ZXJVcGRhdGUnICk7XHJcblx0XHRcdC8vIHRyaWdnZXIgaW5pdCBhZnRlciBzZXRUaW1lb3V0IHRvIHByZXZlbnQgbXVsdGlwbGUgZmlsdGVyU3RhcnQvRW5kL0luaXQgdHJpZ2dlcnNcclxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2luaXRpYWxpemVkICkge1xyXG5cdFx0XHRcdFx0dHNmLmZpbHRlckluaXRDb21wbGV0ZSggYyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTAwICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vICRjZWxsIHBhcmFtZXRlciwgYnV0IG5vdCB0aGUgY29uZmlnLCBpcyBwYXNzZWQgdG8gdGhlIGZpbHRlcl9mb3JtYXR0ZXJzLFxyXG5cdFx0Ly8gc28gd2UgaGF2ZSB0byB3b3JrIHdpdGggaXQgaW5zdGVhZFxyXG5cdFx0Zm9ybWF0dGVyVXBkYXRlZDogZnVuY3Rpb24oICRjZWxsLCBjb2x1bW4gKSB7XHJcblx0XHRcdC8vIHByZXZlbnQgZXJyb3IgaWYgJGNlbGwgaXMgdW5kZWZpbmVkIC0gc2VlICMxMDU2XHJcblx0XHRcdHZhciAkdGFibGUgPSAkY2VsbCAmJiAkY2VsbC5jbG9zZXN0KCAndGFibGUnICk7XHJcblx0XHRcdHZhciBjb25maWcgPSAkdGFibGUubGVuZ3RoICYmICR0YWJsZVswXS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjb25maWcgJiYgY29uZmlnLndpZGdldE9wdGlvbnM7XHJcblx0XHRcdGlmICggd28gJiYgIXdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcclxuXHRcdFx0XHQvLyBhZGQgdXBkYXRlcyBieSBjb2x1bW4gc2luY2UgdGhpcyBmdW5jdGlvblxyXG5cdFx0XHRcdC8vIG1heSBiZSBjYWxsZWQgbnVtZXJvdXMgdGltZXMgYmVmb3JlIGluaXRpYWxpemF0aW9uXHJcblx0XHRcdFx0d28uZmlsdGVyX2Zvcm1hdHRlckluaXRbIGNvbHVtbiBdID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGZpbHRlckluaXRDb21wbGV0ZTogZnVuY3Rpb24oIGMgKSB7XHJcblx0XHRcdHZhciBpbmR4LCBsZW4sXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0Y291bnQgPSAwLFxyXG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0d28uZmlsdGVyX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBsYXN0U2VhcmNoIC0gaXQgZ2V0cyBjbGVhcmVkIG9mdGVuXHJcblx0XHRcdFx0XHRjLmxhc3RTZWFyY2ggPSBjLiR0YWJsZS5kYXRhKCAnbGFzdFNlYXJjaCcgKTtcclxuXHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVySW5pdCcsIGMgKTtcclxuXHRcdFx0XHRcdHRzZi5maW5kUm93cyggYy50YWJsZSwgYy5sYXN0U2VhcmNoIHx8IFtdICk7XHJcblx0XHRcdFx0XHRpZiAodHMuZGVidWcoYywgJ2ZpbHRlcicpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdGaWx0ZXIgPj4gV2lkZ2V0IGluaXRpYWxpemVkJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0aWYgKCAkLmlzRW1wdHlPYmplY3QoIHdvLmZpbHRlcl9mb3JtYXR0ZXIgKSApIHtcclxuXHRcdFx0XHRjb21wbGV0ZWQoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZW4gPSB3by5maWx0ZXJfZm9ybWF0dGVySW5pdC5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdGlmICggd28uZmlsdGVyX2Zvcm1hdHRlckluaXRbIGluZHggXSA9PT0gMSApIHtcclxuXHRcdFx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB3by5maWx0ZXJfaW5pdFRpbWVyICk7XHJcblx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2luaXRpYWxpemVkICYmIGNvdW50ID09PSB3by5maWx0ZXJfZm9ybWF0dGVyQ291bnQgKSB7XHJcblx0XHRcdFx0XHQvLyBmaWx0ZXIgd2lkZ2V0IGluaXRpYWxpemVkXHJcblx0XHRcdFx0XHRjb21wbGV0ZWQoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhd28uZmlsdGVyX2luaXRpYWxpemVkICkge1xyXG5cdFx0XHRcdFx0Ly8gZmFsbCBiYWNrIGluIGNhc2UgYSBmaWx0ZXJfZm9ybWF0dGVyIGRvZXNuJ3QgY2FsbFxyXG5cdFx0XHRcdFx0Ly8gJC50YWJsZXNvcnRlci5maWx0ZXIuZm9ybWF0dGVyVXBkYXRlZCggJGNlbGwsIGNvbHVtbiApLCBhbmQgdGhlIGNvdW50IGlzIG9mZlxyXG5cdFx0XHRcdFx0d28uZmlsdGVyX2luaXRUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjb21wbGV0ZWQoKTtcclxuXHRcdFx0XHRcdH0sIDUwMCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8vIGVuY29kZSBvciBkZWNvZGUgZmlsdGVycyBmb3Igc3RvcmFnZTsgc2VlICMxMDI2XHJcblx0XHRwcm9jZXNzRmlsdGVyczogZnVuY3Rpb24oIGZpbHRlcnMsIGVuY29kZSApIHtcclxuXHRcdFx0dmFyIGluZHgsXHJcblx0XHRcdFx0Ly8gZml4ZXMgIzEyMzc7IHByZXZpb3VzbHkgcmV0dXJuaW5nIGFuIGVuY29kZWQgXCJmaWx0ZXJzXCIgdmFsdWVcclxuXHRcdFx0XHRyZXN1bHQgPSBbXSxcclxuXHRcdFx0XHRtb2RlID0gZW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50IDogZGVjb2RlVVJJQ29tcG9uZW50LFxyXG5cdFx0XHRcdGxlbiA9IGZpbHRlcnMubGVuZ3RoO1xyXG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xyXG5cdFx0XHRcdGlmICggZmlsdGVyc1sgaW5keCBdICkge1xyXG5cdFx0XHRcdFx0cmVzdWx0WyBpbmR4IF0gPSBtb2RlKCBmaWx0ZXJzWyBpbmR4IF0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH0sXHJcblx0XHRzZXREZWZhdWx0czogZnVuY3Rpb24oIHRhYmxlLCBjLCB3byApIHtcclxuXHRcdFx0dmFyIGlzQXJyYXksIHNhdmVkLCBpbmR4LCBjb2wsICRmaWx0ZXJzLFxyXG5cdFx0XHRcdC8vIGdldCBjdXJyZW50ICggZGVmYXVsdCApIGZpbHRlcnNcclxuXHRcdFx0XHRmaWx0ZXJzID0gdHMuZ2V0RmlsdGVycyggdGFibGUgKSB8fCBbXTtcclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfc2F2ZUZpbHRlcnMgJiYgdHMuc3RvcmFnZSApIHtcclxuXHRcdFx0XHRzYXZlZCA9IHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItZmlsdGVycycgKSB8fCBbXTtcclxuXHRcdFx0XHRpc0FycmF5ID0gJC5pc0FycmF5KCBzYXZlZCApO1xyXG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBub3QganVzdCBnZXR0aW5nIGFuIGVtcHR5IGFycmF5XHJcblx0XHRcdFx0aWYgKCAhKCBpc0FycmF5ICYmIHNhdmVkLmpvaW4oICcnICkgPT09ICcnIHx8ICFpc0FycmF5ICkgKSB7XHJcblx0XHRcdFx0XHRmaWx0ZXJzID0gdHNmLnByb2Nlc3NGaWx0ZXJzKCBzYXZlZCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpZiBubyBmaWx0ZXJzIHNhdmVkLCB0aGVuIGNoZWNrIGRlZmF1bHQgc2V0dGluZ3NcclxuXHRcdFx0aWYgKCBmaWx0ZXJzLmpvaW4oICcnICkgPT09ICcnICkge1xyXG5cdFx0XHRcdC8vIGFsbG93IGFkZGluZyBkZWZhdWx0IHNldHRpbmcgdG8gZXh0ZXJuYWwgZmlsdGVyc1xyXG5cdFx0XHRcdCRmaWx0ZXJzID0gYy4kaGVhZGVycy5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzIClcclxuXHRcdFx0XHRcdC5maWx0ZXIoICdbJyArIHdvLmZpbHRlcl9kZWZhdWx0QXR0cmliICsgJ10nICk7XHJcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPD0gYy5jb2x1bW5zOyBpbmR4KysgKSB7XHJcblx0XHRcdFx0XHQvLyBpbmNsdWRlIGRhdGEtY29sdW1uPSdhbGwnIGV4dGVybmFsIGZpbHRlcnNcclxuXHRcdFx0XHRcdGNvbCA9IGluZHggPT09IGMuY29sdW1ucyA/ICdhbGwnIDogaW5keDtcclxuXHRcdFx0XHRcdGZpbHRlcnNbIGluZHggXSA9ICRmaWx0ZXJzXHJcblx0XHRcdFx0XHRcdC5maWx0ZXIoICdbZGF0YS1jb2x1bW49XCInICsgY29sICsgJ1wiXScgKVxyXG5cdFx0XHRcdFx0XHQuYXR0ciggd28uZmlsdGVyX2RlZmF1bHRBdHRyaWIgKSB8fCBmaWx0ZXJzW2luZHhdIHx8ICcnO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjLiR0YWJsZS5kYXRhKCAnbGFzdFNlYXJjaCcsIGZpbHRlcnMgKTtcclxuXHRcdFx0cmV0dXJuIGZpbHRlcnM7XHJcblx0XHR9LFxyXG5cdFx0cGFyc2VGaWx0ZXI6IGZ1bmN0aW9uKCBjLCBmaWx0ZXIsIGRhdGEsIHBhcnNlZCApIHtcclxuXHRcdFx0cmV0dXJuIHBhcnNlZCB8fCBkYXRhLnBhcnNlZFsgZGF0YS5pbmRleCBdID9cclxuXHRcdFx0XHRjLnBhcnNlcnNbIGRhdGEuaW5kZXggXS5mb3JtYXQoIGZpbHRlciwgYy50YWJsZSwgW10sIGRhdGEuaW5kZXggKSA6XHJcblx0XHRcdFx0ZmlsdGVyO1xyXG5cdFx0fSxcclxuXHRcdGJ1aWxkUm93OiBmdW5jdGlvbiggdGFibGUsIGMsIHdvICkge1xyXG5cdFx0XHR2YXIgJGZpbHRlciwgY29sLCBjb2x1bW4sICRoZWFkZXIsIG1ha2VTZWxlY3QsIGRpc2FibGVkLCBuYW1lLCBmZnhuLCB0bXAsXHJcblx0XHRcdFx0Ly8gYy5jb2x1bW5zIGRlZmluZWQgaW4gY29tcHV0ZVRoSW5kZXhlcygpXHJcblx0XHRcdFx0Y2VsbEZpbHRlciA9IHdvLmZpbHRlcl9jZWxsRmlsdGVyLFxyXG5cdFx0XHRcdGNvbHVtbnMgPSBjLmNvbHVtbnMsXHJcblx0XHRcdFx0YXJyeSA9ICQuaXNBcnJheSggY2VsbEZpbHRlciApLFxyXG5cdFx0XHRcdGJ1aWxkRmlsdGVyID0gJzx0ciByb2xlPVwic2VhcmNoXCIgY2xhc3M9XCInICsgdHNjc3MuZmlsdGVyUm93ICsgJyAnICsgYy5jc3NJZ25vcmVSb3cgKyAnXCI+JztcclxuXHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgY29sdW1uczsgY29sdW1uKysgKSB7XHJcblx0XHRcdFx0aWYgKCBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXS5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHQvLyBhY2NvdW50IGZvciBlbnRpcmUgY29sdW1uIHNldCB3aXRoIGNvbHNwYW4uIFNlZSAjMTA0N1xyXG5cdFx0XHRcdFx0dG1wID0gYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF0gJiYgYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF1bMF0uY29sU3BhbiB8fCAwO1xyXG5cdFx0XHRcdFx0aWYgKCB0bXAgPiAxICkge1xyXG5cdFx0XHRcdFx0XHRidWlsZEZpbHRlciArPSAnPHRkIGRhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICctJyArICggY29sdW1uICsgdG1wIC0gMSApICsgJ1wiIGNvbHNwYW49XCInICsgdG1wICsgJ1wiJztcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyICs9ICc8dGQgZGF0YS1jb2x1bW49XCInICsgY29sdW1uICsgJ1wiJztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggYXJyeSApIHtcclxuXHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgKz0gKCBjZWxsRmlsdGVyWyBjb2x1bW4gXSA/ICcgY2xhc3M9XCInICsgY2VsbEZpbHRlclsgY29sdW1uIF0gKyAnXCInIDogJycgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyICs9ICggY2VsbEZpbHRlciAhPT0gJycgPyAnIGNsYXNzPVwiJyArIGNlbGxGaWx0ZXIgKyAnXCInIDogJycgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJ1aWxkRmlsdGVyICs9ICc+PC90ZD4nO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjLiRmaWx0ZXJzID0gJCggYnVpbGRGaWx0ZXIgKz0gJzwvdHI+JyApXHJcblx0XHRcdFx0LmFwcGVuZFRvKCBjLiR0YWJsZS5jaGlsZHJlbiggJ3RoZWFkJyApLmVxKCAwICkgKVxyXG5cdFx0XHRcdC5jaGlsZHJlbiggJ3RkJyApO1xyXG5cdFx0XHQvLyBidWlsZCBlYWNoIGZpbHRlciBpbnB1dFxyXG5cdFx0XHRmb3IgKCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKyApIHtcclxuXHRcdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdC8vIGFzc3VtaW5nIGxhc3QgY2VsbCBvZiBhIGNvbHVtbiBpcyB0aGUgbWFpbiBjb2x1bW5cclxuXHRcdFx0XHQkaGVhZGVyID0gYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF07XHJcblx0XHRcdFx0aWYgKCAkaGVhZGVyICYmICRoZWFkZXIubGVuZ3RoICkge1xyXG5cdFx0XHRcdFx0Ly8gJGZpbHRlciA9IGMuJGZpbHRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICdcIl0nICk7XHJcblx0XHRcdFx0XHQkZmlsdGVyID0gdHNmLmdldENvbHVtbkVsbSggYywgYy4kZmlsdGVycywgY29sdW1uICk7XHJcblx0XHRcdFx0XHRmZnhuID0gdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9mdW5jdGlvbnMsIGNvbHVtbiApO1xyXG5cdFx0XHRcdFx0bWFrZVNlbGVjdCA9ICggd28uZmlsdGVyX2Z1bmN0aW9ucyAmJiBmZnhuICYmIHR5cGVvZiBmZnhuICE9PSAnZnVuY3Rpb24nICkgfHxcclxuXHRcdFx0XHRcdFx0JGhlYWRlci5oYXNDbGFzcyggJ2ZpbHRlci1zZWxlY3QnICk7XHJcblx0XHRcdFx0XHQvLyBnZXQgZGF0YSBmcm9tIGpRdWVyeSBkYXRhLCBtZXRhZGF0YSwgaGVhZGVycyBvcHRpb24gb3IgaGVhZGVyIGNsYXNzIG5hbWVcclxuXHRcdFx0XHRcdGNvbCA9IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCBjLmhlYWRlcnMsIGNvbHVtbiApO1xyXG5cdFx0XHRcdFx0ZGlzYWJsZWQgPSB0cy5nZXREYXRhKCAkaGVhZGVyWzBdLCBjb2wsICdmaWx0ZXInICkgPT09ICdmYWxzZScgfHxcclxuXHRcdFx0XHRcdFx0dHMuZ2V0RGF0YSggJGhlYWRlclswXSwgY29sLCAncGFyc2VyJyApID09PSAnZmFsc2UnO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWFrZVNlbGVjdCApIHtcclxuXHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgPSAkKCAnPHNlbGVjdD4nICkuYXBwZW5kVG8oICRmaWx0ZXIgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGZmeG4gPSB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2Zvcm1hdHRlciwgY29sdW1uICk7XHJcblx0XHRcdFx0XHRcdGlmICggZmZ4biApIHtcclxuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfZm9ybWF0dGVyQ291bnQrKztcclxuXHRcdFx0XHRcdFx0XHRidWlsZEZpbHRlciA9IGZmeG4oICRmaWx0ZXIsIGNvbHVtbiApO1xyXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGVsZW1lbnQgcmV0dXJuZWQsIHNvIGxldHMgZ28gZmluZCBpdFxyXG5cdFx0XHRcdFx0XHRcdGlmICggYnVpbGRGaWx0ZXIgJiYgYnVpbGRGaWx0ZXIubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgPSAkZmlsdGVyLmNoaWxkcmVuKCAnaW5wdXQnICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdC8vIGVsZW1lbnQgbm90IGluIERPTSwgc28gbGV0cyBhdHRhY2ggaXRcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGJ1aWxkRmlsdGVyICYmICggYnVpbGRGaWx0ZXIucGFyZW50KCkubGVuZ3RoID09PSAwIHx8XHJcblx0XHRcdFx0XHRcdFx0XHQoIGJ1aWxkRmlsdGVyLnBhcmVudCgpLmxlbmd0aCAmJiBidWlsZEZpbHRlci5wYXJlbnQoKVswXSAhPT0gJGZpbHRlclswXSApICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQkZmlsdGVyLmFwcGVuZCggYnVpbGRGaWx0ZXIgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgPSAkKCAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIj4nICkuYXBwZW5kVG8oICRmaWx0ZXIgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAoIGJ1aWxkRmlsdGVyICkge1xyXG5cdFx0XHRcdFx0XHRcdHRtcCA9ICRoZWFkZXIuZGF0YSggJ3BsYWNlaG9sZGVyJyApIHx8XHJcblx0XHRcdFx0XHRcdFx0XHQkaGVhZGVyLmF0dHIoICdkYXRhLXBsYWNlaG9sZGVyJyApIHx8XHJcblx0XHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfcGxhY2Vob2xkZXIuc2VhcmNoIHx8ICcnO1xyXG5cdFx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyLmF0dHIoICdwbGFjZWhvbGRlcicsIHRtcCApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIGJ1aWxkRmlsdGVyICkge1xyXG5cdFx0XHRcdFx0XHQvLyBhZGQgZmlsdGVyIGNsYXNzIG5hbWVcclxuXHRcdFx0XHRcdFx0bmFtZSA9ICggJC5pc0FycmF5KCB3by5maWx0ZXJfY3NzRmlsdGVyICkgP1xyXG5cdFx0XHRcdFx0XHRcdCggdHlwZW9mIHdvLmZpbHRlcl9jc3NGaWx0ZXJbY29sdW1uXSAhPT0gJ3VuZGVmaW5lZCcgPyB3by5maWx0ZXJfY3NzRmlsdGVyW2NvbHVtbl0gfHwgJycgOiAnJyApIDpcclxuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfY3NzRmlsdGVyICkgfHwgJyc7XHJcblx0XHRcdFx0XHRcdC8vIGNvcHkgZGF0YS1jb2x1bW4gZnJvbSB0YWJsZSBjZWxsIChpdCB3aWxsIGluY2x1ZGUgY29sc3BhbilcclxuXHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIuYWRkQ2xhc3MoIHRzY3NzLmZpbHRlciArICcgJyArIG5hbWUgKTtcclxuXHRcdFx0XHRcdFx0bmFtZSA9IHdvLmZpbHRlcl9maWx0ZXJMYWJlbDtcclxuXHRcdFx0XHRcdFx0dG1wID0gbmFtZS5tYXRjaCgve3soW159XSs/KX19L2cpO1xyXG5cdFx0XHRcdFx0XHRpZiAoIXRtcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRtcCA9IFsgJ3t7bGFiZWx9fScgXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQkLmVhY2godG1wLCBmdW5jdGlvbihpbmR4LCBhdHRyKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChhdHRyLCAnZycpLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9ICRoZWFkZXIuYXR0cignZGF0YS0nICsgYXR0ci5yZXBsYWNlKC97e3x9fS9nLCAnJykpLFxyXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICRoZWFkZXIudGV4dCgpIDogZGF0YTtcclxuXHRcdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCByZWdleCwgJC50cmltKCB0ZXh0ICkgKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyLmF0dHIoe1xyXG5cdFx0XHRcdFx0XHRcdCdkYXRhLWNvbHVtbic6ICRmaWx0ZXIuYXR0ciggJ2RhdGEtY29sdW1uJyApLFxyXG5cdFx0XHRcdFx0XHRcdCdhcmlhLWxhYmVsJzogbmFtZVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aWYgKCBkaXNhYmxlZCApIHtcclxuXHRcdFx0XHRcdFx0XHRidWlsZEZpbHRlci5hdHRyKCAncGxhY2Vob2xkZXInLCAnJyApLmFkZENsYXNzKCB0c2Nzcy5maWx0ZXJEaXNhYmxlZCApWzBdLmRpc2FibGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGJpbmRTZWFyY2g6IGZ1bmN0aW9uKCB0YWJsZSwgJGVsLCBpbnRlcm5hbCApIHtcclxuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWzBdO1xyXG5cdFx0XHQkZWwgPSAkKCAkZWwgKTsgLy8gYWxsb3cgcGFzc2luZyBhIHNlbGVjdG9yIHN0cmluZ1xyXG5cdFx0XHRpZiAoICEkZWwubGVuZ3RoICkgeyByZXR1cm47IH1cclxuXHRcdFx0dmFyIHRtcCxcclxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxyXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxyXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ2ZpbHRlcicsXHJcblx0XHRcdFx0JGV4dCA9IHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzO1xyXG5cdFx0XHRpZiAoIGludGVybmFsICE9PSB0cnVlICkge1xyXG5cdFx0XHRcdC8vIHNhdmUgYW55TWF0Y2ggZWxlbWVudFxyXG5cdFx0XHRcdHRtcCA9IHdvLmZpbHRlcl9hbnlDb2x1bW5TZWxlY3RvciArICcsJyArIHdvLmZpbHRlcl9tdWx0aXBsZUNvbHVtblNlbGVjdG9yO1xyXG5cdFx0XHRcdHdvLmZpbHRlcl8kYW55TWF0Y2ggPSAkZWwuZmlsdGVyKCB0bXAgKTtcclxuXHRcdFx0XHRpZiAoICRleHQgJiYgJGV4dC5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHR3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyA9IHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzLmFkZCggJGVsICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzID0gJGVsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB1cGRhdGUgdmFsdWVzICggZXh0ZXJuYWwgZmlsdGVycyBhZGRlZCBhZnRlciB0YWJsZSBpbml0aWFsaXphdGlvbiApXHJcblx0XHRcdFx0dHMuc2V0RmlsdGVycyggdGFibGUsIGMuJHRhYmxlLmRhdGEoICdsYXN0U2VhcmNoJyApIHx8IFtdLCBpbnRlcm5hbCA9PT0gZmFsc2UgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB1bmJpbmQgZXZlbnRzXHJcblx0XHRcdHRtcCA9ICggJ2tleXByZXNzIGtleXVwIGtleWRvd24gc2VhcmNoIGNoYW5nZSBpbnB1dCAnLnNwbGl0KCAnICcgKS5qb2luKCBuYW1lc3BhY2UgKyAnICcgKSApO1xyXG5cdFx0XHQkZWxcclxuXHRcdFx0Ly8gdXNlIGRhdGEgYXR0cmlidXRlIGluc3RlYWQgb2YgalF1ZXJ5IGRhdGEgc2luY2UgdGhlIGhlYWQgaXMgY2xvbmVkIHdpdGhvdXQgaW5jbHVkaW5nXHJcblx0XHRcdC8vIHRoZSBkYXRhL2JpbmRpbmdcclxuXHRcdFx0LmF0dHIoICdkYXRhLWxhc3RTZWFyY2hUaW1lJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgKVxyXG5cdFx0XHQudW5iaW5kKCB0bXAucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKSApXHJcblx0XHRcdC5iaW5kKCAna2V5ZG93bicgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdFx0XHRpZiAoIGV2ZW50LndoaWNoID09PSB0c2tleUNvZGVzLmVzY2FwZSAmJiAhdGFibGUuY29uZmlnLndpZGdldE9wdGlvbnMuZmlsdGVyX3Jlc2V0T25Fc2MgKSB7XHJcblx0XHRcdFx0XHQvLyBwcmV2ZW50IGtleXByZXNzIGV2ZW50XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuYmluZCggJ2tleXVwJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdFx0XHRcdHdvID0gdGFibGUuY29uZmlnLndpZGdldE9wdGlvbnM7IC8vIG1ha2Ugc3VyZSBcIndvXCIgaXNuJ3QgY2FjaGVkXHJcblx0XHRcdFx0dmFyIGNvbHVtbiA9IHBhcnNlSW50KCAkKCB0aGlzICkuYXR0ciggJ2RhdGEtY29sdW1uJyApLCAxMCApLFxyXG5cdFx0XHRcdFx0bGl2ZVNlYXJjaCA9IHR5cGVvZiB3by5maWx0ZXJfbGl2ZVNlYXJjaCA9PT0gJ2Jvb2xlYW4nID8gd28uZmlsdGVyX2xpdmVTZWFyY2ggOlxyXG5cdFx0XHRcdFx0XHR0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2xpdmVTZWFyY2gsIGNvbHVtbiApO1xyXG5cdFx0XHRcdGlmICggdHlwZW9mIGxpdmVTZWFyY2ggPT09ICd1bmRlZmluZWQnICkge1xyXG5cdFx0XHRcdFx0bGl2ZVNlYXJjaCA9IHdvLmZpbHRlcl9saXZlU2VhcmNoLmZhbGxiYWNrIHx8IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQkKCB0aGlzICkuYXR0ciggJ2RhdGEtbGFzdFNlYXJjaFRpbWUnLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSApO1xyXG5cdFx0XHRcdC8vIGVtdWxhdGUgd2hhdCB3ZWJraXQgZG9lcy4uLi4gZXNjYXBlIGNsZWFycyB0aGUgZmlsdGVyXHJcblx0XHRcdFx0aWYgKCBldmVudC53aGljaCA9PT0gdHNrZXlDb2Rlcy5lc2NhcGUgKSB7XHJcblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdG8gcmVzdG9yZSB0aGUgbGFzdCB2YWx1ZSBvbiBlc2NhcGVcclxuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB3by5maWx0ZXJfcmVzZXRPbkVzYyA/ICcnIDogYy5sYXN0U2VhcmNoW2NvbHVtbl07XHJcblx0XHRcdFx0XHQvLyBkb24ndCByZXR1cm4gaWYgdGhlIHNlYXJjaCB2YWx1ZSBpcyBlbXB0eSAoIGFsbCByb3dzIG5lZWQgdG8gYmUgcmV2ZWFsZWQgKVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudmFsdWUgIT09ICcnICYmIChcclxuXHRcdFx0XHRcdC8vIGxpdmVTZWFyY2ggY2FuIGNvbnRhaW4gYSBtaW4gdmFsdWUgbGVuZ3RoOyBpZ25vcmUgYXJyb3cgYW5kIG1ldGEga2V5cywgYnV0IGFsbG93IGJhY2tzcGFjZVxyXG5cdFx0XHRcdFx0KCB0eXBlb2YgbGl2ZVNlYXJjaCA9PT0gJ251bWJlcicgJiYgdGhpcy52YWx1ZS5sZW5ndGggPCBsaXZlU2VhcmNoICkgfHxcclxuXHRcdFx0XHRcdC8vIGxldCByZXR1cm4gJiBiYWNrc3BhY2UgY29udGludWUgb24sIGJ1dCBpZ25vcmUgYXJyb3dzICYgbm9uLXZhbGlkIGNoYXJhY3RlcnNcclxuXHRcdFx0XHRcdCggZXZlbnQud2hpY2ggIT09IHRza2V5Q29kZXMuZW50ZXIgJiYgZXZlbnQud2hpY2ggIT09IHRza2V5Q29kZXMuYmFja1NwYWNlICYmXHJcblx0XHRcdFx0XHRcdCggZXZlbnQud2hpY2ggPCB0c2tleUNvZGVzLnNwYWNlIHx8ICggZXZlbnQud2hpY2ggPj0gdHNrZXlDb2Rlcy5sZWZ0ICYmIGV2ZW50LndoaWNoIDw9IHRza2V5Q29kZXMuZG93biApICkgKSApICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0Ly8gbGl2ZSBzZWFyY2hcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaXZlU2VhcmNoID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdGlmICggdGhpcy52YWx1ZSAhPT0gJycgJiYgZXZlbnQud2hpY2ggIT09IHRza2V5Q29kZXMuZW50ZXIgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gY2hhbmdlIGV2ZW50ID0gbm8gZGVsYXk7IGxhc3QgdHJ1ZSBmbGFnIHRlbGxzIGdldEZpbHRlcnMgdG8gc2tpcCBuZXdlc3QgdGltZWQgaW5wdXRcclxuXHRcdFx0XHR0c2Yuc2VhcmNoaW5nKCB0YWJsZSwgdHJ1ZSwgdHJ1ZSwgY29sdW1uICk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIGluY2x1ZGUgY2hhbmdlIGZvciBzZWxlY3QgLSBmaXhlcyAjNDczXHJcblx0XHRcdC5iaW5kKCAnc2VhcmNoIGNoYW5nZSBrZXlwcmVzcyBpbnB1dCBibHVyICcuc3BsaXQoICcgJyApLmpvaW4oIG5hbWVzcGFjZSArICcgJyApLCBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0XHRcdFx0Ly8gZG9uJ3QgZ2V0IGNhY2hlZCBkYXRhLCBpbiBjYXNlIGRhdGEtY29sdW1uIGNoYW5nZXMgZHluYW1pY2FsbHlcclxuXHRcdFx0XHR2YXIgY29sdW1uID0gcGFyc2VJbnQoICQoIHRoaXMgKS5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXHJcblx0XHRcdFx0XHRldmVudFR5cGUgPSBldmVudC50eXBlLFxyXG5cdFx0XHRcdFx0bGl2ZVNlYXJjaCA9IHR5cGVvZiB3by5maWx0ZXJfbGl2ZVNlYXJjaCA9PT0gJ2Jvb2xlYW4nID9cclxuXHRcdFx0XHRcdFx0d28uZmlsdGVyX2xpdmVTZWFyY2ggOlxyXG5cdFx0XHRcdFx0XHR0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2xpdmVTZWFyY2gsIGNvbHVtbiApO1xyXG5cdFx0XHRcdGlmICggdGFibGUuY29uZmlnLndpZGdldE9wdGlvbnMuZmlsdGVyX2luaXRpYWxpemVkICYmXHJcblx0XHRcdFx0XHQvLyBpbW1lZGlhdGUgc2VhcmNoIGlmIHVzZXIgcHJlc3NlcyBlbnRlclxyXG5cdFx0XHRcdFx0KCBldmVudC53aGljaCA9PT0gdHNrZXlDb2Rlcy5lbnRlciB8fFxyXG5cdFx0XHRcdFx0XHQvLyBpbW1lZGlhdGUgc2VhcmNoIGlmIGEgXCJzZWFyY2hcIiBvciBcImJsdXJcIiBpcyB0cmlnZ2VyZWQgb24gdGhlIGlucHV0XHJcblx0XHRcdFx0XHRcdCggZXZlbnRUeXBlID09PSAnc2VhcmNoJyB8fCBldmVudFR5cGUgPT09ICdibHVyJyApIHx8XHJcblx0XHRcdFx0XHRcdC8vIGNoYW5nZSAmIGlucHV0IGV2ZW50cyBtdXN0IGJlIGlnbm9yZWQgaWYgbGl2ZVNlYXJjaCAhPT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQoIGV2ZW50VHlwZSA9PT0gJ2NoYW5nZScgfHwgZXZlbnRUeXBlID09PSAnaW5wdXQnICkgJiZcclxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBzZWFyY2ggaWYgbGl2ZVNlYXJjaCBpcyBhIG51bWJlclxyXG5cdFx0XHRcdFx0XHQoIGxpdmVTZWFyY2ggPT09IHRydWUgfHwgbGl2ZVNlYXJjaCAhPT0gdHJ1ZSAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgIT09ICdJTlBVVCcgKSAmJlxyXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBhbGxvdyAnY2hhbmdlJyBvciAnaW5wdXQnIGV2ZW50IHRvIHByb2Nlc3MgaWYgdGhlIGlucHV0IHZhbHVlXHJcblx0XHRcdFx0XHRcdC8vIGlzIHRoZSBzYW1lIC0gZml4ZXMgIzY4NVxyXG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlICE9PSBjLmxhc3RTZWFyY2hbY29sdW1uXVxyXG5cdFx0XHRcdFx0KVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdC8vIGluaXQgc2VhcmNoIHdpdGggbm8gZGVsYXlcclxuXHRcdFx0XHRcdCQoIHRoaXMgKS5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScsIG5ldyBEYXRlKCkuZ2V0VGltZSgpICk7XHJcblx0XHRcdFx0XHR0c2Yuc2VhcmNoaW5nKCB0YWJsZSwgZXZlbnRUeXBlICE9PSAna2V5cHJlc3MnIHx8IGV2ZW50LndoaWNoID09PSB0c2tleUNvZGVzLmVudGVyLCB0cnVlLCBjb2x1bW4gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdHNlYXJjaGluZzogZnVuY3Rpb24oIHRhYmxlLCBmaWx0ZXIsIHNraXBGaXJzdCwgY29sdW1uICkge1xyXG5cdFx0XHR2YXIgbGl2ZVNlYXJjaCxcclxuXHRcdFx0XHR3byA9IHRhYmxlLmNvbmZpZy53aWRnZXRPcHRpb25zO1xyXG5cdFx0XHRpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvLyBubyBkZWxheVxyXG5cdFx0XHRcdGxpdmVTZWFyY2ggPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsaXZlU2VhcmNoID0gdHlwZW9mIHdvLmZpbHRlcl9saXZlU2VhcmNoID09PSAnYm9vbGVhbicgP1xyXG5cdFx0XHRcdFx0d28uZmlsdGVyX2xpdmVTZWFyY2ggOlxyXG5cdFx0XHRcdFx0Ly8gZ2V0IGNvbHVtbiBzZXR0aW5nLCBvciBzZXQgdG8gZmFsbGJhY2sgdmFsdWUsIG9yIGRlZmF1bHQgdG8gZmFsc2VcclxuXHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfbGl2ZVNlYXJjaCwgY29sdW1uICk7XHJcblx0XHRcdFx0aWYgKCB0eXBlb2YgbGl2ZVNlYXJjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0XHRcdFx0XHRsaXZlU2VhcmNoID0gd28uZmlsdGVyX2xpdmVTZWFyY2guZmFsbGJhY2sgfHwgZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGNsZWFyVGltZW91dCggd28uZmlsdGVyX3NlYXJjaFRpbWVyICk7XHJcblx0XHRcdGlmICggdHlwZW9mIGZpbHRlciA9PT0gJ3VuZGVmaW5lZCcgfHwgZmlsdGVyID09PSB0cnVlICkge1xyXG5cdFx0XHRcdC8vIGRlbGF5IGZpbHRlcmluZ1xyXG5cdFx0XHRcdHdvLmZpbHRlcl9zZWFyY2hUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dHNmLmNoZWNrRmlsdGVycyggdGFibGUsIGZpbHRlciwgc2tpcEZpcnN0ICk7XHJcblx0XHRcdFx0fSwgbGl2ZVNlYXJjaCA/IHdvLmZpbHRlcl9zZWFyY2hEZWxheSA6IDEwICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gc2tpcCBkZWxheVxyXG5cdFx0XHRcdHRzZi5jaGVja0ZpbHRlcnMoIHRhYmxlLCBmaWx0ZXIsIHNraXBGaXJzdCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0ZXF1YWxGaWx0ZXJzOiBmdW5jdGlvbiAoYywgZmlsdGVyMSwgZmlsdGVyMikge1xyXG5cdFx0XHR2YXIgaW5keCxcclxuXHRcdFx0XHRmMSA9IFtdLFxyXG5cdFx0XHRcdGYyID0gW10sXHJcblx0XHRcdFx0bGVuID0gYy5jb2x1bW5zICsgMTsgLy8gYWRkIG9uZSB0byBpbmNsdWRlIGFueU1hdGNoIGZpbHRlclxyXG5cdFx0XHRmaWx0ZXIxID0gJC5pc0FycmF5KGZpbHRlcjEpID8gZmlsdGVyMSA6IFtdO1xyXG5cdFx0XHRmaWx0ZXIyID0gJC5pc0FycmF5KGZpbHRlcjIpID8gZmlsdGVyMiA6IFtdO1xyXG5cdFx0XHRmb3IgKGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KyspIHtcclxuXHRcdFx0XHRmMVtpbmR4XSA9IGZpbHRlcjFbaW5keF0gfHwgJyc7XHJcblx0XHRcdFx0ZjJbaW5keF0gPSBmaWx0ZXIyW2luZHhdIHx8ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmMS5qb2luKCcsJykgPT09IGYyLmpvaW4oJywnKTtcclxuXHRcdH0sXHJcblx0XHRjaGVja0ZpbHRlcnM6IGZ1bmN0aW9uKCB0YWJsZSwgZmlsdGVyLCBza2lwRmlyc3QgKSB7XHJcblx0XHRcdHZhciBjID0gdGFibGUuY29uZmlnLFxyXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxyXG5cdFx0XHRcdGZpbHRlckFycmF5ID0gJC5pc0FycmF5KCBmaWx0ZXIgKSxcclxuXHRcdFx0XHRmaWx0ZXJzID0gKCBmaWx0ZXJBcnJheSApID8gZmlsdGVyIDogdHMuZ2V0RmlsdGVycyggdGFibGUsIHRydWUgKSxcclxuXHRcdFx0XHRjdXJyZW50RmlsdGVycyA9IGZpbHRlcnMgfHwgW107IC8vIGN1cnJlbnQgZmlsdGVyIHZhbHVlc1xyXG5cdFx0XHQvLyBwcmV2ZW50IGVycm9ycyBpZiBkZWxheSBpbml0IGlzIHNldFxyXG5cdFx0XHRpZiAoICQuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICkge1xyXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYWNoZSBpZiBkZWxheUluaXQgc2V0ICYgcGFnZXIgaGFzIGluaXRpYWxpemVkICggYWZ0ZXIgdXNlciBpbml0aWF0ZXMgYSBzZWFyY2ggKVxyXG5cdFx0XHRcdGlmICggYy5kZWxheUluaXQgJiYgKCAhYy5wYWdlciB8fCBjLnBhZ2VyICYmIGMucGFnZXIuaW5pdGlhbGl6ZWQgKSApIHtcclxuXHRcdFx0XHRcdHRzLnVwZGF0ZUNhY2hlKCBjLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dHNmLmNoZWNrRmlsdGVycyggdGFibGUsIGZhbHNlLCBza2lwRmlyc3QgKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYWRkIGZpbHRlciBhcnJheSBiYWNrIGludG8gaW5wdXRzXHJcblx0XHRcdGlmICggZmlsdGVyQXJyYXkgKSB7XHJcblx0XHRcdFx0dHMuc2V0RmlsdGVycyggdGFibGUsIGZpbHRlcnMsIGZhbHNlLCBza2lwRmlyc3QgIT09IHRydWUgKTtcclxuXHRcdFx0XHRpZiAoICF3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XHJcblx0XHRcdFx0XHRjLmxhc3RTZWFyY2ggPSBbXTtcclxuXHRcdFx0XHRcdGMubGFzdENvbWJpbmVkRmlsdGVyID0gJyc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggd28uZmlsdGVyX2hpZGVGaWx0ZXJzICkge1xyXG5cdFx0XHRcdC8vIHNob3cvaGlkZSBmaWx0ZXIgcm93IGFzIG5lZWRlZFxyXG5cdFx0XHRcdGMuJHRhYmxlXHJcblx0XHRcdFx0XHQuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyUm93IClcclxuXHRcdFx0XHRcdC50cmlnZ2VySGFuZGxlciggdHNmLmhpZGVGaWx0ZXJzQ2hlY2soIGMgKSA/ICdtb3VzZWxlYXZlJyA6ICdtb3VzZWVudGVyJyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHJldHVybiBpZiB0aGUgbGFzdCBzZWFyY2ggaXMgdGhlIHNhbWU7IGJ1dCBmaWx0ZXIgPT09IGZhbHNlIHdoZW4gdXBkYXRpbmcgdGhlIHNlYXJjaFxyXG5cdFx0XHQvLyBzZWUgZXhhbXBsZS13aWRnZXQtZmlsdGVyLmh0bWwgZmlsdGVyIHRvZ2dsZSBidXR0b25zXHJcblx0XHRcdGlmICggdHNmLmVxdWFsRmlsdGVycyhjLCBjLmxhc3RTZWFyY2gsIGN1cnJlbnRGaWx0ZXJzKSApIHtcclxuXHRcdFx0XHRpZiAoIGZpbHRlciAhPT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIGZvcmNlIGZpbHRlciByZWZyZXNoXHJcblx0XHRcdFx0XHRjLmxhc3RDb21iaW5lZEZpbHRlciA9ICcnO1xyXG5cdFx0XHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGRlZmluZSBmaWx0ZXIgaW5zaWRlIGl0IGlzIGZhbHNlXHJcblx0XHRcdGZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdO1xyXG5cdFx0XHQvLyBjb252ZXJ0IGZpbHRlcnMgdG8gc3RyaW5ncyAtIHNlZSAjMTA3MFxyXG5cdFx0XHRmaWx0ZXJzID0gQXJyYXkucHJvdG90eXBlLm1hcCA/XHJcblx0XHRcdFx0ZmlsdGVycy5tYXAoIFN0cmluZyApIDpcclxuXHRcdFx0XHQvLyBmb3IgSUU4ICYgb2xkZXIgYnJvd3NlcnMgLSBtYXliZSBub3QgdGhlIGJlc3QgbWV0aG9kXHJcblx0XHRcdFx0ZmlsdGVycy5qb2luKCAnXFx1ZmZmZCcgKS5zcGxpdCggJ1xcdWZmZmQnICk7XHJcblxyXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcclxuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ2ZpbHRlclN0YXJ0JywgWyBmaWx0ZXJzIF0gKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIGMuc2hvd1Byb2Nlc3NpbmcgKSB7XHJcblx0XHRcdFx0Ly8gZ2l2ZSBpdCB0aW1lIGZvciB0aGUgcHJvY2Vzc2luZyBpY29uIHRvIGtpY2sgaW5cclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHRzZi5maW5kUm93cyggdGFibGUsIGZpbHRlcnMsIGN1cnJlbnRGaWx0ZXJzICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fSwgMzAgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0c2YuZmluZFJvd3MoIHRhYmxlLCBmaWx0ZXJzLCBjdXJyZW50RmlsdGVycyApO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGhpZGVGaWx0ZXJzQ2hlY2s6IGZ1bmN0aW9uKCBjICkge1xyXG5cdFx0XHRpZiAodHlwZW9mIGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaGlkZUZpbHRlcnMgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YXIgdmFsID0gYy53aWRnZXRPcHRpb25zLmZpbHRlcl9oaWRlRmlsdGVycyggYyApO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuXHRcdFx0XHRcdHJldHVybiB2YWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cy5nZXRGaWx0ZXJzKCBjLiR0YWJsZSApLmpvaW4oICcnICkgPT09ICcnO1xyXG5cdFx0fSxcclxuXHRcdGhpZGVGaWx0ZXJzOiBmdW5jdGlvbiggYywgJHRhYmxlICkge1xyXG5cdFx0XHR2YXIgdGltZXI7XHJcblx0XHRcdCggJHRhYmxlIHx8IGMuJHRhYmxlIClcclxuXHRcdFx0XHQuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyUm93IClcclxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRzY3NzLmZpbHRlclJvd0hpZGUgKVxyXG5cdFx0XHRcdC5iaW5kKCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgZnVuY3Rpb24oIGUgKSB7XHJcblx0XHRcdFx0XHQvLyBzYXZlIGV2ZW50IG9iamVjdCAtIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMTQwXHJcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSBlLFxyXG5cdFx0XHRcdFx0XHQkcm93ID0gJCggdGhpcyApO1xyXG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApO1xyXG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCAvZW50ZXJ8b3Zlci8udGVzdCggZXZlbnQudHlwZSApICkge1xyXG5cdFx0XHRcdFx0XHRcdCRyb3cucmVtb3ZlQ2xhc3MoIHRzY3NzLmZpbHRlclJvd0hpZGUgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBoaWRlIGlmIGlucHV0IGhhcyBmb2N1c1xyXG5cdFx0XHRcdFx0XHRcdC8vICQoICc6Zm9jdXMnICkgbmVlZHMgalF1ZXJ5IDEuNitcclxuXHRcdFx0XHRcdFx0XHRpZiAoICQoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKS5jbG9zZXN0KCAndHInIClbMF0gIT09ICRyb3dbMF0gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBkb24ndCBoaWRlIHJvdyBpZiBhbnkgZmlsdGVyIGhhcyBhIHZhbHVlXHJcblx0XHRcdFx0XHRcdFx0XHQkcm93LnRvZ2dsZUNsYXNzKCB0c2Nzcy5maWx0ZXJSb3dIaWRlLCB0c2YuaGlkZUZpbHRlcnNDaGVjayggYyApICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCAyMDAgKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5maW5kKCAnaW5wdXQsIHNlbGVjdCcgKS5iaW5kKCAnZm9jdXMgYmx1cicsIGZ1bmN0aW9uKCBlICkge1xyXG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gZSxcclxuXHRcdFx0XHRcdFx0JHJvdyA9ICQoIHRoaXMgKS5jbG9zZXN0KCAndHInICk7XHJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XHJcblx0XHRcdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XHJcblx0XHRcdFx0XHRcdC8vIGRvbid0IGhpZGUgcm93IGlmIGFueSBmaWx0ZXIgaGFzIGEgdmFsdWVcclxuXHRcdFx0XHRcdFx0JHJvdy50b2dnbGVDbGFzcyggdHNjc3MuZmlsdGVyUm93SGlkZSwgdHNmLmhpZGVGaWx0ZXJzQ2hlY2soIGMgKSAmJiBldmVudC50eXBlICE9PSAnZm9jdXMnICk7XHJcblx0XHRcdFx0XHR9LCAyMDAgKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRkZWZhdWx0RmlsdGVyOiBmdW5jdGlvbiggZmlsdGVyLCBtYXNrICkge1xyXG5cdFx0XHRpZiAoIGZpbHRlciA9PT0gJycgKSB7IHJldHVybiBmaWx0ZXI7IH1cclxuXHRcdFx0dmFyIHJlZ2V4ID0gdHNmUmVnZXguaVF1ZXJ5LFxyXG5cdFx0XHRcdG1hc2tMZW4gPSBtYXNrLm1hdGNoKCB0c2ZSZWdleC5pZ1F1ZXJ5ICkubGVuZ3RoLFxyXG5cdFx0XHRcdHF1ZXJ5ID0gbWFza0xlbiA+IDEgPyAkLnRyaW0oIGZpbHRlciApLnNwbGl0KCAvXFxzLyApIDogWyAkLnRyaW0oIGZpbHRlciApIF0sXHJcblx0XHRcdFx0bGVuID0gcXVlcnkubGVuZ3RoIC0gMSxcclxuXHRcdFx0XHRpbmR4ID0gMCxcclxuXHRcdFx0XHR2YWwgPSBtYXNrO1xyXG5cdFx0XHRpZiAoIGxlbiA8IDEgJiYgbWFza0xlbiA+IDEgKSB7XHJcblx0XHRcdFx0Ly8gb25seSBvbmUgJ3dvcmQnIGluIHF1ZXJ5IGJ1dCBtYXNrIGhhcyA+MSBzbG90c1xyXG5cdFx0XHRcdHF1ZXJ5WzFdID0gcXVlcnlbMF07XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gcmVwbGFjZSBhbGwge3F1ZXJ5fSB3aXRoIHF1ZXJ5IHdvcmRzLi4uXHJcblx0XHRcdC8vIGlmIHF1ZXJ5ID0gJ0JvYicsIHRoZW4gY29udmVydCBtYXNrIGZyb20gJyF7cXVlcnl9JyB0byAnIUJvYidcclxuXHRcdFx0Ly8gaWYgcXVlcnkgPSAnQm9iIEpvZSBGcmFuaycsIHRoZW4gY29udmVydCBtYXNrICd7cX0gT1Ige3F9JyB0byAnQm9iIE9SIEpvZSBPUiBGcmFuaydcclxuXHRcdFx0d2hpbGUgKCByZWdleC50ZXN0KCB2YWwgKSApIHtcclxuXHRcdFx0XHR2YWwgPSB2YWwucmVwbGFjZSggcmVnZXgsIHF1ZXJ5W2luZHgrK10gfHwgJycgKTtcclxuXHRcdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIHZhbCApICYmIGluZHggPCBsZW4gJiYgKCBxdWVyeVtpbmR4XSB8fCAnJyApICE9PSAnJyApIHtcclxuXHRcdFx0XHRcdHZhbCA9IG1hc2sucmVwbGFjZSggcmVnZXgsIHZhbCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdmFsO1xyXG5cdFx0fSxcclxuXHRcdGdldExhdGVzdFNlYXJjaDogZnVuY3Rpb24oICRpbnB1dCApIHtcclxuXHRcdFx0aWYgKCAkaW5wdXQgKSB7XHJcblx0XHRcdFx0cmV0dXJuICRpbnB1dC5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcclxuXHRcdFx0XHRcdHJldHVybiAkKCBiICkuYXR0ciggJ2RhdGEtbGFzdFNlYXJjaFRpbWUnICkgLSAkKCBhICkuYXR0ciggJ2RhdGEtbGFzdFNlYXJjaFRpbWUnICk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuICRpbnB1dCB8fCAkKCk7XHJcblx0XHR9LFxyXG5cdFx0ZmluZFJhbmdlOiBmdW5jdGlvbiggYywgdmFsLCBpZ25vcmVSYW5nZXMgKSB7XHJcblx0XHRcdC8vIGxvb2sgZm9yIG11bHRpcGxlIGNvbHVtbnMgJzEtMyw0LTYsOCcgaW4gZGF0YS1jb2x1bW5cclxuXHRcdFx0dmFyIHRlbXAsIHJhbmdlcywgcmFuZ2UsIHN0YXJ0LCBlbmQsIHNpbmdsZXMsIGksIGluZHgsIGxlbixcclxuXHRcdFx0XHRjb2x1bW5zID0gW107XHJcblx0XHRcdGlmICggL15bMC05XSskLy50ZXN0KCB2YWwgKSApIHtcclxuXHRcdFx0XHQvLyBhbHdheXMgcmV0dXJuIGFuIGFycmF5XHJcblx0XHRcdFx0cmV0dXJuIFsgcGFyc2VJbnQoIHZhbCwgMTAgKSBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHByb2Nlc3MgY29sdW1uIHJhbmdlXHJcblx0XHRcdGlmICggIWlnbm9yZVJhbmdlcyAmJiAvLS8udGVzdCggdmFsICkgKSB7XHJcblx0XHRcdFx0cmFuZ2VzID0gdmFsLm1hdGNoKCAvKFxcZCspXFxzKi1cXHMqKFxcZCspL2cgKTtcclxuXHRcdFx0XHRsZW4gPSByYW5nZXMgPyByYW5nZXMubGVuZ3RoIDogMDtcclxuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0cmFuZ2UgPSByYW5nZXNbaW5keF0uc3BsaXQoIC9cXHMqLVxccyovICk7XHJcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlSW50KCByYW5nZVswXSwgMTAgKSB8fCAwO1xyXG5cdFx0XHRcdFx0ZW5kID0gcGFyc2VJbnQoIHJhbmdlWzFdLCAxMCApIHx8ICggYy5jb2x1bW5zIC0gMSApO1xyXG5cdFx0XHRcdFx0aWYgKCBzdGFydCA+IGVuZCApIHtcclxuXHRcdFx0XHRcdFx0dGVtcCA9IHN0YXJ0OyBzdGFydCA9IGVuZDsgZW5kID0gdGVtcDsgLy8gc3dhcFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBlbmQgPj0gYy5jb2x1bW5zICkge1xyXG5cdFx0XHRcdFx0XHRlbmQgPSBjLmNvbHVtbnMgLSAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yICggOyBzdGFydCA8PSBlbmQ7IHN0YXJ0KysgKSB7XHJcblx0XHRcdFx0XHRcdGNvbHVtbnNbIGNvbHVtbnMubGVuZ3RoIF0gPSBzdGFydDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHJlbW92ZSBwcm9jZXNzZWQgcmFuZ2UgZnJvbSB2YWxcclxuXHRcdFx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKCByYW5nZXNbIGluZHggXSwgJycgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gcHJvY2VzcyBzaW5nbGUgY29sdW1uc1xyXG5cdFx0XHRpZiAoICFpZ25vcmVSYW5nZXMgJiYgLywvLnRlc3QoIHZhbCApICkge1xyXG5cdFx0XHRcdHNpbmdsZXMgPSB2YWwuc3BsaXQoIC9cXHMqLFxccyovICk7XHJcblx0XHRcdFx0bGVuID0gc2luZ2xlcy5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0XHRcdGlmICggc2luZ2xlc1sgaSBdICE9PSAnJyApIHtcclxuXHRcdFx0XHRcdFx0aW5keCA9IHBhcnNlSW50KCBzaW5nbGVzWyBpIF0sIDEwICk7XHJcblx0XHRcdFx0XHRcdGlmICggaW5keCA8IGMuY29sdW1ucyApIHtcclxuXHRcdFx0XHRcdFx0XHRjb2x1bW5zWyBjb2x1bW5zLmxlbmd0aCBdID0gaW5keDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyByZXR1cm4gYWxsIGNvbHVtbnNcclxuXHRcdFx0aWYgKCAhY29sdW1ucy5sZW5ndGggKSB7XHJcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjLmNvbHVtbnM7IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdGNvbHVtbnNbIGNvbHVtbnMubGVuZ3RoIF0gPSBpbmR4O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY29sdW1ucztcclxuXHRcdH0sXHJcblx0XHRnZXRDb2x1bW5FbG06IGZ1bmN0aW9uKCBjLCAkZWxlbWVudHMsIGNvbHVtbiApIHtcclxuXHRcdFx0Ly8gZGF0YS1jb2x1bW4gbWF5IGNvbnRhaW4gbXVsdGlwbGUgY29sdW1ucyAnMS0zLDUtNiw4J1xyXG5cdFx0XHQvLyByZXBsYWNlczogYy4kZmlsdGVycy5maWx0ZXIoICdbZGF0YS1jb2x1bW49XCInICsgY29sdW1uICsgJ1wiXScgKTtcclxuXHRcdFx0cmV0dXJuICRlbGVtZW50cy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBjb2xzID0gdHNmLmZpbmRSYW5nZSggYywgJCggdGhpcyApLmF0dHIoICdkYXRhLWNvbHVtbicgKSApO1xyXG5cdFx0XHRcdHJldHVybiAkLmluQXJyYXkoIGNvbHVtbiwgY29scyApID4gLTE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdG11bHRpcGxlQ29sdW1uczogZnVuY3Rpb24oIGMsICRpbnB1dCApIHtcclxuXHRcdFx0Ly8gbG9vayBmb3IgbXVsdGlwbGUgY29sdW1ucyAnMS0zLDQtNiw4JyBpbiBkYXRhLWNvbHVtblxyXG5cdFx0XHR2YXIgd28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0Ly8gb25seSB0YXJnZXQgJ2FsbCcgY29sdW1uIGlucHV0cyBvbiBpbml0aWFsaXphdGlvblxyXG5cdFx0XHRcdC8vICYgZG9uJ3QgdGFyZ2V0ICdhbGwnIGNvbHVtbiBpbnB1dHMgaWYgdGhleSBkb24ndCBleGlzdFxyXG5cdFx0XHRcdHRhcmdldHMgPSB3by5maWx0ZXJfaW5pdGlhbGl6ZWQgfHwgISRpbnB1dC5maWx0ZXIoIHdvLmZpbHRlcl9hbnlDb2x1bW5TZWxlY3RvciApLmxlbmd0aCxcclxuXHRcdFx0XHR2YWwgPSAkLnRyaW0oIHRzZi5nZXRMYXRlc3RTZWFyY2goICRpbnB1dCApLmF0dHIoICdkYXRhLWNvbHVtbicgKSB8fCAnJyApO1xyXG5cdFx0XHRyZXR1cm4gdHNmLmZpbmRSYW5nZSggYywgdmFsLCAhdGFyZ2V0cyApO1xyXG5cdFx0fSxcclxuXHRcdHByb2Nlc3NUeXBlczogZnVuY3Rpb24oIGMsIGRhdGEsIHZhcnMgKSB7XHJcblx0XHRcdHZhciBmZnhuLFxyXG5cdFx0XHRcdGZpbHRlck1hdGNoZWQgPSBudWxsLFxyXG5cdFx0XHRcdG1hdGNoZXMgPSBudWxsO1xyXG5cdFx0XHRmb3IgKCBmZnhuIGluIHRzZi50eXBlcyApIHtcclxuXHRcdFx0XHRpZiAoICQuaW5BcnJheSggZmZ4biwgdmFycy5leGNsdWRlTWF0Y2ggKSA8IDAgJiYgbWF0Y2hlcyA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdG1hdGNoZXMgPSB0c2YudHlwZXNbZmZ4bl0oIGMsIGRhdGEsIHZhcnMgKTtcclxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcyAhPT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0ZGF0YS5tYXRjaGVkT24gPSBmZnhuO1xyXG5cdFx0XHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gbWF0Y2hlcztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZpbHRlck1hdGNoZWQ7XHJcblx0XHR9LFxyXG5cdFx0bWF0Y2hUeXBlOiBmdW5jdGlvbiggYywgY29sdW1uSW5kZXggKSB7XHJcblx0XHRcdHZhciBpc01hdGNoLFxyXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxyXG5cdFx0XHRcdCRlbCA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbkluZGV4IF07XHJcblx0XHRcdC8vIGZpbHRlci1leGFjdCA+IGZpbHRlci1tYXRjaCA+IGZpbHRlcl9tYXRjaFR5cGUgZm9yIHR5cGVcclxuXHRcdFx0aWYgKCAkZWwuaGFzQ2xhc3MoICdmaWx0ZXItZXhhY3QnICkgKSB7XHJcblx0XHRcdFx0aXNNYXRjaCA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCAkZWwuaGFzQ2xhc3MoICdmaWx0ZXItbWF0Y2gnICkgKSB7XHJcblx0XHRcdFx0aXNNYXRjaCA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gZmlsdGVyLXNlbGVjdCBpcyBub3QgYXBwbGllZCB3aGVuIGZpbHRlcl9mdW5jdGlvbnMgYXJlIHVzZWQsIHNvIGxvb2sgZm9yIGEgc2VsZWN0XHJcblx0XHRcdFx0aWYgKCB3by5maWx0ZXJfY29sdW1uRmlsdGVycyApIHtcclxuXHRcdFx0XHRcdCRlbCA9IGMuJGZpbHRlcnNcclxuXHRcdFx0XHRcdFx0LmZpbmQoICcuJyArIHRzY3NzLmZpbHRlciApXHJcblx0XHRcdFx0XHRcdC5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzIClcclxuXHRcdFx0XHRcdFx0LmZpbHRlciggJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW5JbmRleCArICdcIl0nICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICggd28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMgKSB7XHJcblx0XHRcdFx0XHQkZWwgPSB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycy5maWx0ZXIoICdbZGF0YS1jb2x1bW49XCInICsgY29sdW1uSW5kZXggKyAnXCJdJyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpc01hdGNoID0gJGVsLmxlbmd0aCA/XHJcblx0XHRcdFx0XHRjLndpZGdldE9wdGlvbnMuZmlsdGVyX21hdGNoVHlwZVsgKCAkZWxbIDAgXS5ub2RlTmFtZSB8fCAnJyApLnRvTG93ZXJDYXNlKCkgXSA9PT0gJ21hdGNoJyA6XHJcblx0XHRcdFx0XHQvLyBkZWZhdWx0IHRvIGV4YWN0LCBpZiBubyBpbnB1dHMgZm91bmRcclxuXHRcdFx0XHRcdGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBpc01hdGNoO1xyXG5cdFx0fSxcclxuXHRcdHByb2Nlc3NSb3c6IGZ1bmN0aW9uKCBjLCBkYXRhLCB2YXJzICkge1xyXG5cdFx0XHR2YXIgcmVzdWx0LCBmaWx0ZXJNYXRjaGVkLFxyXG5cdFx0XHRcdGZ4biwgZmZ4biwgdHh0LFxyXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxyXG5cdFx0XHRcdHNob3dSb3cgPSB0cnVlLFxyXG5cdFx0XHRcdGhhc0FueU1hdGNoSW5wdXQgPSB3by5maWx0ZXJfJGFueU1hdGNoICYmIHdvLmZpbHRlcl8kYW55TWF0Y2gubGVuZ3RoLFxyXG5cclxuXHRcdFx0XHQvLyBpZiB3by5maWx0ZXJfJGFueU1hdGNoIGRhdGEtY29sdW1uIGF0dHJpYnV0ZSBpcyBjaGFuZ2VkIGR5bmFtaWNhbGx5XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBkbyBhbiBcImFueU1hdGNoXCIgc2VhcmNoIG9uIG9uZSBjb2x1bW4gdXNpbmcgZGF0YVxyXG5cdFx0XHRcdC8vIGZvciB0aGUgZW50aXJlIHJvdyAtIHNlZSAjOTk4XHJcblx0XHRcdFx0Y29sdW1uSW5kZXggPSB3by5maWx0ZXJfJGFueU1hdGNoICYmIHdvLmZpbHRlcl8kYW55TWF0Y2gubGVuZ3RoID9cclxuXHRcdFx0XHRcdC8vIGxvb2sgZm9yIG11bHRpcGxlIGNvbHVtbnMgJzEtMyw0LTYsOCdcclxuXHRcdFx0XHRcdHRzZi5tdWx0aXBsZUNvbHVtbnMoIGMsIHdvLmZpbHRlcl8kYW55TWF0Y2ggKSA6XHJcblx0XHRcdFx0XHRbXTtcclxuXHRcdFx0ZGF0YS4kY2VsbHMgPSBkYXRhLiRyb3cuY2hpbGRyZW4oKTtcclxuXHRcdFx0ZGF0YS5tYXRjaGVkT24gPSBudWxsO1xyXG5cdFx0XHRpZiAoIGRhdGEuYW55TWF0Y2hGbGFnICYmIGNvbHVtbkluZGV4Lmxlbmd0aCA+IDEgfHwgKCBkYXRhLmFueU1hdGNoRmlsdGVyICYmICFoYXNBbnlNYXRjaElucHV0ICkgKSB7XHJcblx0XHRcdFx0ZGF0YS5hbnlNYXRjaCA9IHRydWU7XHJcblx0XHRcdFx0ZGF0YS5pc01hdGNoID0gdHJ1ZTtcclxuXHRcdFx0XHRkYXRhLnJvd0FycmF5ID0gZGF0YS4kY2VsbHMubWFwKCBmdW5jdGlvbiggaSApIHtcclxuXHRcdFx0XHRcdGlmICggJC5pbkFycmF5KCBpLCBjb2x1bW5JbmRleCApID4gLTEgfHwgKCBkYXRhLmFueU1hdGNoRmlsdGVyICYmICFoYXNBbnlNYXRjaElucHV0ICkgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggZGF0YS5wYXJzZWRbIGkgXSApIHtcclxuXHRcdFx0XHRcdFx0XHR0eHQgPSBkYXRhLmNhY2hlQXJyYXlbIGkgXTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0eHQgPSBkYXRhLnJhd0FycmF5WyBpIF07XHJcblx0XHRcdFx0XHRcdFx0dHh0ID0gJC50cmltKCB3by5maWx0ZXJfaWdub3JlQ2FzZSA/IHR4dC50b0xvd2VyQ2FzZSgpIDogdHh0ICk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBjLnNvcnRMb2NhbGVDb21wYXJlICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dHh0ID0gdHMucmVwbGFjZUFjY2VudHMoIHR4dCApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHh0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pLmdldCgpO1xyXG5cdFx0XHRcdGRhdGEuZmlsdGVyID0gZGF0YS5hbnlNYXRjaEZpbHRlcjtcclxuXHRcdFx0XHRkYXRhLmlGaWx0ZXIgPSBkYXRhLmlBbnlNYXRjaEZpbHRlcjtcclxuXHRcdFx0XHRkYXRhLmV4YWN0ID0gZGF0YS5yb3dBcnJheS5qb2luKCAnICcgKTtcclxuXHRcdFx0XHRkYXRhLmlFeGFjdCA9IHdvLmZpbHRlcl9pZ25vcmVDYXNlID8gZGF0YS5leGFjdC50b0xvd2VyQ2FzZSgpIDogZGF0YS5leGFjdDtcclxuXHRcdFx0XHRkYXRhLmNhY2hlID0gZGF0YS5jYWNoZUFycmF5LnNsaWNlKCAwLCAtMSApLmpvaW4oICcgJyApO1xyXG5cdFx0XHRcdHZhcnMuZXhjbHVkZU1hdGNoID0gdmFycy5ub0FueU1hdGNoO1xyXG5cdFx0XHRcdGZpbHRlck1hdGNoZWQgPSB0c2YucHJvY2Vzc1R5cGVzKCBjLCBkYXRhLCB2YXJzICk7XHJcblx0XHRcdFx0aWYgKCBmaWx0ZXJNYXRjaGVkICE9PSBudWxsICkge1xyXG5cdFx0XHRcdFx0c2hvd1JvdyA9IGZpbHRlck1hdGNoZWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICggd28uZmlsdGVyX3N0YXJ0c1dpdGggKSB7XHJcblx0XHRcdFx0XHRcdHNob3dSb3cgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0Ly8gZGF0YS5yb3dBcnJheSBtYXkgbm90IGNvbnRhaW4gYWxsIGNvbHVtbnNcclxuXHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBNYXRoLm1pbiggYy5jb2x1bW5zLCBkYXRhLnJvd0FycmF5Lmxlbmd0aCApO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoICFzaG93Um93ICYmIGNvbHVtbkluZGV4ID4gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRjb2x1bW5JbmRleC0tO1xyXG5cdFx0XHRcdFx0XHRcdHNob3dSb3cgPSBzaG93Um93IHx8IGRhdGEucm93QXJyYXlbIGNvbHVtbkluZGV4IF0uaW5kZXhPZiggZGF0YS5pRmlsdGVyICkgPT09IDA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNob3dSb3cgPSAoIGRhdGEuaUV4YWN0ICsgZGF0YS5jaGlsZFJvd1RleHQgKS5pbmRleE9mKCBkYXRhLmlGaWx0ZXIgKSA+PSAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkYXRhLmFueU1hdGNoID0gZmFsc2U7XHJcblx0XHRcdFx0Ly8gbm8gb3RoZXIgZmlsdGVycyB0byBwcm9jZXNzXHJcblx0XHRcdFx0aWYgKCBkYXRhLmZpbHRlcnMuam9pbiggJycgKSA9PT0gZGF0YS5maWx0ZXIgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2hvd1JvdztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjLmNvbHVtbnM7IGNvbHVtbkluZGV4KysgKSB7XHJcblx0XHRcdFx0ZGF0YS5maWx0ZXIgPSBkYXRhLmZpbHRlcnNbIGNvbHVtbkluZGV4IF07XHJcblx0XHRcdFx0ZGF0YS5pbmRleCA9IGNvbHVtbkluZGV4O1xyXG5cclxuXHRcdFx0XHQvLyBmaWx0ZXIgdHlwZXMgdG8gZXhjbHVkZSwgcGVyIGNvbHVtblxyXG5cdFx0XHRcdHZhcnMuZXhjbHVkZU1hdGNoID0gdmFycy5leGNsdWRlRmlsdGVyWyBjb2x1bW5JbmRleCBdO1xyXG5cclxuXHRcdFx0XHQvLyBpZ25vcmUgaWYgZmlsdGVyIGlzIGVtcHR5IG9yIGRpc2FibGVkXHJcblx0XHRcdFx0aWYgKCBkYXRhLmZpbHRlciApIHtcclxuXHRcdFx0XHRcdGRhdGEuY2FjaGUgPSBkYXRhLmNhY2hlQXJyYXlbIGNvbHVtbkluZGV4IF07XHJcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhLnBhcnNlZFsgY29sdW1uSW5kZXggXSA/IGRhdGEuY2FjaGUgOiBkYXRhLnJhd0FycmF5WyBjb2x1bW5JbmRleCBdIHx8ICcnO1xyXG5cdFx0XHRcdFx0ZGF0YS5leGFjdCA9IGMuc29ydExvY2FsZUNvbXBhcmUgPyB0cy5yZXBsYWNlQWNjZW50cyggcmVzdWx0ICkgOiByZXN1bHQ7IC8vIGlzc3VlICM0MDVcclxuXHRcdFx0XHRcdGRhdGEuaUV4YWN0ID0gIXRzZlJlZ2V4LnR5cGUudGVzdCggdHlwZW9mIGRhdGEuZXhhY3QgKSAmJiB3by5maWx0ZXJfaWdub3JlQ2FzZSA/XHJcblx0XHRcdFx0XHRcdGRhdGEuZXhhY3QudG9Mb3dlckNhc2UoKSA6IGRhdGEuZXhhY3Q7XHJcblx0XHRcdFx0XHRkYXRhLmlzTWF0Y2ggPSB0c2YubWF0Y2hUeXBlKCBjLCBjb2x1bW5JbmRleCApO1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdCA9IHNob3dSb3c7IC8vIGlmIHNob3dSb3cgaXMgdHJ1ZSwgc2hvdyB0aGF0IHJvd1xyXG5cclxuXHRcdFx0XHRcdC8vIGluIGNhc2Ugc2VsZWN0IGZpbHRlciBvcHRpb24gaGFzIGEgZGlmZmVyZW50IHZhbHVlIHZzIHRleHQgJ2EgLSB6fEEgdGhyb3VnaCBaJ1xyXG5cdFx0XHRcdFx0ZmZ4biA9IHdvLmZpbHRlcl9jb2x1bW5GaWx0ZXJzID9cclxuXHRcdFx0XHRcdFx0Yy4kZmlsdGVycy5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzIClcclxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbkluZGV4ICsgJ1wiXScgKVxyXG5cdFx0XHRcdFx0XHRcdC5maW5kKCAnc2VsZWN0IG9wdGlvbjpzZWxlY3RlZCcgKVxyXG5cdFx0XHRcdFx0XHRcdC5hdHRyKCAnZGF0YS1mdW5jdGlvbi1uYW1lJyApIHx8ICcnIDogJyc7XHJcblx0XHRcdFx0XHQvLyByZXBsYWNlIGFjY2VudHMgLSBzZWUgIzM1N1xyXG5cdFx0XHRcdFx0aWYgKCBjLnNvcnRMb2NhbGVDb21wYXJlICkge1xyXG5cdFx0XHRcdFx0XHRkYXRhLmZpbHRlciA9IHRzLnJlcGxhY2VBY2NlbnRzKCBkYXRhLmZpbHRlciApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHJlcGxhY2UgY29sdW1uIHNwZWNpZmljIGRlZmF1bHQgZmlsdGVycyAtIHNlZSAjMTA4OFxyXG5cdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfZGVmYXVsdEZpbHRlciAmJiB0c2ZSZWdleC5pUXVlcnkudGVzdCggdmFycy5kZWZhdWx0Q29sRmlsdGVyWyBjb2x1bW5JbmRleCBdICkgKSB7XHJcblx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyID0gdHNmLmRlZmF1bHRGaWx0ZXIoIGRhdGEuZmlsdGVyLCB2YXJzLmRlZmF1bHRDb2xGaWx0ZXJbIGNvbHVtbkluZGV4IF0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBkYXRhLmlGaWx0ZXIgPSBjYXNlIGluc2Vuc2l0aXZlICggaWYgd28uZmlsdGVyX2lnbm9yZUNhc2UgaXMgdHJ1ZSApLFxyXG5cdFx0XHRcdFx0Ly8gZGF0YS5maWx0ZXIgPSBjYXNlIHNlbnNpdGl2ZVxyXG5cdFx0XHRcdFx0ZGF0YS5pRmlsdGVyID0gd28uZmlsdGVyX2lnbm9yZUNhc2UgPyAoIGRhdGEuZmlsdGVyIHx8ICcnICkudG9Mb3dlckNhc2UoKSA6IGRhdGEuZmlsdGVyO1xyXG5cdFx0XHRcdFx0ZnhuID0gdmFycy5mdW5jdGlvbnNbIGNvbHVtbkluZGV4IF07XHJcblx0XHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gbnVsbDtcclxuXHRcdFx0XHRcdGlmICggZnhuICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBmeG4gPT09ICdmdW5jdGlvbicgKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gZmlsdGVyIGNhbGxiYWNrKCBleGFjdCBjZWxsIGNvbnRlbnQsIHBhcnNlciBub3JtYWxpemVkIGNvbnRlbnQsXHJcblx0XHRcdFx0XHRcdFx0Ly8gZmlsdGVyIGlucHV0IHZhbHVlLCBjb2x1bW4gaW5kZXgsIGpRdWVyeSByb3cgb2JqZWN0IClcclxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gZnhuKCBkYXRhLmV4YWN0LCBkYXRhLmNhY2hlLCBkYXRhLmZpbHRlciwgY29sdW1uSW5kZXgsIGRhdGEuJHJvdywgYywgZGF0YSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgZnhuWyBmZnhuIHx8IGRhdGEuZmlsdGVyIF0gPT09ICdmdW5jdGlvbicgKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc2VsZWN0b3Igb3B0aW9uIGZ1bmN0aW9uXHJcblx0XHRcdFx0XHRcdFx0dHh0ID0gZmZ4biB8fCBkYXRhLmZpbHRlcjtcclxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJNYXRjaGVkID1cclxuXHRcdFx0XHRcdFx0XHRcdGZ4blsgdHh0IF0oIGRhdGEuZXhhY3QsIGRhdGEuY2FjaGUsIGRhdGEuZmlsdGVyLCBjb2x1bW5JbmRleCwgZGF0YS4kcm93LCBjLCBkYXRhICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggZmlsdGVyTWF0Y2hlZCA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0Ly8gY3ljbGUgdGhyb3VnaCB0aGUgZGlmZmVyZW50IGZpbHRlcnNcclxuXHRcdFx0XHRcdFx0Ly8gZmlsdGVycyByZXR1cm4gYSBib29sZWFuIG9yIG51bGwgaWYgbm90aGluZyBtYXRjaGVzXHJcblx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSB0c2YucHJvY2Vzc1R5cGVzKCBjLCBkYXRhLCB2YXJzICk7XHJcblx0XHRcdFx0XHRcdC8vIHNlbGVjdCB3aXRoIGV4YWN0IG1hdGNoOyBpZ25vcmUgXCJhbmRcIiBvciBcIm9yXCIgd2l0aGluIHRoZSB0ZXh0OyBmaXhlcyAjMTQ4NlxyXG5cdFx0XHRcdFx0XHR0eHQgPSBmeG4gPT09IHRydWUgJiYgKGRhdGEubWF0Y2hlZE9uID09PSAnYW5kJyB8fCBkYXRhLm1hdGNoZWRPbiA9PT0gJ29yJyk7XHJcblx0XHRcdFx0XHRcdGlmICggZmlsdGVyTWF0Y2hlZCAhPT0gbnVsbCAmJiAhdHh0KSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZmlsdGVyTWF0Y2hlZDtcclxuXHRcdFx0XHRcdFx0Ly8gTG9vayBmb3IgbWF0Y2gsIGFuZCBhZGQgY2hpbGQgcm93IGRhdGEgZm9yIG1hdGNoaW5nXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgZnhuIChmaWx0ZXItc2VsZWN0IGluIGhlYWRlcikgYWZ0ZXIgZmlsdGVyIHR5cGVzIGFyZSBjaGVja2VkXHJcblx0XHRcdFx0XHRcdFx0Ly8gd2l0aG91dCB0aGlzLCB0aGUgZmlsdGVyICsgalF1ZXJ5IFVJIHNlbGVjdG1lbnUgZGVtbyB3YXMgYnJlYWtpbmdcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGZ4biA9PT0gdHJ1ZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgc2VsZWN0b3IgdXNlcyBleGFjdCBtYXRjaCB1bmxlc3MgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcclxuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IGRhdGEuaXNNYXRjaCA/XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGRhdGEuaUV4YWN0IG1heSBiZSBhIG51bWJlclxyXG5cdFx0XHRcdFx0XHRcdFx0XHQoICcnICsgZGF0YS5pRXhhY3QgKS5zZWFyY2goIGRhdGEuaUZpbHRlciApID49IDAgOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmZpbHRlciA9PT0gZGF0YS5leGFjdDtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dHh0ID0gKCBkYXRhLmlFeGFjdCArIGRhdGEuY2hpbGRSb3dUZXh0ICkuaW5kZXhPZiggdHNmLnBhcnNlRmlsdGVyKCBjLCBkYXRhLmlGaWx0ZXIsIGRhdGEgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gKCAoICF3by5maWx0ZXJfc3RhcnRzV2l0aCAmJiB0eHQgPj0gMCApIHx8ICggd28uZmlsdGVyX3N0YXJ0c1dpdGggJiYgdHh0ID09PSAwICkgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGZpbHRlck1hdGNoZWQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzaG93Um93ID0gKCByZXN1bHQgKSA/IHNob3dSb3cgOiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHNob3dSb3c7XHJcblx0XHR9LFxyXG5cdFx0ZmluZFJvd3M6IGZ1bmN0aW9uKCB0YWJsZSwgZmlsdGVycywgY3VycmVudEZpbHRlcnMgKSB7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHR0c2YuZXF1YWxGaWx0ZXJzKHRhYmxlLmNvbmZpZywgdGFibGUuY29uZmlnLmxhc3RTZWFyY2gsIGN1cnJlbnRGaWx0ZXJzKSB8fFxyXG5cdFx0XHRcdCF0YWJsZS5jb25maWcud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaW5pdGlhbGl6ZWRcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsZW4sIG5vcm1fcm93cywgcm93RGF0YSwgJHJvd3MsICRyb3csIHJvd0luZGV4LCB0Ym9keUluZGV4LCAkdGJvZHksIGNvbHVtbkluZGV4LFxyXG5cdFx0XHRcdGlzQ2hpbGQsIGNoaWxkUm93LCBsYXN0U2VhcmNoLCBzaG93Um93LCBzaG93UGFyZW50LCB0aW1lLCB2YWwsIGluZHgsXHJcblx0XHRcdFx0bm90RmlsdGVyZWQsIHNlYXJjaEZpbHRlcmVkLCBxdWVyeSwgaW5qZWN0ZWQsIHJlcywgaWQsIHR4dCxcclxuXHRcdFx0XHRzdG9yZWRGaWx0ZXJzID0gJC5leHRlbmQoIFtdLCBmaWx0ZXJzICksXHJcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcclxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcclxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdmaWx0ZXInKSxcclxuXHRcdFx0XHQvLyBkYXRhIG9iamVjdCBwYXNzZWQgdG8gZmlsdGVyczsgYW55TWF0Y2ggaXMgYSBmbGFnIGZvciB0aGUgZmlsdGVyc1xyXG5cdFx0XHRcdGRhdGEgPSB7XHJcblx0XHRcdFx0XHRhbnlNYXRjaDogZmFsc2UsXHJcblx0XHRcdFx0XHRmaWx0ZXJzOiBmaWx0ZXJzLFxyXG5cdFx0XHRcdFx0Ly8gcmVnZXggZmlsdGVyIHR5cGUgY2FjaGVcclxuXHRcdFx0XHRcdGZpbHRlcl9yZWdleENhY2hlIDogW11cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHZhcnMgPSB7XHJcblx0XHRcdFx0XHQvLyBhbnlNYXRjaCByZWFsbHkgc2NyZXdzIHVwIHdpdGggdGhlc2UgdHlwZXMgb2YgZmlsdGVyc1xyXG5cdFx0XHRcdFx0bm9BbnlNYXRjaDogWyAncmFuZ2UnLCAgJ29wZXJhdG9ycycgXSxcclxuXHRcdFx0XHRcdC8vIGNhY2hlIGZpbHRlciB2YXJpYWJsZXMgdGhhdCB1c2UgdHMuZ2V0Q29sdW1uRGF0YSBpbiB0aGUgbWFpbiBsb29wXHJcblx0XHRcdFx0XHRmdW5jdGlvbnMgOiBbXSxcclxuXHRcdFx0XHRcdGV4Y2x1ZGVGaWx0ZXIgOiBbXSxcclxuXHRcdFx0XHRcdGRlZmF1bHRDb2xGaWx0ZXIgOiBbXSxcclxuXHRcdFx0XHRcdGRlZmF1bHRBbnlGaWx0ZXIgOiB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2RlZmF1bHRGaWx0ZXIsIGMuY29sdW1ucywgdHJ1ZSApIHx8ICcnXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0Ly8gcGFyc2UgY29sdW1ucyBhZnRlciBmb3JtYXR0ZXIsIGluIGNhc2UgdGhlIGNsYXNzIGlzIGFkZGVkIGF0IHRoYXQgcG9pbnRcclxuXHRcdFx0ZGF0YS5wYXJzZWQgPSBbXTtcclxuXHRcdFx0Zm9yICggY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGMuY29sdW1uczsgY29sdW1uSW5kZXgrKyApIHtcclxuXHRcdFx0XHRkYXRhLnBhcnNlZFsgY29sdW1uSW5kZXggXSA9IHdvLmZpbHRlcl91c2VQYXJzZWREYXRhIHx8XHJcblx0XHRcdFx0XHQvLyBwYXJzZXIgaGFzIGEgXCJwYXJzZWRcIiBwYXJhbWV0ZXJcclxuXHRcdFx0XHRcdCggYy5wYXJzZXJzICYmIGMucGFyc2Vyc1sgY29sdW1uSW5kZXggXSAmJiBjLnBhcnNlcnNbIGNvbHVtbkluZGV4IF0ucGFyc2VkIHx8XHJcblx0XHRcdFx0XHQvLyBnZXREYXRhIG1heSBub3QgcmV0dXJuICdwYXJzZWQnIGlmIG90aGVyICdmaWx0ZXItJyBjbGFzcyBuYW1lcyBleGlzdFxyXG5cdFx0XHRcdFx0Ly8gKCBlLmcuIDx0aCBjbGFzcz1cImZpbHRlci1zZWxlY3QgZmlsdGVyLXBhcnNlZFwiPiApXHJcblx0XHRcdFx0XHR0cy5nZXREYXRhICYmIHRzLmdldERhdGEoIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbkluZGV4IF0sXHJcblx0XHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCBjLmhlYWRlcnMsIGNvbHVtbkluZGV4ICksICdmaWx0ZXInICkgPT09ICdwYXJzZWQnIHx8XHJcblx0XHRcdFx0XHRjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW5JbmRleCBdLmhhc0NsYXNzKCAnZmlsdGVyLXBhcnNlZCcgKSApO1xyXG5cclxuXHRcdFx0XHR2YXJzLmZ1bmN0aW9uc1sgY29sdW1uSW5kZXggXSA9XHJcblx0XHRcdFx0XHR0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2Z1bmN0aW9ucywgY29sdW1uSW5kZXggKSB8fFxyXG5cdFx0XHRcdFx0Yy4kaGVhZGVySW5kZXhlZFsgY29sdW1uSW5kZXggXS5oYXNDbGFzcyggJ2ZpbHRlci1zZWxlY3QnICk7XHJcblx0XHRcdFx0dmFycy5kZWZhdWx0Q29sRmlsdGVyWyBjb2x1bW5JbmRleCBdID1cclxuXHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfZGVmYXVsdEZpbHRlciwgY29sdW1uSW5kZXggKSB8fCAnJztcclxuXHRcdFx0XHR2YXJzLmV4Y2x1ZGVGaWx0ZXJbIGNvbHVtbkluZGV4IF0gPVxyXG5cdFx0XHRcdFx0KCB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2V4Y2x1ZGVGaWx0ZXIsIGNvbHVtbkluZGV4LCB0cnVlICkgfHwgJycgKS5zcGxpdCggL1xccysvICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGVidWcgKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coICdGaWx0ZXIgPj4gU3RhcnRpbmcgZmlsdGVyIHdpZGdldCBzZWFyY2gnLCBmaWx0ZXJzICk7XHJcblx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gZmlsdGVyZWQgcm93cyBjb3VudFxyXG5cdFx0XHRjLmZpbHRlcmVkUm93cyA9IDA7XHJcblx0XHRcdGMudG90YWxSb3dzID0gMDtcclxuXHRcdFx0Y3VycmVudEZpbHRlcnMgPSAoIHN0b3JlZEZpbHRlcnMgfHwgW10gKTtcclxuXHJcblx0XHRcdGZvciAoIHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgYy4kdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcclxuXHRcdFx0XHQkdGJvZHkgPSB0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCBjLiR0Ym9kaWVzLmVxKCB0Ym9keUluZGV4ICksIHRydWUgKTtcclxuXHRcdFx0XHQvLyBza2lwIGNoaWxkIHJvd3MgJiB3aWRnZXQgYWRkZWQgKCByZW1vdmFibGUgKSByb3dzIC0gZml4ZXMgIzQ0OCB0aGFua3MgdG8gQGhlbXBlbCFcclxuXHRcdFx0XHQvLyAkcm93cyA9ICR0Ym9keS5jaGlsZHJlbiggJ3RyJyApLm5vdCggYy5zZWxlY3RvclJlbW92ZSApO1xyXG5cdFx0XHRcdGNvbHVtbkluZGV4ID0gYy5jb2x1bW5zO1xyXG5cdFx0XHRcdC8vIGNvbnZlcnQgc3RvcmVkIHJvd3MgaW50byBhIGpRdWVyeSBvYmplY3RcclxuXHRcdFx0XHRub3JtX3Jvd3MgPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0ubm9ybWFsaXplZDtcclxuXHRcdFx0XHQkcm93cyA9ICQoICQubWFwKCBub3JtX3Jvd3MsIGZ1bmN0aW9uKCBlbCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBlbFsgY29sdW1uSW5kZXggXS4kcm93LmdldCgpO1xyXG5cdFx0XHRcdH0pICk7XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudEZpbHRlcnMuam9pbignJykgPT09ICcnIHx8IHdvLmZpbHRlcl9zZXJ2ZXJzaWRlRmlsdGVyaW5nICkge1xyXG5cdFx0XHRcdFx0JHJvd3NcclxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB3by5maWx0ZXJfZmlsdGVyZWRSb3cgKVxyXG5cdFx0XHRcdFx0XHQubm90KCAnLicgKyBjLmNzc0NoaWxkUm93IClcclxuXHRcdFx0XHRcdFx0LmNzcyggJ2Rpc3BsYXknLCAnJyApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBmaWx0ZXIgb3V0IGNoaWxkIHJvd3NcclxuXHRcdFx0XHRcdCRyb3dzID0gJHJvd3Mubm90KCAnLicgKyBjLmNzc0NoaWxkUm93ICk7XHJcblx0XHRcdFx0XHRsZW4gPSAkcm93cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIHdvLmZpbHRlcl8kYW55TWF0Y2ggJiYgd28uZmlsdGVyXyRhbnlNYXRjaC5sZW5ndGggKSB8fFxyXG5cdFx0XHRcdFx0XHR0eXBlb2YgZmlsdGVyc1tjLmNvbHVtbnNdICE9PSAndW5kZWZpbmVkJyApIHtcclxuXHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZsYWcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRkYXRhLmFueU1hdGNoRmlsdGVyID0gJycgKyAoXHJcblx0XHRcdFx0XHRcdFx0ZmlsdGVyc1sgYy5jb2x1bW5zIF0gfHxcclxuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfJGFueU1hdGNoICYmIHRzZi5nZXRMYXRlc3RTZWFyY2goIHdvLmZpbHRlcl8kYW55TWF0Y2ggKS52YWwoKSB8fFxyXG5cdFx0XHRcdFx0XHRcdCcnXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdGlmICggd28uZmlsdGVyX2NvbHVtbkFueU1hdGNoICkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHNwZWNpZmljIGNvbHVtbnMgc2VhcmNoXHJcblx0XHRcdFx0XHRcdFx0cXVlcnkgPSBkYXRhLmFueU1hdGNoRmlsdGVyLnNwbGl0KCB0c2ZSZWdleC5hbmRTcGxpdCApO1xyXG5cdFx0XHRcdFx0XHRcdGluamVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBxdWVyeS5sZW5ndGg7IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJlcyA9IHF1ZXJ5WyBpbmR4IF0uc3BsaXQoICc6JyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29sdW1uIGEgb25lLWJhc2VkIGluZGV4ICggbm9uLWRldmVsb3BlcnMgc3RhcnQgY291bnRpbmcgZnJvbSBvbmUgOlAgKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzTmFOKCByZXNbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goIGMuaGVhZGVyQ29udGVudCwgZnVuY3Rpb24oIGksIHR4dCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIG11bHRpcGxlIG1hdGNoZXMgYXJlIHBvc3NpYmxlXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHR4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoIHJlc1swXSApID4gLTEgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkID0gaTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyc1sgaWQgXSA9IHJlc1sxXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZCA9IHBhcnNlSW50KCByZXNbMF0sIDEwICkgLSAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaWQgPj0gMCAmJiBpZCA8IGMuY29sdW1ucyApIHsgLy8gaWYgaWQgaXMgYW4gaW50ZWdlclxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcnNbIGlkIF0gPSByZXNbMV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cXVlcnkuc3BsaWNlKCBpbmR4LCAxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5keC0tO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGluamVjdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGluamVjdGVkICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA9IHF1ZXJ5LmpvaW4oICcgJiYgJyApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIG9wdGltaXplIHNlYXJjaGluZyBvbmx5IHRocm91Z2ggYWxyZWFkeSBmaWx0ZXJlZCByb3dzIC0gc2VlICMzMTNcclxuXHRcdFx0XHRcdHNlYXJjaEZpbHRlcmVkID0gd28uZmlsdGVyX3NlYXJjaEZpbHRlcmVkO1xyXG5cdFx0XHRcdFx0bGFzdFNlYXJjaCA9IGMubGFzdFNlYXJjaCB8fCBjLiR0YWJsZS5kYXRhKCAnbGFzdFNlYXJjaCcgKSB8fCBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VhcmNoRmlsdGVyZWQgKSB7XHJcblx0XHRcdFx0XHRcdC8vIGN5Y2xlIHRocm91Z2ggYWxsIGZpbHRlcnM7IGluY2x1ZGUgbGFzdCAoIGNvbHVtbkluZGV4ICsgMSA9IG1hdGNoIGFueSBjb2x1bW4gKS4gRml4ZXMgIzY2OVxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGNvbHVtbkluZGV4ICsgMTsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhbCA9IGZpbHRlcnNbaW5keF0gfHwgJyc7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYnJlYWsgb3V0IG9mIGxvb3AgaWYgd2UndmUgYWxyZWFkeSBkZXRlcm1pbmVkIG5vdCB0byBzZWFyY2ggZmlsdGVyZWQgcm93c1xyXG5cdFx0XHRcdFx0XHRcdGlmICggIXNlYXJjaEZpbHRlcmVkICkgeyBpbmR4ID0gY29sdW1uSW5kZXg7IH1cclxuXHRcdFx0XHRcdFx0XHQvLyBzZWFyY2ggYWxyZWFkeSBmaWx0ZXJlZCByb3dzIGlmLi4uXHJcblx0XHRcdFx0XHRcdFx0c2VhcmNoRmlsdGVyZWQgPSBzZWFyY2hGaWx0ZXJlZCAmJiBsYXN0U2VhcmNoLmxlbmd0aCAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhlcmUgYXJlIG5vIGNoYW5nZXMgZnJvbSBiZWdpbm5pbmcgb2YgZmlsdGVyXHJcblx0XHRcdFx0XHRcdFx0XHR2YWwuaW5kZXhPZiggbGFzdFNlYXJjaFtpbmR4XSB8fCAnJyApID09PSAwICYmXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBOT1QgYSBsb2dpY2FsICdvcicsIG9yIHJhbmdlICggJ3RvJyBvciAnLScgKSBpbiB0aGUgc3RyaW5nXHJcblx0XHRcdFx0XHRcdFx0XHQhdHNmUmVnZXguYWxyZWFkeUZpbHRlcmVkLnRlc3QoIHZhbCApICYmXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGV4YWN0IG1hdGNoZXMsIHVzaW5nICd8JyAoIGxvZ2ljYWwgb3IgKSBvciBub3QgJyEnXHJcblx0XHRcdFx0XHRcdFx0XHQhdHNmUmVnZXguZXhhY3RUZXN0LnRlc3QoIHZhbCApICYmXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBkb24ndCBzZWFyY2ggb25seSBmaWx0ZXJlZCBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcclxuXHRcdFx0XHRcdFx0XHRcdC8vICggJz4gLTEwJyA9PiAnPiAtMTAwJyB3aWxsIGlnbm9yZSBoaWRkZW4gcm93cyApXHJcblx0XHRcdFx0XHRcdFx0XHQhKCB0c2ZSZWdleC5pc05lZzEudGVzdCggdmFsICkgfHwgdHNmUmVnZXguaXNOZWcyLnRlc3QoIHZhbCApICkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIGZpbHRlcmluZyB1c2luZyBhIHNlbGVjdCB3aXRob3V0IGEgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgKCBleGFjdCBtYXRjaCApIC0gZml4ZXMgIzU5M1xyXG5cdFx0XHRcdFx0XHRcdFx0ISggdmFsICE9PSAnJyAmJiBjLiRmaWx0ZXJzICYmIGMuJGZpbHRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGluZHggKyAnXCJdJyApLmZpbmQoICdzZWxlY3QnICkubGVuZ3RoICYmXHJcblx0XHRcdFx0XHRcdFx0XHRcdCF0c2YubWF0Y2hUeXBlKCBjLCBpbmR4ICkgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bm90RmlsdGVyZWQgPSAkcm93cy5ub3QoICcuJyArIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApLmxlbmd0aDtcclxuXHRcdFx0XHRcdC8vIGNhbid0IHNlYXJjaCB3aGVuIGFsbCByb3dzIGFyZSBoaWRkZW4gLSB0aGlzIGhhcHBlbnMgd2hlbiBsb29raW5nIGZvciBleGFjdCBtYXRjaGVzXHJcblx0XHRcdFx0XHRpZiAoIHNlYXJjaEZpbHRlcmVkICYmIG5vdEZpbHRlcmVkID09PSAwICkgeyBzZWFyY2hGaWx0ZXJlZCA9IGZhbHNlOyB9XHJcblx0XHRcdFx0XHRpZiAoIGRlYnVnICkge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0ZpbHRlciA+PiBTZWFyY2hpbmcgdGhyb3VnaCAnICtcclxuXHRcdFx0XHRcdFx0XHQoIHNlYXJjaEZpbHRlcmVkICYmIG5vdEZpbHRlcmVkIDwgbGVuID8gbm90RmlsdGVyZWQgOiAnYWxsJyApICsgJyByb3dzJyApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmFueU1hdGNoRmxhZyApIHtcclxuXHRcdFx0XHRcdFx0aWYgKCBjLnNvcnRMb2NhbGVDb21wYXJlICkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHJlcGxhY2UgYWNjZW50c1xyXG5cdFx0XHRcdFx0XHRcdGRhdGEuYW55TWF0Y2hGaWx0ZXIgPSB0cy5yZXBsYWNlQWNjZW50cyggZGF0YS5hbnlNYXRjaEZpbHRlciApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICggd28uZmlsdGVyX2RlZmF1bHRGaWx0ZXIgJiYgdHNmUmVnZXguaVF1ZXJ5LnRlc3QoIHZhcnMuZGVmYXVsdEFueUZpbHRlciApICkge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGEuYW55TWF0Y2hGaWx0ZXIgPSB0c2YuZGVmYXVsdEZpbHRlciggZGF0YS5hbnlNYXRjaEZpbHRlciwgdmFycy5kZWZhdWx0QW55RmlsdGVyICk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY2xlYXIgc2VhcmNoIGZpbHRlcmVkIGZsYWcgYmVjYXVzZSBkZWZhdWx0IGZpbHRlcnMgYXJlIG5vdCBzYXZlZCB0byB0aGUgbGFzdCBzZWFyY2hcclxuXHRcdFx0XHRcdFx0XHRzZWFyY2hGaWx0ZXJlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIG1ha2UgaUFueU1hdGNoRmlsdGVyIGxvd2VyY2FzZSB1bmxlc3MgYm90aCBmaWx0ZXIgd2lkZ2V0ICYgY29yZSBpZ25vcmVDYXNlIG9wdGlvbnMgYXJlIHRydWVcclxuXHRcdFx0XHRcdFx0Ly8gd2hlbiBjLmlnbm9yZUNhc2UgaXMgdHJ1ZSwgdGhlIGNhY2hlIGNvbnRhaW5zIGFsbCBsb3dlciBjYXNlIGRhdGFcclxuXHRcdFx0XHRcdFx0ZGF0YS5pQW55TWF0Y2hGaWx0ZXIgPSAhKCB3by5maWx0ZXJfaWdub3JlQ2FzZSAmJiBjLmlnbm9yZUNhc2UgKSA/XHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA6XHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlci50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCB0aGUgcm93c1xyXG5cdFx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGxlbjsgcm93SW5kZXgrKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHR4dCA9ICRyb3dzWyByb3dJbmRleCBdLmNsYXNzTmFtZTtcclxuXHRcdFx0XHRcdFx0Ly8gdGhlIGZpcnN0IHJvdyBjYW4gbmV2ZXIgYmUgYSBjaGlsZCByb3dcclxuXHRcdFx0XHRcdFx0aXNDaGlsZCA9IHJvd0luZGV4ICYmIHRzZlJlZ2V4LmNoaWxkLnRlc3QoIHR4dCApO1xyXG5cdFx0XHRcdFx0XHQvLyBza2lwIGNoaWxkIHJvd3MgJiBhbHJlYWR5IGZpbHRlcmVkIHJvd3NcclxuXHRcdFx0XHRcdFx0aWYgKCBpc0NoaWxkIHx8ICggc2VhcmNoRmlsdGVyZWQgJiYgdHNmUmVnZXguZmlsdGVyZWQudGVzdCggdHh0ICkgKSApIHtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0ZGF0YS4kcm93ID0gJHJvd3MuZXEoIHJvd0luZGV4ICk7XHJcblx0XHRcdFx0XHRcdGRhdGEucm93SW5kZXggPSByb3dJbmRleDtcclxuXHRcdFx0XHRcdFx0ZGF0YS5jYWNoZUFycmF5ID0gbm9ybV9yb3dzWyByb3dJbmRleCBdO1xyXG5cdFx0XHRcdFx0XHRyb3dEYXRhID0gZGF0YS5jYWNoZUFycmF5WyBjLmNvbHVtbnMgXTtcclxuXHRcdFx0XHRcdFx0ZGF0YS5yYXdBcnJheSA9IHJvd0RhdGEucmF3O1xyXG5cdFx0XHRcdFx0XHRkYXRhLmNoaWxkUm93VGV4dCA9ICcnO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2NoaWxkQnlDb2x1bW4gKSB7XHJcblx0XHRcdFx0XHRcdFx0dHh0ID0gJyc7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY2hpbGQgcm93IGNhY2hlZCB0ZXh0XHJcblx0XHRcdFx0XHRcdFx0Y2hpbGRSb3cgPSByb3dEYXRhLmNoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHNvLCBpZiAndGFibGUuY29uZmlnLndpZGdldE9wdGlvbnMuZmlsdGVyX2NoaWxkUm93cycgaXMgdHJ1ZSBhbmQgdGhlcmUgaXNcclxuXHRcdFx0XHRcdFx0XHQvLyBhIG1hdGNoIGFueXdoZXJlIGluIHRoZSBjaGlsZCByb3csIHRoZW4gaXQgd2lsbCBtYWtlIHRoZSByb3cgdmlzaWJsZVxyXG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrZWQgaGVyZSBzbyB0aGUgb3B0aW9uIGNhbiBiZSBjaGFuZ2VkIGR5bmFtaWNhbGx5XHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjaGlsZFJvdy5sZW5ndGg7IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHR4dCArPSAnICcgKyBjaGlsZFJvd1tpbmR4XS5qb2luKCAnICcgKSB8fCAnJztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5jaGlsZFJvd1RleHQgPSB3by5maWx0ZXJfY2hpbGRSb3dzID9cclxuXHRcdFx0XHRcdFx0XHRcdCggd28uZmlsdGVyX2lnbm9yZUNhc2UgPyB0eHQudG9Mb3dlckNhc2UoKSA6IHR4dCApIDpcclxuXHRcdFx0XHRcdFx0XHRcdCcnO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzaG93Um93ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdHNob3dQYXJlbnQgPSB0c2YucHJvY2Vzc1JvdyggYywgZGF0YSwgdmFycyApO1xyXG5cdFx0XHRcdFx0XHQkcm93ID0gcm93RGF0YS4kcm93O1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgcGFzcyByZWZlcmVuY2UgdG8gdmFsXHJcblx0XHRcdFx0XHRcdHZhbCA9IHNob3dQYXJlbnQgPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdFx0XHRcdGNoaWxkUm93ID0gcm93RGF0YS4kcm93LmZpbHRlciggJzpndCgwKScgKTtcclxuXHRcdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfY2hpbGRSb3dzICYmIGNoaWxkUm93Lmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9jaGlsZEJ5Q29sdW1uICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2NoaWxkV2l0aFNpYnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGhpZGUgYWxsIGNoaWxkIHJvd3NcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGRSb3cuYWRkQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiBvbmx5IHNob3dpbmcgcmVzdWx0aW5nIGNoaWxkIHJvdywgb25seSBpbmNsdWRlIHBhcmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQkcm93ID0gJHJvdy5lcSggMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY3ljbGUgdGhyb3VnaCBlYWNoIGNoaWxkIHJvd1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjaGlsZFJvdy5sZW5ndGg7IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS4kcm93ID0gY2hpbGRSb3cuZXEoIGluZHggKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5jYWNoZUFycmF5ID0gcm93RGF0YS5jaGlsZFsgaW5keCBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhd0FycmF5ID0gZGF0YS5jYWNoZUFycmF5O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSB0c2YucHJvY2Vzc1JvdyggYywgZGF0YSwgdmFycyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB1c2UgT1IgY29tcGFyaXNvbiBvbiBjaGlsZCByb3dzXHJcblx0XHRcdFx0XHRcdFx0XHRcdHNob3dSb3cgPSBzaG93Um93IHx8IHZhbDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2NoaWxkV2l0aFNpYnMgJiYgdmFsICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkUm93LmVxKCBpbmR4ICkucmVtb3ZlQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdC8vIGtlZXAgcGFyZW50IHJvdyBtYXRjaCBldmVuIGlmIG5vIGNoaWxkIG1hdGNoZXMuLi4gc2VlICMxMDIwXHJcblx0XHRcdFx0XHRcdFx0c2hvd1JvdyA9IHNob3dSb3cgfHwgc2hvd1BhcmVudDtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzaG93Um93ID0gdmFsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdCRyb3dcclxuXHRcdFx0XHRcdFx0XHQudG9nZ2xlQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdywgIXNob3dSb3cgKVswXVxyXG5cdFx0XHRcdFx0XHRcdC5kaXNwbGF5ID0gc2hvd1JvdyA/ICcnIDogJ25vbmUnO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjLmZpbHRlcmVkUm93cyArPSAkcm93cy5ub3QoICcuJyArIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApLmxlbmd0aDtcclxuXHRcdFx0XHRjLnRvdGFsUm93cyArPSAkcm93cy5sZW5ndGg7XHJcblx0XHRcdFx0dHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJHRib2R5LCBmYWxzZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGxhc3RDb21iaW5lZEZpbHRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5XHJcblx0XHRcdGMubGFzdENvbWJpbmVkRmlsdGVyID0gc3RvcmVkRmlsdGVycy5qb2luKCcnKTsgLy8gc2F2ZSBsYXN0IHNlYXJjaFxyXG5cdFx0XHQvLyBkb24ndCBzYXZlICdmaWx0ZXJzJyBkaXJlY3RseSBzaW5jZSBpdCBtYXkgaGF2ZSBhbHRlcmVkICggQW55TWF0Y2ggY29sdW1uIHNlYXJjaGVzIClcclxuXHRcdFx0Yy5sYXN0U2VhcmNoID0gc3RvcmVkRmlsdGVycztcclxuXHRcdFx0Yy4kdGFibGUuZGF0YSggJ2xhc3RTZWFyY2gnLCBzdG9yZWRGaWx0ZXJzICk7XHJcblx0XHRcdGlmICggd28uZmlsdGVyX3NhdmVGaWx0ZXJzICYmIHRzLnN0b3JhZ2UgKSB7XHJcblx0XHRcdFx0dHMuc3RvcmFnZSggdGFibGUsICd0YWJsZXNvcnRlci1maWx0ZXJzJywgdHNmLnByb2Nlc3NGaWx0ZXJzKCBzdG9yZWRGaWx0ZXJzLCB0cnVlICkgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIGRlYnVnICkge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnRmlsdGVyID4+IENvbXBsZXRlZCBzZWFyY2gnICsgdHMuYmVuY2htYXJrKHRpbWUpICk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XHJcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJCZWZvcmVFbmQnLCBjICk7XHJcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJFbmQnLCBjICk7XHJcblx0XHRcdH1cclxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dHMuYXBwbHlXaWRnZXQoIGMudGFibGUgKTsgLy8gbWFrZSBzdXJlIHplYnJhIHdpZGdldCBpcyBhcHBsaWVkXHJcblx0XHRcdH0sIDAgKTtcclxuXHRcdH0sXHJcblx0XHRnZXRPcHRpb25Tb3VyY2U6IGZ1bmN0aW9uKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKSB7XHJcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVswXTtcclxuXHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0YXJyeSA9IGZhbHNlLFxyXG5cdFx0XHRcdHNvdXJjZSA9IHdvLmZpbHRlcl9zZWxlY3RTb3VyY2UsXHJcblx0XHRcdFx0bGFzdCA9IGMuJHRhYmxlLmRhdGEoICdsYXN0U2VhcmNoJyApIHx8IFtdLFxyXG5cdFx0XHRcdGZ4biA9IHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0cnVlIDogdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHNvdXJjZSwgY29sdW1uICk7XHJcblxyXG5cdFx0XHRpZiAoIG9ubHlBdmFpbCAmJiBsYXN0W2NvbHVtbl0gIT09ICcnICkge1xyXG5cdFx0XHRcdG9ubHlBdmFpbCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBmaWx0ZXIgc2VsZWN0IHNvdXJjZSBvcHRpb25cclxuXHRcdFx0aWYgKCBmeG4gPT09IHRydWUgKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUkFMTCBzb3VyY2VcclxuXHRcdFx0XHRhcnJ5ID0gc291cmNlKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKTtcclxuXHRcdFx0fSBlbHNlIGlmICggZnhuIGluc3RhbmNlb2YgJCB8fCAoICQudHlwZSggZnhuICkgPT09ICdzdHJpbmcnICYmIGZ4bi5pbmRleE9mKCAnPC9vcHRpb24+JyApID49IDAgKSApIHtcclxuXHRcdFx0XHQvLyBzZWxlY3RTb3VyY2UgaXMgYSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiBvcHRpb25zXHJcblx0XHRcdFx0cmV0dXJuIGZ4bjtcclxuXHRcdFx0fSBlbHNlIGlmICggJC5pc0FycmF5KCBmeG4gKSApIHtcclxuXHRcdFx0XHRhcnJ5ID0gZnhuO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCAkLnR5cGUoIHNvdXJjZSApID09PSAnb2JqZWN0JyAmJiBmeG4gKSB7XHJcblx0XHRcdFx0Ly8gY3VzdG9tIHNlbGVjdCBzb3VyY2UgZnVuY3Rpb24gZm9yIGEgU1BFQ0lGSUMgQ09MVU1OXHJcblx0XHRcdFx0YXJyeSA9IGZ4biggdGFibGUsIGNvbHVtbiwgb25seUF2YWlsICk7XHJcblx0XHRcdFx0Ly8gYWJvcnQgLSB1cGRhdGluZyB0aGUgc2VsZWN0cyBmcm9tIGFuIGV4dGVybmFsIG1ldGhvZFxyXG5cdFx0XHRcdGlmIChhcnJ5ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCBhcnJ5ID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gb3JpZ2luYWwgbWV0aG9kXHJcblx0XHRcdFx0YXJyeSA9IHRzZi5nZXRPcHRpb25zKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRzZi5wcm9jZXNzT3B0aW9ucyggdGFibGUsIGNvbHVtbiwgYXJyeSApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24oIHRhYmxlLCBjb2x1bW4sIGFycnkgKSB7XHJcblx0XHRcdGlmICggISQuaXNBcnJheSggYXJyeSApICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbMF07XHJcblx0XHRcdHZhciBjdHMsIHR4dCwgaW5keCwgbGVuLCBwYXJzZWRUeHQsIHN0cixcclxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxyXG5cdFx0XHRcdHZhbGlkQ29sdW1uID0gdHlwZW9mIGNvbHVtbiAhPT0gJ3VuZGVmaW5lZCcgJiYgY29sdW1uICE9PSBudWxsICYmIGNvbHVtbiA+PSAwICYmIGNvbHVtbiA8IGMuY29sdW1ucyxcclxuXHRcdFx0XHRkaXJlY3Rpb24gPSB2YWxpZENvbHVtbiA/IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLmhhc0NsYXNzKCAnZmlsdGVyLXNlbGVjdC1zb3J0LWRlc2MnICkgOiBmYWxzZSxcclxuXHRcdFx0XHRwYXJzZWQgPSBbXTtcclxuXHRcdFx0Ly8gZ2V0IHVuaXF1ZSBlbGVtZW50cyBhbmQgc29ydCB0aGUgbGlzdFxyXG5cdFx0XHQvLyBpZiAkLnRhYmxlc29ydGVyLnNvcnRUZXh0IGV4aXN0cyAoIG5vdCBpbiB0aGUgb3JpZ2luYWwgdGFibGVzb3J0ZXIgKSxcclxuXHRcdFx0Ly8gdGhlbiBuYXR1cmFsIHNvcnQgdGhlIGxpc3Qgb3RoZXJ3aXNlIHVzZSBhIGJhc2ljIHNvcnRcclxuXHRcdFx0YXJyeSA9ICQuZ3JlcCggYXJyeSwgZnVuY3Rpb24oIHZhbHVlLCBpbmR4ICkge1xyXG5cdFx0XHRcdGlmICggdmFsdWUudGV4dCApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB2YWx1ZSwgYXJyeSApID09PSBpbmR4O1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKCB2YWxpZENvbHVtbiAmJiBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXS5oYXNDbGFzcyggJ2ZpbHRlci1zZWxlY3Qtbm9zb3J0JyApICkge1xyXG5cdFx0XHRcdC8vIHVuc29ydGVkIHNlbGVjdCBvcHRpb25zXHJcblx0XHRcdFx0cmV0dXJuIGFycnk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGVuID0gYXJyeS5sZW5ndGg7XHJcblx0XHRcdFx0Ly8gcGFyc2Ugc2VsZWN0IG9wdGlvbiB2YWx1ZXNcclxuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0dHh0ID0gYXJyeVsgaW5keCBdO1xyXG5cdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIG9iamVjdFxyXG5cdFx0XHRcdFx0c3RyID0gdHh0LnRleHQgPyB0eHQudGV4dCA6IHR4dDtcclxuXHRcdFx0XHRcdC8vIHNvcnROYXR1cmFsIGJyZWFrcyBpZiB5b3UgZG9uJ3QgcGFzcyBpdCBzdHJpbmdzXHJcblx0XHRcdFx0XHRwYXJzZWRUeHQgPSAoIHZhbGlkQ29sdW1uICYmIGMucGFyc2VycyAmJiBjLnBhcnNlcnMubGVuZ3RoICYmXHJcblx0XHRcdFx0XHRcdGMucGFyc2Vyc1sgY29sdW1uIF0uZm9ybWF0KCBzdHIsIHRhYmxlLCBbXSwgY29sdW1uICkgfHwgc3RyICkudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdHBhcnNlZFR4dCA9IGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaWdub3JlQ2FzZSA/IHBhcnNlZFR4dC50b0xvd2VyQ2FzZSgpIDogcGFyc2VkVHh0O1xyXG5cdFx0XHRcdFx0Ly8gcGFyc2UgYXJyYXkgZGF0YSB1c2luZyBzZXQgY29sdW1uIHBhcnNlcjsgdGhpcyBET0VTIE5PVCBwYXNzIHRoZSBvcmlnaW5hbFxyXG5cdFx0XHRcdFx0Ly8gdGFibGUgY2VsbCB0byB0aGUgcGFyc2VyIGZvcm1hdCBmdW5jdGlvblxyXG5cdFx0XHRcdFx0aWYgKCB0eHQudGV4dCApIHtcclxuXHRcdFx0XHRcdFx0dHh0LnBhcnNlZCA9IHBhcnNlZFR4dDtcclxuXHRcdFx0XHRcdFx0cGFyc2VkWyBwYXJzZWQubGVuZ3RoIF0gPSB0eHQ7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwYXJzZWRbIHBhcnNlZC5sZW5ndGggXSA9IHtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0IDogdHh0LFxyXG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIHBhcnNlciBsZW5ndGggLSBmaXhlcyAjOTM0XHJcblx0XHRcdFx0XHRcdFx0cGFyc2VkIDogcGFyc2VkVHh0XHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHNvcnQgcGFyc2VkIHNlbGVjdCBvcHRpb25zXHJcblx0XHRcdFx0Y3RzID0gYy50ZXh0U29ydGVyIHx8ICcnO1xyXG5cdFx0XHRcdHBhcnNlZC5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcclxuXHRcdFx0XHRcdHZhciB4ID0gZGlyZWN0aW9uID8gYi5wYXJzZWQgOiBhLnBhcnNlZCxcclxuXHRcdFx0XHRcdFx0eSA9IGRpcmVjdGlvbiA/IGEucGFyc2VkIDogYi5wYXJzZWQ7XHJcblx0XHRcdFx0XHRpZiAoIHZhbGlkQ29sdW1uICYmIHR5cGVvZiBjdHMgPT09ICdmdW5jdGlvbicgKSB7XHJcblx0XHRcdFx0XHRcdC8vIGN1c3RvbSBPVkVSQUxMIHRleHQgc29ydGVyXHJcblx0XHRcdFx0XHRcdHJldHVybiBjdHMoIHgsIHksIHRydWUsIGNvbHVtbiwgdGFibGUgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHZhbGlkQ29sdW1uICYmIHR5cGVvZiBjdHMgPT09ICdvYmplY3QnICYmIGN0cy5oYXNPd25Qcm9wZXJ0eSggY29sdW1uICkgKSB7XHJcblx0XHRcdFx0XHRcdC8vIGN1c3RvbSB0ZXh0IHNvcnRlciBmb3IgYSBTUEVDSUZJQyBDT0xVTU5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGN0c1tjb2x1bW5dKCB4LCB5LCB0cnVlLCBjb2x1bW4sIHRhYmxlICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0cy5zb3J0TmF0dXJhbCApIHtcclxuXHRcdFx0XHRcdFx0Ly8gZmFsbCBiYWNrIHRvIG5hdHVyYWwgc29ydFxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHMuc29ydE5hdHVyYWwoIHgsIHkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHVzaW5nIGFuIG9sZGVyIHZlcnNpb24hIGRvIGEgYmFzaWMgc29ydFxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0Ly8gcmVidWlsZCBhcnJ5IGZyb20gc29ydGVkIHBhcnNlZCBkYXRhXHJcblx0XHRcdFx0YXJyeSA9IFtdO1xyXG5cdFx0XHRcdGxlbiA9IHBhcnNlZC5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcclxuXHRcdFx0XHRcdGFycnlbIGFycnkubGVuZ3RoIF0gPSBwYXJzZWRbaW5keF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBhcnJ5O1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24oIHRhYmxlLCBjb2x1bW4sIG9ubHlBdmFpbCApIHtcclxuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWzBdO1xyXG5cdFx0XHR2YXIgcm93SW5kZXgsIHRib2R5SW5kZXgsIGxlbiwgcm93LCBjYWNoZSwgaW5keCwgY2hpbGQsIGNoaWxkTGVuLFxyXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0YXJyeSA9IFtdO1xyXG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8IGMuJHRib2RpZXMubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XHJcblx0XHRcdFx0Y2FjaGUgPSBjLmNhY2hlW3Rib2R5SW5kZXhdO1xyXG5cdFx0XHRcdGxlbiA9IGMuY2FjaGVbdGJvZHlJbmRleF0ubm9ybWFsaXplZC5sZW5ndGg7XHJcblx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSByb3dzXHJcblx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGxlbjsgcm93SW5kZXgrKyApIHtcclxuXHRcdFx0XHRcdC8vIGdldCBjYWNoZWQgcm93IGZyb20gY2FjaGUucm93ICggb2xkICkgb3Igcm93IGRhdGEgb2JqZWN0XHJcblx0XHRcdFx0XHQvLyAoIG5ldzsgbGFzdCBpdGVtIGluIG5vcm1hbGl6ZWQgYXJyYXkgKVxyXG5cdFx0XHRcdFx0cm93ID0gY2FjaGUucm93ID9cclxuXHRcdFx0XHRcdFx0Y2FjaGUucm93WyByb3dJbmRleCBdIDpcclxuXHRcdFx0XHRcdFx0Y2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvd1swXTtcclxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGhhcyBjbGFzcyBmaWx0ZXJlZFxyXG5cdFx0XHRcdFx0aWYgKCBvbmx5QXZhaWwgJiYgcm93LmNsYXNzTmFtZS5tYXRjaCggd28uZmlsdGVyX2ZpbHRlcmVkUm93ICkgKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gZ2V0IG5vbi1ub3JtYWxpemVkIGNlbGwgY29udGVudFxyXG5cdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfdXNlUGFyc2VkRGF0YSB8fFxyXG5cdFx0XHRcdFx0XHRjLnBhcnNlcnNbY29sdW1uXS5wYXJzZWQgfHxcclxuXHRcdFx0XHRcdFx0Yy4kaGVhZGVySW5kZXhlZFtjb2x1bW5dLmhhc0NsYXNzKCAnZmlsdGVyLXBhcnNlZCcgKSApIHtcclxuXHRcdFx0XHRcdFx0YXJyeVsgYXJyeS5sZW5ndGggXSA9ICcnICsgY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgY29sdW1uIF07XHJcblx0XHRcdFx0XHRcdC8vIGNoaWxkIHJvdyBwYXJzZWQgZGF0YVxyXG5cdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9jaGlsZFJvd3MgJiYgd28uZmlsdGVyX2NoaWxkQnlDb2x1bW4gKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2hpbGRMZW4gPSBjYWNoZS5ub3JtYWxpemVkWyByb3dJbmRleCBdWyBjLmNvbHVtbnMgXS4kcm93Lmxlbmd0aCAtIDE7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjaGlsZExlbjsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YXJyeVsgYXJyeS5sZW5ndGggXSA9ICcnICsgY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uY2hpbGRbIGluZHggXVsgY29sdW1uIF07XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBnZXQgcmF3IGNhY2hlZCBkYXRhIGluc3RlYWQgb2YgY29udGVudCBkaXJlY3RseSBmcm9tIHRoZSBjZWxsc1xyXG5cdFx0XHRcdFx0XHRhcnJ5WyBhcnJ5Lmxlbmd0aCBdID0gY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0ucmF3WyBjb2x1bW4gXTtcclxuXHRcdFx0XHRcdFx0Ly8gY2hpbGQgcm93IHVucGFyc2VkIGRhdGFcclxuXHRcdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfY2hpbGRSb3dzICYmIHdvLmZpbHRlcl9jaGlsZEJ5Q29sdW1uICkge1xyXG5cdFx0XHRcdFx0XHRcdGNoaWxkTGVuID0gY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvdy5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDE7IGluZHggPCBjaGlsZExlbjsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQgPSAgY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvdy5lcSggaW5keCApLmNoaWxkcmVuKCkuZXEoIGNvbHVtbiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YXJyeVsgYXJyeS5sZW5ndGggXSA9ICcnICsgdHMuZ2V0RWxlbWVudFRleHQoIGMsIGNoaWxkLCBjb2x1bW4gKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGFycnk7XHJcblx0XHR9LFxyXG5cdFx0YnVpbGRTZWxlY3Q6IGZ1bmN0aW9uKCB0YWJsZSwgY29sdW1uLCBhcnJ5LCB1cGRhdGluZywgb25seUF2YWlsICkge1xyXG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbMF07XHJcblx0XHRcdGNvbHVtbiA9IHBhcnNlSW50KCBjb2x1bW4sIDEwICk7XHJcblx0XHRcdGlmICggIXRhYmxlLmNvbmZpZy5jYWNoZSB8fCAkLmlzRW1wdHlPYmplY3QoIHRhYmxlLmNvbmZpZy5jYWNoZSApICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGluZHgsIHZhbCwgdHh0LCB0LCAkZmlsdGVycywgJGZpbHRlciwgb3B0aW9uLFxyXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0bm9kZSA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLFxyXG5cdFx0XHRcdC8vIHQuZGF0YSggJ3BsYWNlaG9sZGVyJyApIHdvbid0IHdvcmsgaW4galF1ZXJ5IG9sZGVyIHRoYW4gMS40LjNcclxuXHRcdFx0XHRvcHRpb25zID0gJzxvcHRpb24gdmFsdWU9XCJcIj4nICtcclxuXHRcdFx0XHRcdCggbm9kZS5kYXRhKCAncGxhY2Vob2xkZXInICkgfHxcclxuXHRcdFx0XHRcdFx0bm9kZS5hdHRyKCAnZGF0YS1wbGFjZWhvbGRlcicgKSB8fFxyXG5cdFx0XHRcdFx0XHR3by5maWx0ZXJfcGxhY2Vob2xkZXIuc2VsZWN0IHx8ICcnXHJcblx0XHRcdFx0XHQpICsgJzwvb3B0aW9uPicsXHJcblx0XHRcdFx0Ly8gR2V0IGN1cmVudCBmaWx0ZXIgdmFsdWVcclxuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBjLiR0YWJsZVxyXG5cdFx0XHRcdFx0LmZpbmQoICd0aGVhZCcgKVxyXG5cdFx0XHRcdFx0LmZpbmQoICdzZWxlY3QuJyArIHRzY3NzLmZpbHRlciArICdbZGF0YS1jb2x1bW49XCInICsgY29sdW1uICsgJ1wiXScgKVxyXG5cdFx0XHRcdFx0LnZhbCgpO1xyXG5cclxuXHRcdFx0Ly8gbm90aGluZyBpbmNsdWRlZCBpbiBhcnJ5ICggZXh0ZXJuYWwgc291cmNlICksIHNvIGdldCB0aGUgb3B0aW9ucyBmcm9tXHJcblx0XHRcdC8vIGZpbHRlcl9zZWxlY3RTb3VyY2Ugb3IgY29sdW1uIGRhdGFcclxuXHRcdFx0aWYgKCB0eXBlb2YgYXJyeSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJyeSA9PT0gJycgKSB7XHJcblx0XHRcdFx0YXJyeSA9IHRzZi5nZXRPcHRpb25Tb3VyY2UoIHRhYmxlLCBjb2x1bW4sIG9ubHlBdmFpbCApO1xyXG5cdFx0XHRcdC8vIGFib3J0LCBzZWxlY3RzIGFyZSB1cGRhdGVkIGJ5IGFuIGV4dGVybmFsIG1ldGhvZFxyXG5cdFx0XHRcdGlmIChhcnJ5ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICQuaXNBcnJheSggYXJyeSApICkge1xyXG5cdFx0XHRcdC8vIGJ1aWxkIG9wdGlvbiBsaXN0XHJcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBhcnJ5Lmxlbmd0aDsgaW5keCsrICkge1xyXG5cdFx0XHRcdFx0b3B0aW9uID0gYXJyeVsgaW5keCBdO1xyXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24udGV4dCApIHtcclxuXHRcdFx0XHRcdFx0Ly8gT0JKRUNUISEgYWRkIGRhdGEtZnVuY3Rpb24tbmFtZSBpbiBjYXNlIHRoZSB2YWx1ZSBpcyBzZXQgaW4gZmlsdGVyX2Z1bmN0aW9uc1xyXG5cdFx0XHRcdFx0XHRvcHRpb25bJ2RhdGEtZnVuY3Rpb24tbmFtZSddID0gdHlwZW9mIG9wdGlvbi52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBvcHRpb24udGV4dCA6IG9wdGlvbi52YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHN1cHBvcnQgalF1ZXJ5IDwgdjEuOCwgb3RoZXJ3aXNlIHRoZSBiZWxvdyBjb2RlIGNvdWxkIGJlIHNob3J0ZW5lZCB0b1xyXG5cdFx0XHRcdFx0XHQvLyBvcHRpb25zICs9ICQoICc8b3B0aW9uPicsIG9wdGlvbiApWyAwIF0ub3V0ZXJIVE1MO1xyXG5cdFx0XHRcdFx0XHRvcHRpb25zICs9ICc8b3B0aW9uJztcclxuXHRcdFx0XHRcdFx0Zm9yICggdmFsIGluIG9wdGlvbiApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSggdmFsICkgJiYgdmFsICE9PSAndGV4dCcgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zICs9ICcgJyArIHZhbCArICc9XCInICsgb3B0aW9uWyB2YWwgXS5yZXBsYWNlKCB0c2ZSZWdleC5xdW90ZSwgJyZxdW90OycgKSArICdcIic7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICggIW9wdGlvbi52YWx1ZSApIHtcclxuXHRcdFx0XHRcdFx0XHRvcHRpb25zICs9ICcgdmFsdWU9XCInICsgb3B0aW9uLnRleHQucmVwbGFjZSggdHNmUmVnZXgucXVvdGUsICcmcXVvdDsnICkgKyAnXCInO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMgKz0gJz4nICsgb3B0aW9uLnRleHQucmVwbGFjZSggdHNmUmVnZXgucXVvdGUsICcmcXVvdDsnICkgKyAnPC9vcHRpb24+JztcclxuXHRcdFx0XHRcdFx0Ly8gYWJvdmUgY29kZSBpcyBuZWVkZWQgaW4galF1ZXJ5IDwgdjEuOFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHdlIGRvbid0IHR1cm4gYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgKG9iamVjdHMgd2l0aG91dCBhIFwidGV4dFwiIHByb3BlcnR5KVxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggJycgKyBvcHRpb24gIT09ICdbb2JqZWN0IE9iamVjdF0nICkge1xyXG5cdFx0XHRcdFx0XHR0eHQgPSBvcHRpb24gPSAoICcnICsgb3B0aW9uICkucmVwbGFjZSggdHNmUmVnZXgucXVvdGUsICcmcXVvdDsnICk7XHJcblx0XHRcdFx0XHRcdHZhbCA9IHR4dDtcclxuXHRcdFx0XHRcdFx0Ly8gYWxsb3cgaW5jbHVkaW5nIGEgc3ltYm9sIGluIHRoZSBzZWxlY3RTb3VyY2UgYXJyYXlcclxuXHRcdFx0XHRcdFx0Ly8gJ2EtenxBIHRocm91Z2ggWicgc28gdGhhdCAnYS16JyBiZWNvbWVzIHRoZSBvcHRpb24gdmFsdWVcclxuXHRcdFx0XHRcdFx0Ly8gYW5kICdBIHRocm91Z2ggWicgYmVjb21lcyB0aGUgb3B0aW9uIHRleHRcclxuXHRcdFx0XHRcdFx0aWYgKCB0eHQuaW5kZXhPZiggd28uZmlsdGVyX3NlbGVjdFNvdXJjZVNlcGFyYXRvciApID49IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0dCA9IHR4dC5zcGxpdCggd28uZmlsdGVyX3NlbGVjdFNvdXJjZVNlcGFyYXRvciApO1xyXG5cdFx0XHRcdFx0XHRcdHZhbCA9IHRbMF07XHJcblx0XHRcdFx0XHRcdFx0dHh0ID0gdFsxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyByZXBsYWNlIHF1b3RlcyAtIGZpeGVzICMyNDIgJiBpZ25vcmUgZW1wdHkgc3RyaW5nc1xyXG5cdFx0XHRcdFx0XHQvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTQ5OTA5NzEvMTQ1MzQ2XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMgKz0gb3B0aW9uICE9PSAnJyA/XHJcblx0XHRcdFx0XHRcdFx0JzxvcHRpb24gJyArXHJcblx0XHRcdFx0XHRcdFx0XHQoIHZhbCA9PT0gdHh0ID8gJycgOiAnZGF0YS1mdW5jdGlvbi1uYW1lPVwiJyArIG9wdGlvbiArICdcIiAnICkgK1xyXG5cdFx0XHRcdFx0XHRcdFx0J3ZhbHVlPVwiJyArIHZhbCArICdcIj4nICsgdHh0ICtcclxuXHRcdFx0XHRcdFx0XHQnPC9vcHRpb24+JyA6ICcnO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBjbGVhciBhcnJ5IHNvIGl0IGRvZXNuJ3QgZ2V0IGFwcGVuZGVkIHR3aWNlXHJcblx0XHRcdFx0YXJyeSA9IFtdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgYWxsIHNlbGVjdHMgaW4gdGhlIHNhbWUgY29sdW1uICggY2xvbmUgdGhlYWQgaW4gc3RpY2t5IGhlYWRlcnMgJlxyXG5cdFx0XHQvLyBhbnkgZXh0ZXJuYWwgc2VsZWN0cyApIC0gZml4ZXMgNDczXHJcblx0XHRcdCRmaWx0ZXJzID0gKCBjLiRmaWx0ZXJzID8gYy4kZmlsdGVycyA6IGMuJHRhYmxlLmNoaWxkcmVuKCAndGhlYWQnICkgKVxyXG5cdFx0XHRcdC5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXIgKTtcclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApIHtcclxuXHRcdFx0XHQkZmlsdGVycyA9ICRmaWx0ZXJzICYmICRmaWx0ZXJzLmxlbmd0aCA/XHJcblx0XHRcdFx0XHQkZmlsdGVycy5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzICkgOlxyXG5cdFx0XHRcdFx0d28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnM7XHJcblx0XHRcdH1cclxuXHRcdFx0JGZpbHRlciA9ICRmaWx0ZXJzLmZpbHRlciggJ3NlbGVjdFtkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCJdJyApO1xyXG5cclxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgc2VsZWN0IHRoZXJlIVxyXG5cdFx0XHRpZiAoICRmaWx0ZXIubGVuZ3RoICkge1xyXG5cdFx0XHRcdCRmaWx0ZXJbIHVwZGF0aW5nID8gJ2h0bWwnIDogJ2FwcGVuZCcgXSggb3B0aW9ucyApO1xyXG5cdFx0XHRcdGlmICggISQuaXNBcnJheSggYXJyeSApICkge1xyXG5cdFx0XHRcdFx0Ly8gYXBwZW5kIG9wdGlvbnMgaWYgYXJyeSBpcyBwcm92aWRlZCBleHRlcm5hbGx5IGFzIGEgc3RyaW5nIG9yIGpRdWVyeSBvYmplY3RcclxuXHRcdFx0XHRcdC8vIG9wdGlvbnMgKCBkZWZhdWx0IHZhbHVlICkgd2FzIGFscmVhZHkgYWRkZWRcclxuXHRcdFx0XHRcdCRmaWx0ZXIuYXBwZW5kKCBhcnJ5ICkudmFsKCBjdXJyZW50VmFsdWUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JGZpbHRlci52YWwoIGN1cnJlbnRWYWx1ZSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0YnVpbGREZWZhdWx0OiBmdW5jdGlvbiggdGFibGUsIHVwZGF0aW5nICkge1xyXG5cdFx0XHR2YXIgY29sdW1uSW5kZXgsICRoZWFkZXIsIG5vU2VsZWN0LFxyXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXHJcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXHJcblx0XHRcdFx0Y29sdW1ucyA9IGMuY29sdW1ucztcclxuXHRcdFx0Ly8gYnVpbGQgZGVmYXVsdCBzZWxlY3QgZHJvcGRvd25cclxuXHRcdFx0Zm9yICggY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGNvbHVtbnM7IGNvbHVtbkluZGV4KysgKSB7XHJcblx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbY29sdW1uSW5kZXhdO1xyXG5cdFx0XHRcdG5vU2VsZWN0ID0gISggJGhlYWRlci5oYXNDbGFzcyggJ2ZpbHRlci1mYWxzZScgKSB8fCAkaGVhZGVyLmhhc0NsYXNzKCAncGFyc2VyLWZhbHNlJyApICk7XHJcblx0XHRcdFx0Ly8gbG9vayBmb3IgdGhlIGZpbHRlci1zZWxlY3QgY2xhc3M7IGJ1aWxkL3VwZGF0ZSBpdCBpZiBmb3VuZFxyXG5cdFx0XHRcdGlmICggKCAkaGVhZGVyLmhhc0NsYXNzKCAnZmlsdGVyLXNlbGVjdCcgKSB8fFxyXG5cdFx0XHRcdFx0dHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9mdW5jdGlvbnMsIGNvbHVtbkluZGV4ICkgPT09IHRydWUgKSAmJiBub1NlbGVjdCApIHtcclxuXHRcdFx0XHRcdHRzZi5idWlsZFNlbGVjdCggdGFibGUsIGNvbHVtbkluZGV4LCAnJywgdXBkYXRpbmcsICRoZWFkZXIuaGFzQ2xhc3MoIHdvLmZpbHRlcl9vbmx5QXZhaWwgKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIGZpbHRlciByZWdleCB2YXJpYWJsZVxyXG5cdHRzZlJlZ2V4ID0gdHNmLnJlZ2V4O1xyXG5cclxuXHR0cy5nZXRGaWx0ZXJzID0gZnVuY3Rpb24oIHRhYmxlLCBnZXRSYXcsIHNldEZpbHRlcnMsIHNraXBGaXJzdCApIHtcclxuXHRcdHZhciBpLCAkZmlsdGVycywgJGNvbHVtbiwgY29scyxcclxuXHRcdFx0ZmlsdGVycyA9IFtdLFxyXG5cdFx0XHRjID0gdGFibGUgPyAkKCB0YWJsZSApWzBdLmNvbmZpZyA6ICcnLFxyXG5cdFx0XHR3byA9IGMgPyBjLndpZGdldE9wdGlvbnMgOiAnJztcclxuXHRcdGlmICggKCBnZXRSYXcgIT09IHRydWUgJiYgd28gJiYgIXdvLmZpbHRlcl9jb2x1bW5GaWx0ZXJzICkgfHxcclxuXHRcdFx0Ly8gc2V0RmlsdGVycyBjYWxsZWQsIGJ1dCBsYXN0IHNlYXJjaCBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XHJcblx0XHRcdC8vIGZpeGVzIGlzc3VlICM3MzMgJiAjOTAzIHdoZXJlIGNhbGxpbmcgdXBkYXRlIGNhdXNlcyB0aGUgaW5wdXQgdmFsdWVzIHRvIHJlc2V0XHJcblx0XHRcdCggJC5pc0FycmF5KHNldEZpbHRlcnMpICYmIHRzZi5lcXVhbEZpbHRlcnMoYywgc2V0RmlsdGVycywgYy5sYXN0U2VhcmNoKSApXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuICQoIHRhYmxlICkuZGF0YSggJ2xhc3RTZWFyY2gnICkgfHwgW107XHJcblx0XHR9XHJcblx0XHRpZiAoIGMgKSB7XHJcblx0XHRcdGlmICggYy4kZmlsdGVycyApIHtcclxuXHRcdFx0XHQkZmlsdGVycyA9IGMuJGZpbHRlcnMuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyICk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApIHtcclxuXHRcdFx0XHQkZmlsdGVycyA9ICRmaWx0ZXJzICYmICRmaWx0ZXJzLmxlbmd0aCA/XHJcblx0XHRcdFx0XHQkZmlsdGVycy5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzICkgOlxyXG5cdFx0XHRcdFx0d28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCAkZmlsdGVycyAmJiAkZmlsdGVycy5sZW5ndGggKSB7XHJcblx0XHRcdFx0ZmlsdGVycyA9IHNldEZpbHRlcnMgfHwgW107XHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjLmNvbHVtbnMgKyAxOyBpKysgKSB7XHJcblx0XHRcdFx0XHRjb2xzID0gKCBpID09PSBjLmNvbHVtbnMgP1xyXG5cdFx0XHRcdFx0XHQvLyAnYWxsJyBjb2x1bW5zIGNhbiBub3cgaW5jbHVkZSBhIHJhbmdlIG9yIHNldCBvZiBjb2x1bW1zICggZGF0YS1jb2x1bW49JzAtMiw0LDYtNycgKVxyXG5cdFx0XHRcdFx0XHR3by5maWx0ZXJfYW55Q29sdW1uU2VsZWN0b3IgKyAnLCcgKyB3by5maWx0ZXJfbXVsdGlwbGVDb2x1bW5TZWxlY3RvciA6XHJcblx0XHRcdFx0XHRcdCdbZGF0YS1jb2x1bW49XCInICsgaSArICdcIl0nICk7XHJcblx0XHRcdFx0XHQkY29sdW1uID0gJGZpbHRlcnMuZmlsdGVyKCBjb2xzICk7XHJcblx0XHRcdFx0XHRpZiAoICRjb2x1bW4ubGVuZ3RoICkge1xyXG5cdFx0XHRcdFx0XHQvLyBtb3ZlIHRoZSBsYXRlc3Qgc2VhcmNoIHRvIHRoZSBmaXJzdCBzbG90IGluIHRoZSBhcnJheVxyXG5cdFx0XHRcdFx0XHQkY29sdW1uID0gdHNmLmdldExhdGVzdFNlYXJjaCggJGNvbHVtbiApO1xyXG5cdFx0XHRcdFx0XHRpZiAoICQuaXNBcnJheSggc2V0RmlsdGVycyApICkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHNraXAgZmlyc3QgKCBsYXRlc3QgaW5wdXQgKSB0byBtYWludGFpbiBjdXJzb3IgcG9zaXRpb24gd2hpbGUgdHlwaW5nXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBza2lwRmlyc3QgJiYgJGNvbHVtbi5sZW5ndGggPiAxICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0JGNvbHVtbiA9ICRjb2x1bW4uc2xpY2UoIDEgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpID09PSBjLmNvbHVtbnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBwcmV2ZW50IGRhdGEtY29sdW1uPSdhbGwnIGZyb20gZmlsbGluZyBkYXRhLWNvbHVtbj0nMCwxJyAoIGV0YyApXHJcblx0XHRcdFx0XHRcdFx0XHRjb2xzID0gJGNvbHVtbi5maWx0ZXIoIHdvLmZpbHRlcl9hbnlDb2x1bW5TZWxlY3RvciApO1xyXG5cdFx0XHRcdFx0XHRcdFx0JGNvbHVtbiA9IGNvbHMubGVuZ3RoID8gY29scyA6ICRjb2x1bW47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdCRjb2x1bW5cclxuXHRcdFx0XHRcdFx0XHRcdC52YWwoIHNldEZpbHRlcnNbIGkgXSApXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBtdXN0IGluY2x1ZGUgYSBuYW1lc3BhY2UgaGVyZTsgYnV0IG5vdCBjLm5hbWVzcGFjZSArICdmaWx0ZXInP1xyXG5cdFx0XHRcdFx0XHRcdFx0LnRyaWdnZXIoICdjaGFuZ2UnICsgYy5uYW1lc3BhY2UgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJzW2ldID0gJGNvbHVtbi52YWwoKSB8fCAnJztcclxuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBjaGFuZ2UgdGhlIGZpcnN0Li4uIGl0IHdpbGwgbW92ZSB0aGUgY3Vyc29yXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpID09PSBjLmNvbHVtbnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBkb24ndCB1cGRhdGUgcmFuZ2UgY29sdW1ucyBmcm9tICdhbGwnIHNldHRpbmdcclxuXHRcdFx0XHRcdFx0XHRcdCRjb2x1bW5cclxuXHRcdFx0XHRcdFx0XHRcdFx0LnNsaWNlKCAxIClcclxuXHRcdFx0XHRcdFx0XHRcdFx0LmZpbHRlciggJ1tkYXRhLWNvbHVtbio9XCInICsgJGNvbHVtbi5hdHRyKCAnZGF0YS1jb2x1bW4nICkgKyAnXCJdJyApXHJcblx0XHRcdFx0XHRcdFx0XHRcdC52YWwoIGZpbHRlcnNbIGkgXSApO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHQkY29sdW1uXHJcblx0XHRcdFx0XHRcdFx0XHRcdC5zbGljZSggMSApXHJcblx0XHRcdFx0XHRcdFx0XHRcdC52YWwoIGZpbHRlcnNbIGkgXSApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyBzYXZlIGFueSBtYXRjaCBpbnB1dCBkeW5hbWljYWxseVxyXG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IGMuY29sdW1ucyAmJiAkY29sdW1uLmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfJGFueU1hdGNoID0gJGNvbHVtbjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZpbHRlcnM7XHJcblx0fTtcclxuXHJcblx0dHMuc2V0RmlsdGVycyA9IGZ1bmN0aW9uKCB0YWJsZSwgZmlsdGVyLCBhcHBseSwgc2tpcEZpcnN0ICkge1xyXG5cdFx0dmFyIGMgPSB0YWJsZSA/ICQoIHRhYmxlIClbMF0uY29uZmlnIDogJycsXHJcblx0XHRcdHZhbGlkID0gdHMuZ2V0RmlsdGVycyggdGFibGUsIHRydWUsIGZpbHRlciwgc2tpcEZpcnN0ICk7XHJcblx0XHQvLyBkZWZhdWx0IGFwcGx5IHRvIFwidHJ1ZVwiXHJcblx0XHRpZiAoIHR5cGVvZiBhcHBseSA9PT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0XHRcdGFwcGx5ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGlmICggYyAmJiBhcHBseSApIHtcclxuXHRcdFx0Ly8gZW5zdXJlIG5ldyBzZXQgZmlsdGVycyBhcmUgYXBwbGllZCwgZXZlbiBpZiB0aGUgc2VhcmNoIGlzIHRoZSBzYW1lXHJcblx0XHRcdGMubGFzdENvbWJpbmVkRmlsdGVyID0gbnVsbDtcclxuXHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XHJcblx0XHRcdHRzZi5zZWFyY2hpbmcoIGMudGFibGUsIGZpbHRlciwgc2tpcEZpcnN0ICk7XHJcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyRm9tYXR0ZXJVcGRhdGUnICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsaWQubGVuZ3RoICE9PSAwO1xyXG5cdH07XHJcblxyXG59KSggalF1ZXJ5ICk7XHJcblxyXG4vKiEgV2lkZ2V0OiBzdGlja3lIZWFkZXJzIC0gdXBkYXRlZCA5LzI3LzIwMTcgKHYyLjI5LjApICovLypcbiAqIFJlcXVpcmVzIHRhYmxlc29ydGVyIHYyLjgrIGFuZCBqUXVlcnkgMS40LjMrXG4gKiBieSBSb2IgR2Fycmlzb25cbiAqL1xuOyhmdW5jdGlvbiAoJCwgd2luZG93KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciB8fCB7fTtcblxuXHQkLmV4dGVuZCh0cy5jc3MsIHtcblx0XHRzdGlja3kgICAgOiAndGFibGVzb3J0ZXItc3RpY2t5SGVhZGVyJywgLy8gc3RpY2t5SGVhZGVyXG5cdFx0c3RpY2t5VmlzIDogJ3RhYmxlc29ydGVyLXN0aWNreS12aXNpYmxlJyxcblx0XHRzdGlja3lIaWRlOiAndGFibGVzb3J0ZXItc3RpY2t5LWhpZGRlbicsXG5cdFx0c3RpY2t5V3JhcDogJ3RhYmxlc29ydGVyLXN0aWNreS13cmFwcGVyJ1xuXHR9KTtcblxuXHQvLyBBZGQgYSByZXNpemUgZXZlbnQgdG8gdGFibGUgaGVhZGVyc1xuXHR0cy5hZGRIZWFkZXJSZXNpemVFdmVudCA9IGZ1bmN0aW9uKHRhYmxlLCBkaXNhYmxlLCBzZXR0aW5ncykge1xuXHRcdHRhYmxlID0gJCh0YWJsZSlbMF07IC8vIG1ha2Ugc3VyZSB3ZSdyZSB1c2luZyBhIGRvbSBlbGVtZW50XG5cdFx0aWYgKCAhdGFibGUuY29uZmlnICkgeyByZXR1cm47IH1cblx0XHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0XHRcdHRpbWVyIDogMjUwXG5cdFx0XHR9LFxuXHRcdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgc2V0dGluZ3MpLFxuXHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0Y2hlY2tTaXplcyA9IGZ1bmN0aW9uKCB0cmlnZ2VyRXZlbnQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCwgaGVhZGVycywgJGhlYWRlciwgc2l6ZXMsIHdpZHRoLCBoZWlnaHQsXG5cdFx0XHRcdFx0bGVuID0gYy4kaGVhZGVycy5sZW5ndGg7XG5cdFx0XHRcdHdvLnJlc2l6ZV9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0aGVhZGVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzLmVxKCBpbmRleCApO1xuXHRcdFx0XHRcdHNpemVzID0gJGhlYWRlci5kYXRhKCAnc2F2ZWRTaXplcycgKSB8fCBbIDAsIDAgXTsgLy8gZml4ZXMgIzM5NFxuXHRcdFx0XHRcdHdpZHRoID0gJGhlYWRlclswXS5vZmZzZXRXaWR0aDtcblx0XHRcdFx0XHRoZWlnaHQgPSAkaGVhZGVyWzBdLm9mZnNldEhlaWdodDtcblx0XHRcdFx0XHRpZiAoIHdpZHRoICE9PSBzaXplc1swXSB8fCBoZWlnaHQgIT09IHNpemVzWzFdICkge1xuXHRcdFx0XHRcdFx0JGhlYWRlci5kYXRhKCAnc2F2ZWRTaXplcycsIFsgd2lkdGgsIGhlaWdodCBdICk7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLnB1c2goICRoZWFkZXJbMF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBoZWFkZXJzLmxlbmd0aCAmJiB0cmlnZ2VyRXZlbnQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAncmVzaXplJywgWyBoZWFkZXJzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3by5yZXNpemVfZmxhZyA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRjbGVhckludGVydmFsKHdvLnJlc2l6ZV90aW1lcik7XG5cdFx0aWYgKGRpc2FibGUpIHtcblx0XHRcdHdvLnJlc2l6ZV9mbGFnID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGNoZWNrU2l6ZXMoIGZhbHNlICk7XG5cdFx0d28ucmVzaXplX3RpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAod28ucmVzaXplX2ZsYWcpIHsgcmV0dXJuOyB9XG5cdFx0XHRjaGVja1NpemVzKCk7XG5cdFx0fSwgb3B0aW9ucy50aW1lcik7XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0U3RpY2t5T2Zmc2V0KGMsIHdvKSB7XG5cdFx0dmFyICRlbCA9IGlzTmFOKHdvLnN0aWNreUhlYWRlcnNfb2Zmc2V0KSA/ICQod28uc3RpY2t5SGVhZGVyc19vZmZzZXQpIDogW107XG5cdFx0cmV0dXJuICRlbC5sZW5ndGggP1xuXHRcdFx0JGVsLmhlaWdodCgpIHx8IDAgOlxuXHRcdFx0cGFyc2VJbnQod28uc3RpY2t5SGVhZGVyc19vZmZzZXQsIDEwKSB8fCAwO1xuXHR9XG5cblx0Ly8gU3RpY2t5IGhlYWRlcnMgYmFzZWQgb24gdGhpcyBhd2Vzb21lIGFydGljbGU6XG5cdC8vIGh0dHA6Ly9jc3MtdHJpY2tzLmNvbS8xMzQ2NS1wZXJzaXN0ZW50LWhlYWRlcnMvXG5cdC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vam1vc2JlY2gvU3RpY2t5VGFibGVIZWFkZXJzIGJ5IEpvbmFzIE1vc2JlY2hcblx0Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3N0aWNreUhlYWRlcnMnLFxuXHRcdHByaW9yaXR5OiA1NCwgLy8gc3RpY2t5IHdpZGdldCBtdXN0IGJlIGluaXRpYWxpemVkIGFmdGVyIHRoZSBmaWx0ZXIgJiBiZWZvcmUgcGFnZXIgd2lkZ2V0IVxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHN0aWNreUhlYWRlcnMgOiAnJywgICAgICAgLy8gZXh0cmEgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgc3RpY2t5IGhlYWRlciByb3dcblx0XHRcdHN0aWNreUhlYWRlcnNfYXBwZW5kVG8gOiBudWxsLCAvLyBqUXVlcnkgc2VsZWN0b3Igb3Igb2JqZWN0IHRvIHBoeWNpYWxseSBhdHRhY2ggdGhlIHN0aWNreSBoZWFkZXJzXG5cdFx0XHRzdGlja3lIZWFkZXJzX2F0dGFjaFRvIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyIHRvIChvdmVycmlkZGVuIGJ5IHhTY3JvbGwgJiB5U2Nyb2xsIHNldHRpbmdzKVxuXHRcdFx0c3RpY2t5SGVhZGVyc194U2Nyb2xsIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBtb25pdG9yIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uIChkZWZhdWx0czogeFNjcm9sbCA+IGF0dGFjaFRvID4gd2luZG93KVxuXHRcdFx0c3RpY2t5SGVhZGVyc195U2Nyb2xsIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBtb25pdG9yIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiAoZGVmYXVsdHM6IHlTY3JvbGwgPiBhdHRhY2hUbyA+IHdpbmRvdylcblx0XHRcdHN0aWNreUhlYWRlcnNfb2Zmc2V0IDogMCwgLy8gbnVtYmVyIG9yIGpxdWVyeSBzZWxlY3RvciB0YXJnZXRpbmcgdGhlIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRcblx0XHRcdHN0aWNreUhlYWRlcnNfZmlsdGVyZWRUb1RvcDogdHJ1ZSwgLy8gc2Nyb2xsIHRhYmxlIHRvcCBpbnRvIHZpZXcgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0XHRzdGlja3lIZWFkZXJzX2Nsb25lSWQgOiAnLXN0aWNreScsIC8vIGFkZGVkIHRvIHRhYmxlIElELCBpZiBpdCBleGlzdHNcblx0XHRcdHN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQgOiB0cnVlLCAvLyB0cmlnZ2VyICdyZXNpemUnIGV2ZW50IG9uIGhlYWRlcnNcblx0XHRcdHN0aWNreUhlYWRlcnNfaW5jbHVkZUNhcHRpb24gOiB0cnVlLCAvLyBpZiBmYWxzZSBhbmQgYSBjYXB0aW9uIGV4aXN0LCBpdCB3b24ndCBiZSBpbmNsdWRlZCBpbiB0aGUgc3RpY2t5IGhlYWRlclxuXHRcdFx0c3RpY2t5SGVhZGVyc196SW5kZXggOiAyIC8vIFRoZSB6SW5kZXggb2YgdGhlIHN0aWNreUhlYWRlcnMsIGFsbG93cyB0aGUgdXNlciB0byBhZGp1c3QgdGhpcyB0byB0aGVpciBuZWVkc1xuXHRcdH0sXG5cdFx0Zm9ybWF0OiBmdW5jdGlvbih0YWJsZSwgYywgd28pIHtcblx0XHRcdC8vIGZpbHRlciB3aWRnZXQgZG9lc24ndCBpbml0aWFsaXplIG9uIGFuIGVtcHR5IHRhYmxlLiBGaXhlcyAjNDQ5XG5cdFx0XHRpZiAoIGMuJHRhYmxlLmhhc0NsYXNzKCdoYXNTdGlja3lIZWFkZXJzJykgfHwgKCQuaW5BcnJheSgnZmlsdGVyJywgYy53aWRnZXRzKSA+PSAwICYmICFjLiR0YWJsZS5oYXNDbGFzcygnaGFzRmlsdGVycycpKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluZGV4LCBsZW4sICR0LFxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcblx0XHRcdFx0Ly8gYWRkIHBvc2l0aW9uOiByZWxhdGl2ZSB0byBhdHRhY2ggZWxlbWVudCwgaG9wZWZ1bGx5IGl0IHdvbid0IGNhdXNlIHRyb3VibGUuXG5cdFx0XHRcdCRhdHRhY2ggPSAkKHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8gfHwgd28uc3RpY2t5SGVhZGVyc19hcHBlbmRUbyksXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3N0aWNreWhlYWRlcnMgJyxcblx0XHRcdFx0Ly8gZWxlbWVudCB0byB3YXRjaCBmb3IgdGhlIHNjcm9sbCBldmVudFxuXHRcdFx0XHQkeVNjcm9sbCA9ICQod28uc3RpY2t5SGVhZGVyc195U2Nyb2xsIHx8IHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8gfHwgd2luZG93KSxcblx0XHRcdFx0JHhTY3JvbGwgPSAkKHdvLnN0aWNreUhlYWRlcnNfeFNjcm9sbCB8fCB3by5zdGlja3lIZWFkZXJzX2F0dGFjaFRvIHx8IHdpbmRvdyksXG5cdFx0XHRcdCR0aGVhZCA9ICR0YWJsZS5jaGlsZHJlbigndGhlYWQ6Zmlyc3QnKSxcblx0XHRcdFx0JGhlYWRlciA9ICR0aGVhZC5jaGlsZHJlbigndHInKS5ub3QoJy5zdGlja3ktZmFsc2UnKS5jaGlsZHJlbigpLFxuXHRcdFx0XHQkdGZvb3QgPSAkdGFibGUuY2hpbGRyZW4oJ3Rmb290JyksXG5cdFx0XHRcdHN0aWNreU9mZnNldCA9IGdldFN0aWNreU9mZnNldChjLCB3byksXG5cdFx0XHRcdC8vIGlzIHRoaXMgdGFibGUgbmVzdGVkPyBJZiBzbywgZmluZCBwYXJlbnQgc3RpY2t5IGhlYWRlciB3cmFwcGVyIChkaXYsIG5vdCB0YWJsZSlcblx0XHRcdFx0JG5lc3RlZFN0aWNreSA9ICR0YWJsZS5wYXJlbnQoKS5jbG9zZXN0KCcuJyArIHRzLmNzcy50YWJsZSkuaGFzQ2xhc3MoJ2hhc1N0aWNreUhlYWRlcnMnKSA/XG5cdFx0XHRcdFx0JHRhYmxlLnBhcmVudCgpLmNsb3Nlc3QoJ3RhYmxlLnRhYmxlc29ydGVyJylbMF0uY29uZmlnLndpZGdldE9wdGlvbnMuJHN0aWNreS5wYXJlbnQoKSA6IFtdLFxuXHRcdFx0XHRuZXN0ZWRTdGlja3lUb3AgPSAkbmVzdGVkU3RpY2t5Lmxlbmd0aCA/ICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiAwLFxuXHRcdFx0XHQvLyBjbG9uZSB0YWJsZSwgdGhlbiB3cmFwIHRvIG1ha2Ugc3RpY2t5IGhlYWRlclxuXHRcdFx0XHQkc3RpY2t5VGFibGUgPSB3by4kc3RpY2t5ID0gJHRhYmxlLmNsb25lKClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2NvbnRhaW5zU3RpY2t5SGVhZGVycyAnICsgdHMuY3NzLnN0aWNreSArICcgJyArIHdvLnN0aWNreUhlYWRlcnMgKyAnICcgKyBjLm5hbWVzcGFjZS5zbGljZSgxKSArICdfZXh0cmFfdGFibGUnIClcblx0XHRcdFx0XHQud3JhcCgnPGRpdiBjbGFzcz1cIicgKyB0cy5jc3Muc3RpY2t5V3JhcCArICdcIj4nKSxcblx0XHRcdFx0JHN0aWNreVdyYXAgPSAkc3RpY2t5VGFibGUucGFyZW50KClcblx0XHRcdFx0XHQuYWRkQ2xhc3ModHMuY3NzLnN0aWNreUhpZGUpXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAgIDogJGF0dGFjaC5sZW5ndGggPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyxcblx0XHRcdFx0XHRcdHBhZGRpbmcgICAgOiBwYXJzZUludCggJHN0aWNreVRhYmxlLnBhcmVudCgpLnBhcmVudCgpLmNzcygncGFkZGluZy1sZWZ0JyksIDEwICksXG5cdFx0XHRcdFx0XHR0b3AgICAgICAgIDogc3RpY2t5T2Zmc2V0ICsgbmVzdGVkU3RpY2t5VG9wLFxuXHRcdFx0XHRcdFx0bGVmdCAgICAgICA6IDAsXG5cdFx0XHRcdFx0XHR2aXNpYmlsaXR5IDogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHR6SW5kZXggICAgIDogd28uc3RpY2t5SGVhZGVyc196SW5kZXggfHwgMlxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHQkc3RpY2t5VGhlYWQgPSAkc3RpY2t5VGFibGUuY2hpbGRyZW4oJ3RoZWFkOmZpcnN0JyksXG5cdFx0XHRcdCRzdGlja3lDZWxscyxcblx0XHRcdFx0bGFzdHN0YXRlID0gJycsXG5cdFx0XHRcdHNldFdpZHRoID0gZnVuY3Rpb24oJG9yaWcsICRjbG9uZSkge1xuXHRcdFx0XHRcdHZhciBpbmRleCwgd2lkdGgsIGJvcmRlciwgJGNlbGwsICR0aGlzLFxuXHRcdFx0XHRcdFx0JGNlbGxzID0gJG9yaWcuZmlsdGVyKCc6dmlzaWJsZScpLFxuXHRcdFx0XHRcdFx0bGVuID0gJGNlbGxzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdFx0JGNlbGwgPSAkY2xvbmUuZmlsdGVyKCc6dmlzaWJsZScpLmVxKGluZGV4KTtcblx0XHRcdFx0XHRcdCR0aGlzID0gJGNlbGxzLmVxKGluZGV4KTtcblx0XHRcdFx0XHRcdC8vIGNvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vam1vc2JlY2gvU3RpY2t5VGFibGVIZWFkZXJzXG5cdFx0XHRcdFx0XHRpZiAoJHRoaXMuY3NzKCdib3gtc2l6aW5nJykgPT09ICdib3JkZXItYm94Jykge1xuXHRcdFx0XHRcdFx0XHR3aWR0aCA9ICR0aGlzLm91dGVyV2lkdGgoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICgkY2VsbC5jc3MoJ2JvcmRlci1jb2xsYXBzZScpID09PSAnY29sbGFwc2UnKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aWR0aCA9IHBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCR0aGlzWzBdLCBudWxsKS53aWR0aCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZTggb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ym9yZGVyID0gcGFyc2VGbG9hdCggJHRoaXMuY3NzKCdib3JkZXItd2lkdGgnKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGggPSAkdGhpcy5vdXRlcldpZHRoKCkgLSBwYXJzZUZsb2F0KCAkdGhpcy5jc3MoJ3BhZGRpbmctbGVmdCcpICkgLSBwYXJzZUZsb2F0KCAkdGhpcy5jc3MoJ3BhZGRpbmctcmlnaHQnKSApIC0gYm9yZGVyO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aCA9ICR0aGlzLndpZHRoKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCRjZWxsLmNzcyh7XG5cdFx0XHRcdFx0XHRcdCd3aWR0aCc6IHdpZHRoLFxuXHRcdFx0XHRcdFx0XHQnbWluLXdpZHRoJzogd2lkdGgsXG5cdFx0XHRcdFx0XHRcdCdtYXgtd2lkdGgnOiB3aWR0aFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRMZWZ0UG9zaXRpb24gPSBmdW5jdGlvbih5V2luZG93KSB7XG5cdFx0XHRcdFx0aWYgKHlXaW5kb3cgPT09IGZhbHNlICYmICRuZXN0ZWRTdGlja3kubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJHRhYmxlLnBvc2l0aW9uKCkubGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICRhdHRhY2gubGVuZ3RoID9cblx0XHRcdFx0XHRcdHBhcnNlSW50KCRhdHRhY2guY3NzKCdwYWRkaW5nLWxlZnQnKSwgMTApIHx8IDAgOlxuXHRcdFx0XHRcdFx0JHRhYmxlLm9mZnNldCgpLmxlZnQgLSBwYXJzZUludCgkdGFibGUuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMCkgLSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNpemVIZWFkZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkc3RpY2t5V3JhcC5jc3Moe1xuXHRcdFx0XHRcdFx0bGVmdCA6IGdldExlZnRQb3NpdGlvbigpLFxuXHRcdFx0XHRcdFx0d2lkdGg6ICR0YWJsZS5vdXRlcldpZHRoKClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRXaWR0aCggJHRhYmxlLCAkc3RpY2t5VGFibGUgKTtcblx0XHRcdFx0XHRzZXRXaWR0aCggJGhlYWRlciwgJHN0aWNreUNlbGxzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNjcm9sbFN0aWNreSA9IGZ1bmN0aW9uKCByZXNpemluZyApIHtcblx0XHRcdFx0XHRpZiAoISR0YWJsZS5pcygnOnZpc2libGUnKSkgeyByZXR1cm47IH0gLy8gZml4ZXMgIzI3OFxuXHRcdFx0XHRcdC8vIERldGVjdCBuZXN0ZWQgdGFibGVzIC0gZml4ZXMgIzcyNFxuXHRcdFx0XHRcdG5lc3RlZFN0aWNreVRvcCA9ICRuZXN0ZWRTdGlja3kubGVuZ3RoID8gJG5lc3RlZFN0aWNreS5vZmZzZXQoKS50b3AgLSAkeVNjcm9sbC5zY3JvbGxUb3AoKSArICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiAwO1xuXHRcdFx0XHRcdHZhciB0bXAsXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSAkdGFibGUub2Zmc2V0KCksXG5cdFx0XHRcdFx0XHRzdGlja3lPZmZzZXQgPSBnZXRTdGlja3lPZmZzZXQoYywgd28pLFxuXHRcdFx0XHRcdFx0eVdpbmRvdyA9ICQuaXNXaW5kb3coICR5U2Nyb2xsWzBdICksIC8vICQuaXNXaW5kb3cgbmVlZHMgalF1ZXJ5IDEuNC4zXG5cdFx0XHRcdFx0XHR5U2Nyb2xsID0geVdpbmRvdyA/XG5cdFx0XHRcdFx0XHRcdCR5U2Nyb2xsLnNjcm9sbFRvcCgpIDpcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHBhcmVudCBzdGlja3kgcG9zaXRpb24gaWYgbmVzdGVkIEFORCBpbnNpZGUgb2YgYSBzY3JvbGxhYmxlIGVsZW1lbnQgLSBzZWUgIzE1MTJcblx0XHRcdFx0XHRcdFx0JG5lc3RlZFN0aWNreS5sZW5ndGggPyBwYXJzZUludCgkbmVzdGVkU3RpY2t5WzBdLnN0eWxlLnRvcCwgMTApIDogJHlTY3JvbGwub2Zmc2V0KCkudG9wLFxuXHRcdFx0XHRcdFx0YXR0YWNoVG9wID0gJGF0dGFjaC5sZW5ndGggPyB5U2Nyb2xsIDogJHlTY3JvbGwuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdFx0XHRjYXB0aW9uSGVpZ2h0ID0gd28uc3RpY2t5SGVhZGVyc19pbmNsdWRlQ2FwdGlvbiA/IDAgOiAkdGFibGUuY2hpbGRyZW4oICdjYXB0aW9uJyApLmhlaWdodCgpIHx8IDAsXG5cdFx0XHRcdFx0XHRzY3JvbGxUb3AgPSBhdHRhY2hUb3AgKyBzdGlja3lPZmZzZXQgKyBuZXN0ZWRTdGlja3lUb3AgLSBjYXB0aW9uSGVpZ2h0LFxuXHRcdFx0XHRcdFx0dGFibGVIZWlnaHQgPSAkdGFibGUuaGVpZ2h0KCkgLSAoJHN0aWNreVdyYXAuaGVpZ2h0KCkgKyAoJHRmb290LmhlaWdodCgpIHx8IDApKSAtIGNhcHRpb25IZWlnaHQsXG5cdFx0XHRcdFx0XHRpc1Zpc2libGUgPSAoIHNjcm9sbFRvcCA+IG9mZnNldC50b3AgKSAmJiAoIHNjcm9sbFRvcCA8IG9mZnNldC50b3AgKyB0YWJsZUhlaWdodCApID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IGlzVmlzaWJsZSA9PT0gJ3Zpc2libGUnID8gdHMuY3NzLnN0aWNreVZpcyA6IHRzLmNzcy5zdGlja3lIaWRlLFxuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGluZyA9ICEkc3RpY2t5V3JhcC5oYXNDbGFzcyggc3RhdGUgKSxcblx0XHRcdFx0XHRcdGNzc1NldHRpbmdzID0geyB2aXNpYmlsaXR5IDogaXNWaXNpYmxlIH07XG5cdFx0XHRcdFx0aWYgKCRhdHRhY2gubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBhdHRhY2hlZCBzdGlja3kgaGVhZGVycyBhbHdheXMgbmVlZCB1cGRhdGluZ1xuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRjc3NTZXR0aW5ncy50b3AgPSB5V2luZG93ID8gc2Nyb2xsVG9wIC0gJGF0dGFjaC5vZmZzZXQoKS50b3AgOiAkYXR0YWNoLnNjcm9sbFRvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhZGp1c3Qgd2hlbiBzY3JvbGxpbmcgaG9yaXpvbnRhbGx5IC0gZml4ZXMgaXNzdWUgIzE0M1xuXHRcdFx0XHRcdHRtcCA9IGdldExlZnRQb3NpdGlvbih5V2luZG93KTtcblx0XHRcdFx0XHRpZiAodG1wICE9PSBwYXJzZUludCgkc3RpY2t5V3JhcC5jc3MoJ2xlZnQnKSwgMTApKSB7XG5cdFx0XHRcdFx0XHRuZWVkc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNzc1NldHRpbmdzLmxlZnQgPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNzc1NldHRpbmdzLnRvcCA9ICggY3NzU2V0dGluZ3MudG9wIHx8IDAgKSArXG5cdFx0XHRcdFx0XHQvLyBJZiBuZXN0ZWQgQU5EIGluc2lkZSBvZiBhIHNjcm9sbGFibGUgZWxlbWVudCwgb25seSBhZGQgcGFyZW50IHN0aWNreSBoZWlnaHRcblx0XHRcdFx0XHRcdCgheVdpbmRvdyAmJiAkbmVzdGVkU3RpY2t5Lmxlbmd0aCA/ICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiBzdGlja3lPZmZzZXQgKyBuZXN0ZWRTdGlja3lUb3ApO1xuXHRcdFx0XHRcdGlmIChuZWVkc1VwZGF0aW5nKSB7XG5cdFx0XHRcdFx0XHQkc3RpY2t5V3JhcFxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRzLmNzcy5zdGlja3lWaXMgKyAnICcgKyB0cy5jc3Muc3RpY2t5SGlkZSApXG5cdFx0XHRcdFx0XHRcdC5hZGRDbGFzcyggc3RhdGUgKVxuXHRcdFx0XHRcdFx0XHQuY3NzKGNzc1NldHRpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlzVmlzaWJsZSAhPT0gbGFzdHN0YXRlIHx8IHJlc2l6aW5nKSB7XG5cdFx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGNvbHVtbiB3aWR0aHMgbWF0Y2hcblx0XHRcdFx0XHRcdHJlc2l6ZUhlYWRlcigpO1xuXHRcdFx0XHRcdFx0bGFzdHN0YXRlID0gaXNWaXNpYmxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdC8vIG9ubHkgYWRkIGEgcG9zaXRpb24gcmVsYXRpdmUgaWYgYSBwb3NpdGlvbiBpc24ndCBhbHJlYWR5IGRlZmluZWRcblx0XHRcdGlmICgkYXR0YWNoLmxlbmd0aCAmJiAhJGF0dGFjaC5jc3MoJ3Bvc2l0aW9uJykpIHtcblx0XHRcdFx0JGF0dGFjaC5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaXggY2xvbmUgSUQsIGlmIGl0IGV4aXN0cyAtIGZpeGVzICMyNzFcblx0XHRcdGlmICgkc3RpY2t5VGFibGUuYXR0cignaWQnKSkgeyAkc3RpY2t5VGFibGVbMF0uaWQgKz0gd28uc3RpY2t5SGVhZGVyc19jbG9uZUlkOyB9XG5cdFx0XHQvLyBjbGVhciBvdXQgY2xvbmVkIHRhYmxlLCBleGNlcHQgZm9yIHN0aWNreSBoZWFkZXJcblx0XHRcdC8vIGluY2x1ZGUgY2FwdGlvbiAmIGZpbHRlciByb3cgKGZpeGVzICMxMjYgJiAjMjQ5KSAtIGRvbid0IHJlbW92ZSBjZWxscyB0byBnZXQgY29ycmVjdCBjZWxsIGluZGV4aW5nXG5cdFx0XHQkc3RpY2t5VGFibGUuZmluZCgnPiB0aGVhZDpndCgwKSwgdHIuc3RpY2t5LWZhbHNlJykuaGlkZSgpO1xuXHRcdFx0JHN0aWNreVRhYmxlLmZpbmQoJz4gdGJvZHksID4gdGZvb3QnKS5yZW1vdmUoKTtcblx0XHRcdCRzdGlja3lUYWJsZS5maW5kKCdjYXB0aW9uJykudG9nZ2xlKHdvLnN0aWNreUhlYWRlcnNfaW5jbHVkZUNhcHRpb24pO1xuXHRcdFx0Ly8gaXNzdWUgIzE3MiAtIGZpbmQgdGQvdGggaW4gc3RpY2t5IGhlYWRlclxuXHRcdFx0JHN0aWNreUNlbGxzID0gJHN0aWNreVRoZWFkLmNoaWxkcmVuKCkuY2hpbGRyZW4oKTtcblx0XHRcdCRzdGlja3lUYWJsZS5jc3MoeyBoZWlnaHQ6MCwgd2lkdGg6MCwgbWFyZ2luOiAwIH0pO1xuXHRcdFx0Ly8gcmVtb3ZlIHJlc2l6YWJsZSBibG9ja1xuXHRcdFx0JHN0aWNreUNlbGxzLmZpbmQoJy4nICsgdHMuY3NzLnJlc2l6ZXIpLnJlbW92ZSgpO1xuXHRcdFx0Ly8gdXBkYXRlIHN0aWNreSBoZWFkZXIgY2xhc3MgbmFtZXMgdG8gbWF0Y2ggcmVhbCBoZWFkZXIgYWZ0ZXIgc29ydGluZ1xuXHRcdFx0JHRhYmxlXG5cdFx0XHRcdC5hZGRDbGFzcygnaGFzU3RpY2t5SGVhZGVycycpXG5cdFx0XHRcdC5iaW5kKCdwYWdlckNvbXBsZXRlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmVzaXplSGVhZGVyKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR0cy5iaW5kRXZlbnRzKHRhYmxlLCAkc3RpY2t5VGhlYWQuY2hpbGRyZW4oKS5jaGlsZHJlbignLicgKyB0cy5jc3MuaGVhZGVyKSk7XG5cblx0XHRcdGlmICh3by5zdGlja3lIZWFkZXJzX2FwcGVuZFRvKSB7XG5cdFx0XHRcdCQod28uc3RpY2t5SGVhZGVyc19hcHBlbmRUbykuYXBwZW5kKCAkc3RpY2t5V3JhcCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYWRkIHN0aWNreWhlYWRlcnMgQUZURVIgdGhlIHRhYmxlLiBJZiB0aGUgdGFibGUgaXMgc2VsZWN0ZWQgYnkgSUQsIHRoZSBvcmlnaW5hbCBvbmUgKGZpcnN0KSB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0XHQkdGFibGUuYWZ0ZXIoICRzdGlja3lXcmFwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG9uUmVuZGVySGVhZGVyIGlzIGRlZmluZWQsIHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGFib3V0IGl0IChmaXhlcyAjNjQxKVxuXHRcdFx0aWYgKGMub25SZW5kZXJIZWFkZXIpIHtcblx0XHRcdFx0JHQgPSAkc3RpY2t5VGhlYWQuY2hpbGRyZW4oJ3RyJykuY2hpbGRyZW4oKTtcblx0XHRcdFx0bGVuID0gJHQubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdC8vIHNlbmQgc2Vjb25kIHBhcmFtZXRlclxuXHRcdFx0XHRcdGMub25SZW5kZXJIZWFkZXIuYXBwbHkoICR0LmVxKCBpbmRleCApLCBbIGluZGV4LCBjLCAkc3RpY2t5VGFibGUgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBtYWtlIGl0IHN0aWNreSFcblx0XHRcdCR4U2Nyb2xsLmFkZCgkeVNjcm9sbClcblx0XHRcdFx0LnVuYmluZCggKCdzY3JvbGwgcmVzaXplICcuc3BsaXQoJyAnKS5qb2luKCBuYW1lc3BhY2UgKSkucmVwbGFjZSgvXFxzKy9nLCAnICcpIClcblx0XHRcdFx0LmJpbmQoJ3Njcm9sbCByZXNpemUgJy5zcGxpdCgnICcpLmpvaW4oIG5hbWVzcGFjZSApLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsU3RpY2t5KCBldmVudC50eXBlID09PSAncmVzaXplJyApO1xuXHRcdFx0XHR9KTtcblx0XHRcdGMuJHRhYmxlXG5cdFx0XHRcdC51bmJpbmQoJ3N0aWNreUhlYWRlcnNVcGRhdGUnICsgbmFtZXNwYWNlKVxuXHRcdFx0XHQuYmluZCgnc3RpY2t5SGVhZGVyc1VwZGF0ZScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNjcm9sbFN0aWNreSggdHJ1ZSApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0aWYgKHdvLnN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQpIHtcblx0XHRcdFx0dHMuYWRkSGVhZGVyUmVzaXplRXZlbnQodGFibGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBmaWx0ZXIgd2lkZ2V0XG5cdFx0XHRpZiAoJHRhYmxlLmhhc0NsYXNzKCdoYXNGaWx0ZXJzJykgJiYgd28uZmlsdGVyX2NvbHVtbkZpbHRlcnMpIHtcblx0XHRcdFx0Ly8gc2Nyb2xsIHRhYmxlIGludG8gdmlldyBhZnRlciBmaWx0ZXJpbmcsIGlmIHN0aWNreSBoZWFkZXIgaXMgYWN0aXZlIC0gIzQ4MlxuXHRcdFx0XHQkdGFibGUuYmluZCgnZmlsdGVyRW5kJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gJCgnOmZvY3VzJykgbmVlZHMgalF1ZXJ5IDEuNitcblx0XHRcdFx0XHR2YXIgJHRkID0gJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5jbG9zZXN0KCd0ZCcpLFxuXHRcdFx0XHRcdFx0Y29sdW1uID0gJHRkLnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXgoJHRkKTtcblx0XHRcdFx0XHQvLyBvbmx5IHNjcm9sbCBpZiBzdGlja3kgaGVhZGVyIGlzIGFjdGl2ZVxuXHRcdFx0XHRcdGlmICgkc3RpY2t5V3JhcC5oYXNDbGFzcyh0cy5jc3Muc3RpY2t5VmlzKSAmJiB3by5zdGlja3lIZWFkZXJzX2ZpbHRlcmVkVG9Ub3ApIHtcblx0XHRcdFx0XHRcdC8vIHNjcm9sbCB0byBvcmlnaW5hbCB0YWJsZSAobm90IHN0aWNreSBjbG9uZSlcblx0XHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLCAkdGFibGUucG9zaXRpb24oKS50b3ApO1xuXHRcdFx0XHRcdFx0Ly8gZ2l2ZSBzYW1lIGlucHV0L3NlbGVjdCBmb2N1czsgY2hlY2sgaWYgYy4kZmlsdGVycyBleGlzdHM7IGZpeGVzICM1OTRcblx0XHRcdFx0XHRcdGlmIChjb2x1bW4gPj0gMCAmJiBjLiRmaWx0ZXJzKSB7XG5cdFx0XHRcdFx0XHRcdGMuJGZpbHRlcnMuZXEoY29sdW1uKS5maW5kKCdhLCBzZWxlY3QsIGlucHV0JykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dHMuZmlsdGVyLmJpbmRTZWFyY2goICR0YWJsZSwgJHN0aWNreUNlbGxzLmZpbmQoJy4nICsgdHMuY3NzLmZpbHRlcikgKTtcblx0XHRcdFx0Ly8gc3VwcG9ydCBoaWRlRmlsdGVyc1xuXHRcdFx0XHRpZiAod28uZmlsdGVyX2hpZGVGaWx0ZXJzKSB7XG5cdFx0XHRcdFx0dHMuZmlsdGVyLmhpZGVGaWx0ZXJzKGMsICRzdGlja3lUYWJsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzaXplIHRhYmxlIChGaXJlZm94KVxuXHRcdFx0aWYgKHdvLnN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQpIHtcblx0XHRcdFx0JHRhYmxlLmJpbmQoJ3Jlc2l6ZScgKyBjLm5hbWVzcGFjZSArICdzdGlja3loZWFkZXJzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmVzaXplSGVhZGVyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYWtlIHN1cmUgc3RpY2t5IGlzIHZpc2libGUgaWYgcGFnZSBpcyBwYXJ0aWFsbHkgc2Nyb2xsZWRcblx0XHRcdHNjcm9sbFN0aWNreSggdHJ1ZSApO1xuXHRcdFx0JHRhYmxlLnRyaWdnZXJIYW5kbGVyKCdzdGlja3lIZWFkZXJzSW5pdCcpO1xuXG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bykge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3N0aWNreWhlYWRlcnMgJztcblx0XHRcdGMuJHRhYmxlXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnaGFzU3RpY2t5SGVhZGVycycpXG5cdFx0XHRcdC51bmJpbmQoICgncGFnZXJDb21wbGV0ZSByZXNpemUgZmlsdGVyRW5kIHN0aWNreUhlYWRlcnNVcGRhdGUgJy5zcGxpdCgnICcpLmpvaW4obmFtZXNwYWNlKSkucmVwbGFjZSgvXFxzKy9nLCAnICcpIClcblx0XHRcdFx0Lm5leHQoJy4nICsgdHMuY3NzLnN0aWNreVdyYXApLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHdvLiRzdGlja3kgJiYgd28uJHN0aWNreS5sZW5ndGgpIHsgd28uJHN0aWNreS5yZW1vdmUoKTsgfSAvLyByZW1vdmUgY2xvbmVkIHRhYmxlXG5cdFx0XHQkKHdpbmRvdylcblx0XHRcdFx0LmFkZCh3by5zdGlja3lIZWFkZXJzX3hTY3JvbGwpXG5cdFx0XHRcdC5hZGQod28uc3RpY2t5SGVhZGVyc195U2Nyb2xsKVxuXHRcdFx0XHQuYWRkKHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8pXG5cdFx0XHRcdC51bmJpbmQoICgnc2Nyb2xsIHJlc2l6ZSAnLnNwbGl0KCcgJykuam9pbihuYW1lc3BhY2UpKS5yZXBsYWNlKC9cXHMrL2csICcgJykgKTtcblx0XHRcdHRzLmFkZEhlYWRlclJlc2l6ZUV2ZW50KHRhYmxlLCB0cnVlKTtcblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnksIHdpbmRvdyk7XG5cclxuLyohIFdpZGdldDogcmVzaXphYmxlIC0gdXBkYXRlZCAyMDE4LTAzLTI2ICh2Mi4zMC4yKSAqL1xuLypqc2hpbnQgYnJvd3Nlcjp0cnVlLCBqcXVlcnk6dHJ1ZSwgdW51c2VkOmZhbHNlICovXG47KGZ1bmN0aW9uICgkLCB3aW5kb3cpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgdHMgPSAkLnRhYmxlc29ydGVyIHx8IHt9O1xuXG5cdCQuZXh0ZW5kKHRzLmNzcywge1xuXHRcdHJlc2l6YWJsZUNvbnRhaW5lciA6ICd0YWJsZXNvcnRlci1yZXNpemFibGUtY29udGFpbmVyJyxcblx0XHRyZXNpemFibGVIYW5kbGUgICAgOiAndGFibGVzb3J0ZXItcmVzaXphYmxlLWhhbmRsZScsXG5cdFx0cmVzaXphYmxlTm9TZWxlY3QgIDogJ3RhYmxlc29ydGVyLWRpc2FibGVTZWxlY3Rpb24nLFxuXHRcdHJlc2l6YWJsZVN0b3JhZ2UgICA6ICd0YWJsZXNvcnRlci1yZXNpemFibGUnXG5cdH0pO1xuXG5cdC8vIEFkZCBleHRyYSBzY3JvbGxlciBjc3Ncblx0JChmdW5jdGlvbigpIHtcblx0XHR2YXIgcyA9ICc8c3R5bGU+JyArXG5cdFx0XHQnYm9keS4nICsgdHMuY3NzLnJlc2l6YWJsZU5vU2VsZWN0ICsgJyB7IC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lOycgK1xuXHRcdFx0XHQnLWtodG1sLXVzZXItc2VsZWN0OiBub25lOyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgfScgK1xuXHRcdFx0Jy4nICsgdHMuY3NzLnJlc2l6YWJsZUNvbnRhaW5lciArICcgeyBwb3NpdGlvbjogcmVsYXRpdmU7IGhlaWdodDogMXB4OyB9JyArXG5cdFx0XHQvLyBtYWtlIGhhbmRsZSB6LWluZGV4ID4gdGhhbiBzdGlja3lIZWFkZXIgei1pbmRleCwgc28gdGhlIGhhbmRsZSBzdGF5cyBhYm92ZSBzdGlja3kgaGVhZGVyXG5cdFx0XHQnLicgKyB0cy5jc3MucmVzaXphYmxlSGFuZGxlICsgJyB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogOHB4OycgK1xuXHRcdFx0XHQndG9wOiAxcHg7IGN1cnNvcjogZXctcmVzaXplOyB6LWluZGV4OiAzOyB1c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgfScgK1xuXHRcdFx0Jzwvc3R5bGU+Jztcblx0XHQkKCdoZWFkJykuYXBwZW5kKHMpO1xuXHR9KTtcblxuXHR0cy5yZXNpemFibGUgPSB7XG5cdFx0aW5pdCA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdGlmICggYy4kdGFibGUuaGFzQ2xhc3MoICdoYXNSZXNpemFibGUnICkgKSB7IHJldHVybjsgfVxuXHRcdFx0Yy4kdGFibGUuYWRkQ2xhc3MoICdoYXNSZXNpemFibGUnICk7XG5cblx0XHRcdHZhciBub1Jlc2l6ZSwgJGhlYWRlciwgY29sdW1uLCBzdG9yZWRTaXplcywgdG1wLFxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcblx0XHRcdFx0JHBhcmVudCA9ICR0YWJsZS5wYXJlbnQoKSxcblx0XHRcdFx0bWFyZ2luVG9wID0gcGFyc2VJbnQoICR0YWJsZS5jc3MoICdtYXJnaW4tdG9wJyApLCAxMCApLFxuXG5cdFx0XHQvLyBpbnRlcm5hbCB2YXJpYWJsZXNcblx0XHRcdHZhcnMgPSB3by5yZXNpemFibGVfdmFycyA9IHtcblx0XHRcdFx0dXNlU3RvcmFnZSA6IHRzLnN0b3JhZ2UgJiYgd28ucmVzaXphYmxlICE9PSBmYWxzZSxcblx0XHRcdFx0JHdyYXAgOiAkcGFyZW50LFxuXHRcdFx0XHRtb3VzZVhQb3NpdGlvbiA6IDAsXG5cdFx0XHRcdCR0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHQkbmV4dCA6IG51bGwsXG5cdFx0XHRcdG92ZXJmbG93IDogJHBhcmVudC5jc3MoJ292ZXJmbG93JykgPT09ICdhdXRvJyB8fFxuXHRcdFx0XHRcdCRwYXJlbnQuY3NzKCdvdmVyZmxvdycpID09PSAnc2Nyb2xsJyB8fFxuXHRcdFx0XHRcdCRwYXJlbnQuY3NzKCdvdmVyZmxvdy14JykgPT09ICdhdXRvJyB8fFxuXHRcdFx0XHRcdCRwYXJlbnQuY3NzKCdvdmVyZmxvdy14JykgPT09ICdzY3JvbGwnLFxuXHRcdFx0XHRzdG9yZWRTaXplcyA6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgZGVmYXVsdCB3aWR0aHNcblx0XHRcdHRzLnJlc2l6YWJsZVJlc2V0KCBjLnRhYmxlLCB0cnVlICk7XG5cblx0XHRcdC8vIG5vdyBnZXQgbWVhc3VyZW1lbnRzIVxuXHRcdFx0dmFycy50YWJsZVdpZHRoID0gJHRhYmxlLndpZHRoKCk7XG5cdFx0XHQvLyBhdHRlbXB0IHRvIGF1dG9kZXRlY3Rcblx0XHRcdHZhcnMuZnVsbFdpZHRoID0gTWF0aC5hYnMoICRwYXJlbnQud2lkdGgoKSAtIHZhcnMudGFibGVXaWR0aCApIDwgMjA7XG5cblx0XHRcdC8qXG5cdFx0XHQvLyBIYWNreSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRhYmxlIHdpZHRoIGlzIHNldCB0byAnYXV0bydcblx0XHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwODkyMDQ4LzE0NTM0NlxuXHRcdFx0aWYgKCAhdmFycy5mdWxsV2lkdGggKSB7XG5cdFx0XHRcdHRtcCA9ICR0YWJsZS53aWR0aCgpO1xuXHRcdFx0XHQkaGVhZGVyID0gJHRhYmxlLndyYXAoJzxzcGFuPicpLnBhcmVudCgpOyAvLyB0ZW1wIHZhcmlhYmxlXG5cdFx0XHRcdHN0b3JlZFNpemVzID0gcGFyc2VJbnQoICR0YWJsZS5jc3MoICdtYXJnaW4tbGVmdCcgKSwgMTAgKSB8fCAwO1xuXHRcdFx0XHQkdGFibGUuY3NzKCAnbWFyZ2luLWxlZnQnLCBzdG9yZWRTaXplcyArIDUwICk7XG5cdFx0XHRcdHZhcnMudGFibGVXaWR0aCA9ICRoZWFkZXIud2lkdGgoKSA+IHRtcCA/ICdhdXRvJyA6IHRtcDtcblx0XHRcdFx0JHRhYmxlLmNzcyggJ21hcmdpbi1sZWZ0Jywgc3RvcmVkU2l6ZXMgPyBzdG9yZWRTaXplcyA6ICcnICk7XG5cdFx0XHRcdCRoZWFkZXIgPSBudWxsO1xuXHRcdFx0XHQkdGFibGUudW53cmFwKCc8c3Bhbj4nKTtcblx0XHRcdH1cblx0XHRcdCovXG5cblx0XHRcdGlmICggdmFycy51c2VTdG9yYWdlICYmIHZhcnMub3ZlcmZsb3cgKSB7XG5cdFx0XHRcdC8vIHNhdmUgdGFibGUgd2lkdGhcblx0XHRcdFx0dHMuc3RvcmFnZSggYy50YWJsZSwgJ3RhYmxlc29ydGVyLXRhYmxlLW9yaWdpbmFsLWNzcy13aWR0aCcsIHZhcnMudGFibGVXaWR0aCApO1xuXHRcdFx0XHR0bXAgPSB0cy5zdG9yYWdlKCBjLnRhYmxlLCAndGFibGVzb3J0ZXItdGFibGUtcmVzaXplZC13aWR0aCcgKSB8fCAnYXV0byc7XG5cdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aCggJHRhYmxlLCB0bXAsIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdHdvLnJlc2l6YWJsZV92YXJzLnN0b3JlZFNpemVzID0gc3RvcmVkU2l6ZXMgPSAoIHZhcnMudXNlU3RvcmFnZSA/XG5cdFx0XHRcdHRzLnN0b3JhZ2UoIGMudGFibGUsIHRzLmNzcy5yZXNpemFibGVTdG9yYWdlICkgOlxuXHRcdFx0XHRbXSApIHx8IFtdO1xuXHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRocyggYywgd28sIHN0b3JlZFNpemVzICk7XG5cdFx0XHR0cy5yZXNpemFibGUudXBkYXRlU3RvcmVkU2l6ZXMoIGMsIHdvICk7XG5cblx0XHRcdHdvLiRyZXNpemFibGVfY29udGFpbmVyID0gJCggJzxkaXYgY2xhc3M9XCInICsgdHMuY3NzLnJlc2l6YWJsZUNvbnRhaW5lciArICdcIj4nIClcblx0XHRcdFx0LmNzcyh7IHRvcCA6IG1hcmdpblRvcCB9KVxuXHRcdFx0XHQuaW5zZXJ0QmVmb3JlKCAkdGFibGUgKTtcblx0XHRcdC8vIGFkZCBjb250YWluZXJcblx0XHRcdGZvciAoIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGMuY29sdW1uczsgY29sdW1uKysgKSB7XG5cdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXTtcblx0XHRcdFx0dG1wID0gdHMuZ2V0Q29sdW1uRGF0YSggYy50YWJsZSwgYy5oZWFkZXJzLCBjb2x1bW4gKTtcblx0XHRcdFx0bm9SZXNpemUgPSB0cy5nZXREYXRhKCAkaGVhZGVyLCB0bXAsICdyZXNpemFibGUnICkgPT09ICdmYWxzZSc7XG5cdFx0XHRcdGlmICggIW5vUmVzaXplICkge1xuXHRcdFx0XHRcdCQoICc8ZGl2IGNsYXNzPVwiJyArIHRzLmNzcy5yZXNpemFibGVIYW5kbGUgKyAnXCI+JyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHdvLiRyZXNpemFibGVfY29udGFpbmVyIClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0J2RhdGEtY29sdW1uJyA6IGNvbHVtbixcblx0XHRcdFx0XHRcdFx0J3Vuc2VsZWN0YWJsZScgOiAnb24nXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmRhdGEoICdoZWFkZXInLCAkaGVhZGVyIClcblx0XHRcdFx0XHRcdC5iaW5kKCAnc2VsZWN0c3RhcnQnLCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0cy5yZXNpemFibGUuYmluZGluZ3MoIGMsIHdvICk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZVN0b3JlZFNpemVzIDogZnVuY3Rpb24oIGMsIHdvICkge1xuXHRcdFx0dmFyIGNvbHVtbiwgJGhlYWRlcixcblx0XHRcdFx0bGVuID0gYy5jb2x1bW5zLFxuXHRcdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnM7XG5cdFx0XHR2YXJzLnN0b3JlZFNpemVzID0gW107XG5cdFx0XHRmb3IgKCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBsZW47IGNvbHVtbisrICkge1xuXHRcdFx0XHQkaGVhZGVyID0gYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF07XG5cdFx0XHRcdHZhcnMuc3RvcmVkU2l6ZXNbIGNvbHVtbiBdID0gJGhlYWRlci5pcygnOnZpc2libGUnKSA/ICRoZWFkZXIud2lkdGgoKSA6IDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldFdpZHRoIDogZnVuY3Rpb24oICRlbCwgd2lkdGgsIG92ZXJmbG93ICkge1xuXHRcdFx0Ly8gb3ZlcmZsb3cgdGFibGVzIG5lZWQgbWluICYgbWF4IHdpZHRoIHNldCBhcyB3ZWxsXG5cdFx0XHQkZWwuY3NzKHtcblx0XHRcdFx0J3dpZHRoJyA6IHdpZHRoLFxuXHRcdFx0XHQnbWluLXdpZHRoJyA6IG92ZXJmbG93ID8gd2lkdGggOiAnJyxcblx0XHRcdFx0J21heC13aWR0aCcgOiBvdmVyZmxvdyA/IHdpZHRoIDogJydcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzZXRXaWR0aHMgOiBmdW5jdGlvbiggYywgd28sIHN0b3JlZFNpemVzICkge1xuXHRcdFx0dmFyIGNvbHVtbiwgJHRlbXAsXG5cdFx0XHRcdHZhcnMgPSB3by5yZXNpemFibGVfdmFycyxcblx0XHRcdFx0JGV4dHJhID0gJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX2hlYWRlcnMnICksXG5cdFx0XHRcdCRjb2wgPSBjLiR0YWJsZS5jaGlsZHJlbiggJ2NvbGdyb3VwJyApLmNoaWxkcmVuKCAnY29sJyApO1xuXHRcdFx0c3RvcmVkU2l6ZXMgPSBzdG9yZWRTaXplcyB8fCB2YXJzLnN0b3JlZFNpemVzIHx8IFtdO1xuXHRcdFx0Ly8gcHJvY2VzcyBvbmx5IGlmIHRhYmxlIElEIG9yIHVybCBtYXRjaFxuXHRcdFx0aWYgKCBzdG9yZWRTaXplcy5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGMuY29sdW1uczsgY29sdW1uKysgKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHNhdmVkIHJlc2l6YWJsZSB3aWR0aHNcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLCBzdG9yZWRTaXplc1sgY29sdW1uIF0sIHZhcnMub3ZlcmZsb3cgKTtcblx0XHRcdFx0XHRpZiAoICRleHRyYS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHQvLyBzdGlja3lIZWFkZXJzIG5lZWRzIHRvIG1vZGlmeSBtaW4gJiBtYXggd2lkdGggYXMgd2VsbFxuXHRcdFx0XHRcdFx0JHRlbXAgPSAkZXh0cmEuZXEoIGNvbHVtbiApLmFkZCggJGNvbC5lcSggY29sdW1uICkgKTtcblx0XHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aCggJHRlbXAsIHN0b3JlZFNpemVzWyBjb2x1bW4gXSwgdmFycy5vdmVyZmxvdyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQkdGVtcCA9ICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV90YWJsZScgKTtcblx0XHRcdFx0aWYgKCAkdGVtcC5sZW5ndGggJiYgIXRzLmhhc1dpZGdldCggYy50YWJsZSwgJ3Njcm9sbGVyJyApICkge1xuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aCggJHRlbXAsIGMuJHRhYmxlLm91dGVyV2lkdGgoKSwgdmFycy5vdmVyZmxvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldEhhbmRsZVBvc2l0aW9uIDogZnVuY3Rpb24oIGMsIHdvICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zaXRpb24sXG5cdFx0XHRcdHRhYmxlSGVpZ2h0ID0gYy4kdGFibGUuaGVpZ2h0KCksXG5cdFx0XHRcdCRoYW5kbGVzID0gd28uJHJlc2l6YWJsZV9jb250YWluZXIuY2hpbGRyZW4oKSxcblx0XHRcdFx0aGFuZGxlQ2VudGVyID0gTWF0aC5mbG9vciggJGhhbmRsZXMud2lkdGgoKSAvIDIgKTtcblxuXHRcdFx0aWYgKCB0cy5oYXNXaWRnZXQoIGMudGFibGUsICdzY3JvbGxlcicgKSApIHtcblx0XHRcdFx0dGFibGVIZWlnaHQgPSAwO1xuXHRcdFx0XHRjLiR0YWJsZS5jbG9zZXN0KCAnLicgKyB0cy5jc3Muc2Nyb2xsZXJXcmFwICkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHRcdFx0Ly8gY2VudGVyIHRhYmxlIGhhcyBhIG1heC1oZWlnaHQgc2V0XG5cdFx0XHRcdFx0dGFibGVIZWlnaHQgKz0gJHRoaXMuZmlsdGVyKCdbc3R5bGUqPVwiaGVpZ2h0XCJdJykubGVuZ3RoID8gJHRoaXMuaGVpZ2h0KCkgOiAkdGhpcy5jaGlsZHJlbigndGFibGUnKS5oZWlnaHQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXdvLnJlc2l6YWJsZV9pbmNsdWRlRm9vdGVyICYmIGMuJHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpLmxlbmd0aCApIHtcblx0XHRcdFx0dGFibGVIZWlnaHQgLT0gYy4kdGFibGUuY2hpbGRyZW4oJ3Rmb290JykuaGVpZ2h0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdWJ0cmFjdCBvdXQgdGFibGUgbGVmdCBwb3NpdGlvbiBmcm9tIHJlc2l6YWJsZSBoYW5kbGVzLiBGaXhlcyAjODY0XG5cdFx0XHQvLyBqUXVlcnkgdjMuMy4wKyBhcHBlYXJzIHRvIGluY2x1ZGUgdGhlIHN0YXJ0IHBvc2l0aW9uIHdpdGggdGhlICRoZWFkZXIucG9zaXRpb24oKS5sZWZ0OyBzZWUgIzE1NDRcblx0XHRcdHN0YXJ0UG9zaXRpb24gPSBwYXJzZUZsb2F0KCQuZm4uanF1ZXJ5KSA+PSAzLjMgPyAwIDogYy4kdGFibGUucG9zaXRpb24oKS5sZWZ0O1xuXHRcdFx0JGhhbmRsZXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXG5cdFx0XHRcdFx0Y29sdW1uID0gcGFyc2VJbnQoICR0aGlzLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKSxcblx0XHRcdFx0XHRjb2x1bW5zID0gYy5jb2x1bW5zIC0gMSxcblx0XHRcdFx0XHQkaGVhZGVyID0gJHRoaXMuZGF0YSggJ2hlYWRlcicgKTtcblx0XHRcdFx0aWYgKCAhJGhlYWRlciApIHsgcmV0dXJuOyB9IC8vIHNlZSAjODU5XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhJGhlYWRlci5pcygnOnZpc2libGUnKSB8fFxuXHRcdFx0XHRcdCggIXdvLnJlc2l6YWJsZV9hZGRMYXN0Q29sdW1uICYmIHRzLnJlc2l6YWJsZS5jaGVja1Zpc2libGVDb2x1bW5zKGMsIGNvbHVtbikgKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQkdGhpcy5oaWRlKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbHVtbiA8IGNvbHVtbnMgfHwgY29sdW1uID09PSBjb2x1bW5zICYmIHdvLnJlc2l6YWJsZV9hZGRMYXN0Q29sdW1uICkge1xuXHRcdFx0XHRcdCR0aGlzLmNzcyh7XG5cdFx0XHRcdFx0XHRkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcblx0XHRcdFx0XHRcdGhlaWdodCA6IHRhYmxlSGVpZ2h0LFxuXHRcdFx0XHRcdFx0bGVmdCA6ICRoZWFkZXIucG9zaXRpb24oKS5sZWZ0IC0gc3RhcnRQb3NpdGlvbiArICRoZWFkZXIub3V0ZXJXaWR0aCgpIC0gaGFuZGxlQ2VudGVyXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBGaXhlcyAjMTQ4NVxuXHRcdGNoZWNrVmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCBjLCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0bGVuID0gMDtcblx0XHRcdGZvciAoIGkgPSBjb2x1bW4gKyAxOyBpIDwgYy5jb2x1bW5zOyBpKysgKSB7XG5cdFx0XHRcdGxlbiArPSBjLiRoZWFkZXJJbmRleGVkW2ldLmlzKCAnOnZpc2libGUnICkgPyAxIDogMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsZW4gPT09IDA7XG5cdFx0fSxcblxuXHRcdC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hpbGUgZHJhZ2dpbmcgcmVzaXplIGJhclxuXHRcdHRvZ2dsZVRleHRTZWxlY3Rpb24gOiBmdW5jdGlvbiggYywgd28sIHRvZ2dsZSApIHtcblx0XHRcdHZhciBuYW1lc3BhY2UgPSBjLm5hbWVzcGFjZSArICd0c3Jlc2l6ZSc7XG5cdFx0XHR3by5yZXNpemFibGVfdmFycy5kaXNhYmxlZCA9IHRvZ2dsZTtcblx0XHRcdCQoICdib2R5JyApLnRvZ2dsZUNsYXNzKCB0cy5jc3MucmVzaXphYmxlTm9TZWxlY3QsIHRvZ2dsZSApO1xuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdCQoICdib2R5JyApXG5cdFx0XHRcdFx0LmF0dHIoICd1bnNlbGVjdGFibGUnLCAnb24nIClcblx0XHRcdFx0XHQuYmluZCggJ3NlbGVjdHN0YXJ0JyArIG5hbWVzcGFjZSwgZmFsc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoICdib2R5JyApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoICd1bnNlbGVjdGFibGUnIClcblx0XHRcdFx0XHQudW5iaW5kKCAnc2VsZWN0c3RhcnQnICsgbmFtZXNwYWNlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJpbmRpbmdzIDogZnVuY3Rpb24oIGMsIHdvICkge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3RzcmVzaXplJztcblx0XHRcdHdvLiRyZXNpemFibGVfY29udGFpbmVyLmNoaWxkcmVuKCkuYmluZCggJ21vdXNlZG93bicsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gc2F2ZSBoZWFkZXIgY2VsbCBhbmQgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dmFyIGNvbHVtbixcblx0XHRcdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnMsXG5cdFx0XHRcdFx0JGV4dHJhcyA9ICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV9oZWFkZXJzJyApLFxuXHRcdFx0XHRcdCRoZWFkZXIgPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCAnaGVhZGVyJyApO1xuXG5cdFx0XHRcdGNvbHVtbiA9IHBhcnNlSW50KCAkaGVhZGVyLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKTtcblx0XHRcdFx0dmFycy4kdGFyZ2V0ID0gJGhlYWRlciA9ICRoZWFkZXIuYWRkKCAkZXh0cmFzLmZpbHRlcignW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICdcIl0nKSApO1xuXHRcdFx0XHR2YXJzLnRhcmdldCA9IGNvbHVtbjtcblxuXHRcdFx0XHQvLyBpZiB0YWJsZSBpcyBub3QgYXMgd2lkZSBhcyBpdCdzIHBhcmVudCwgdGhlbiByZXNpemUgdGhlIHRhYmxlXG5cdFx0XHRcdHZhcnMuJG5leHQgPSBldmVudC5zaGlmdEtleSB8fCB3by5yZXNpemFibGVfdGFyZ2V0TGFzdCA/XG5cdFx0XHRcdFx0JGhlYWRlci5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdCggJy5yZXNpemFibGUtZmFsc2UnICkuZmlsdGVyKCAnOmxhc3QnICkgOlxuXHRcdFx0XHRcdCRoZWFkZXIubmV4dEFsbCggJzpub3QoLnJlc2l6YWJsZS1mYWxzZSknICkuZXEoIDAgKTtcblxuXHRcdFx0XHRjb2x1bW4gPSBwYXJzZUludCggdmFycy4kbmV4dC5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICk7XG5cdFx0XHRcdHZhcnMuJG5leHQgPSB2YXJzLiRuZXh0LmFkZCggJGV4dHJhcy5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCJdJykgKTtcblx0XHRcdFx0dmFycy5uZXh0ID0gY29sdW1uO1xuXG5cdFx0XHRcdHZhcnMubW91c2VYUG9zaXRpb24gPSBldmVudC5wYWdlWDtcblx0XHRcdFx0dHMucmVzaXphYmxlLnVwZGF0ZVN0b3JlZFNpemVzKCBjLCB3byApO1xuXHRcdFx0XHR0cy5yZXNpemFibGUudG9nZ2xlVGV4dFNlbGVjdGlvbihjLCB3bywgdHJ1ZSApO1xuXHRcdFx0fSk7XG5cblx0XHRcdCQoIGRvY3VtZW50IClcblx0XHRcdFx0LmJpbmQoICdtb3VzZW1vdmUnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0dmFyIHZhcnMgPSB3by5yZXNpemFibGVfdmFycztcblx0XHRcdFx0XHQvLyBpZ25vcmUgbW91c2Vtb3ZlIGlmIG5vIG1vdXNlZG93blxuXHRcdFx0XHRcdGlmICggIXZhcnMuZGlzYWJsZWQgfHwgdmFycy5tb3VzZVhQb3NpdGlvbiA9PT0gMCB8fCAhdmFycy4kdGFyZ2V0ICkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRpZiAoIHdvLnJlc2l6YWJsZV90aHJvdHRsZSApIHtcblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggdmFycy50aW1lciApO1xuXHRcdFx0XHRcdFx0dmFycy50aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0cy5yZXNpemFibGUubW91c2VNb3ZlKCBjLCB3bywgZXZlbnQgKTtcblx0XHRcdFx0XHRcdH0sIGlzTmFOKCB3by5yZXNpemFibGVfdGhyb3R0bGUgKSA/IDUgOiB3by5yZXNpemFibGVfdGhyb3R0bGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHMucmVzaXphYmxlLm1vdXNlTW92ZSggYywgd28sIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggJ21vdXNldXAnICsgbmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIXdvLnJlc2l6YWJsZV92YXJzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZS50b2dnbGVUZXh0U2VsZWN0aW9uKCBjLCB3bywgZmFsc2UgKTtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc3RvcFJlc2l6ZSggYywgd28gKTtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0SGFuZGxlUG9zaXRpb24oIGMsIHdvICk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyByZXNpemVFbmQgZXZlbnQgdHJpZ2dlcmVkIGJ5IHNjcm9sbGVyIHdpZGdldFxuXHRcdFx0JCggd2luZG93ICkuYmluZCggJ3Jlc2l6ZScgKyBuYW1lc3BhY2UgKyAnIHJlc2l6ZUVuZCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cy5yZXNpemFibGUuc2V0SGFuZGxlUG9zaXRpb24oIGMsIHdvICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmlnaHQgY2xpY2sgdG8gcmVzZXQgY29sdW1ucyB0byBkZWZhdWx0IHdpZHRoc1xuXHRcdFx0Yy4kdGFibGVcblx0XHRcdFx0LmJpbmQoICdjb2x1bW5VcGRhdGUgcGFnZXJDb21wbGV0ZSByZXNpemFibGVVcGRhdGUgJy5zcGxpdCggJyAnICkuam9pbiggbmFtZXNwYWNlICsgJyAnICksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRIYW5kbGVQb3NpdGlvbiggYywgd28gKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoICdyZXNpemFibGVSZXNldCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZVJlc2V0KCBjLnRhYmxlICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5maW5kKCAndGhlYWQ6Zmlyc3QnIClcblx0XHRcdFx0LmFkZCggJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX3RhYmxlJyApLmZpbmQoICd0aGVhZDpmaXJzdCcgKSApXG5cdFx0XHRcdC5iaW5kKCAnY29udGV4dG1lbnUnICsgbmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyAkLmlzRW1wdHlPYmplY3QoKSBuZWVkcyBqUXVlcnkgMS40KzsgYWxsb3cgcmlnaHQgY2xpY2sgaWYgYWxyZWFkeSByZXNldFxuXHRcdFx0XHRcdHZhciBhbGxvd0NsaWNrID0gd28ucmVzaXphYmxlX3ZhcnMuc3RvcmVkU2l6ZXMubGVuZ3RoID09PSAwO1xuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZVJlc2V0KCBjLnRhYmxlICk7XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldEhhbmRsZVBvc2l0aW9uKCBjLCB3byApO1xuXHRcdFx0XHRcdHdvLnJlc2l6YWJsZV92YXJzLnN0b3JlZFNpemVzID0gW107XG5cdFx0XHRcdFx0cmV0dXJuIGFsbG93Q2xpY2s7XG5cdFx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdG1vdXNlTW92ZSA6IGZ1bmN0aW9uKCBjLCB3bywgZXZlbnQgKSB7XG5cdFx0XHRpZiAoIHdvLnJlc2l6YWJsZV92YXJzLm1vdXNlWFBvc2l0aW9uID09PSAwIHx8ICF3by5yZXNpemFibGVfdmFycy4kdGFyZ2V0ICkgeyByZXR1cm47IH1cblx0XHRcdC8vIHJlc2l6ZSBjb2x1bW5zXG5cdFx0XHR2YXIgY29sdW1uLFxuXHRcdFx0XHR0b3RhbCA9IDAsXG5cdFx0XHRcdHZhcnMgPSB3by5yZXNpemFibGVfdmFycyxcblx0XHRcdFx0JG5leHQgPSB2YXJzLiRuZXh0LFxuXHRcdFx0XHR0YXIgPSB2YXJzLnN0b3JlZFNpemVzWyB2YXJzLnRhcmdldCBdLFxuXHRcdFx0XHRsZWZ0RWRnZSA9IGV2ZW50LnBhZ2VYIC0gdmFycy5tb3VzZVhQb3NpdGlvbjtcblx0XHRcdGlmICggdmFycy5vdmVyZmxvdyApIHtcblx0XHRcdFx0aWYgKCB0YXIgKyBsZWZ0RWRnZSA+IDAgKSB7XG5cdFx0XHRcdFx0dmFycy5zdG9yZWRTaXplc1sgdmFycy50YXJnZXQgXSArPSBsZWZ0RWRnZTtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoIHZhcnMuJHRhcmdldCwgdmFycy5zdG9yZWRTaXplc1sgdmFycy50YXJnZXQgXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgZW50aXJlIHRhYmxlIHdpZHRoXG5cdFx0XHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgYy5jb2x1bW5zOyBjb2x1bW4rKyApIHtcblx0XHRcdFx0XHRcdHRvdGFsICs9IHZhcnMuc3RvcmVkU2l6ZXNbIGNvbHVtbiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoIGMuJHRhYmxlLmFkZCggJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX3RhYmxlJyApICksIHRvdGFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJG5leHQubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGlmIGV4cGFuZGluZyByaWdodC1tb3N0IGNvbHVtbiwgc2Nyb2xsIHRoZSB3cmFwcGVyXG5cdFx0XHRcdFx0dmFycy4kd3JhcFswXS5zY3JvbGxMZWZ0ID0gYy4kdGFibGUud2lkdGgoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdmFycy5mdWxsV2lkdGggKSB7XG5cdFx0XHRcdHZhcnMuc3RvcmVkU2l6ZXNbIHZhcnMudGFyZ2V0IF0gKz0gbGVmdEVkZ2U7XG5cdFx0XHRcdHZhcnMuc3RvcmVkU2l6ZXNbIHZhcnMubmV4dCBdIC09IGxlZnRFZGdlO1xuXHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGhzKCBjLCB3byApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFycy5zdG9yZWRTaXplc1sgdmFycy50YXJnZXQgXSArPSBsZWZ0RWRnZTtcblx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRocyggYywgd28gKTtcblx0XHRcdH1cblx0XHRcdHZhcnMubW91c2VYUG9zaXRpb24gPSBldmVudC5wYWdlWDtcblx0XHRcdC8vIGR5bmFtaWNhbGx5IHVwZGF0ZSBzdGlja3kgaGVhZGVyIHdpZHRoc1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoJ3N0aWNreUhlYWRlcnNVcGRhdGUnKTtcblx0XHR9LFxuXG5cdFx0c3RvcFJlc2l6ZSA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciB2YXJzID0gd28ucmVzaXphYmxlX3ZhcnM7XG5cdFx0XHR0cy5yZXNpemFibGUudXBkYXRlU3RvcmVkU2l6ZXMoIGMsIHdvICk7XG5cdFx0XHRpZiAoIHZhcnMudXNlU3RvcmFnZSApIHtcblx0XHRcdFx0Ly8gc2F2ZSBhbGwgY29sdW1uIHdpZHRoc1xuXHRcdFx0XHR0cy5zdG9yYWdlKCBjLnRhYmxlLCB0cy5jc3MucmVzaXphYmxlU3RvcmFnZSwgdmFycy5zdG9yZWRTaXplcyApO1xuXHRcdFx0XHR0cy5zdG9yYWdlKCBjLnRhYmxlLCAndGFibGVzb3J0ZXItdGFibGUtcmVzaXplZC13aWR0aCcsIGMuJHRhYmxlLndpZHRoKCkgKTtcblx0XHRcdH1cblx0XHRcdHZhcnMubW91c2VYUG9zaXRpb24gPSAwO1xuXHRcdFx0dmFycy4kdGFyZ2V0ID0gdmFycy4kbmV4dCA9IG51bGw7XG5cdFx0XHQvLyB3aWxsIHVwZGF0ZSBzdGlja3lIZWFkZXJzLCBqdXN0IGluIGNhc2UsIHNlZSAjOTEyXG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlcignc3RpY2t5SGVhZGVyc1VwZGF0ZScpO1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6YWJsZUNvbXBsZXRlJyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIHRoaXMgd2lkZ2V0IHNhdmVzIHRoZSBjb2x1bW4gd2lkdGhzIGlmXG5cdC8vICQudGFibGVzb3J0ZXIuc3RvcmFnZSBmdW5jdGlvbiBpcyBpbmNsdWRlZFxuXHQvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHR0cy5hZGRXaWRnZXQoe1xuXHRcdGlkOiAncmVzaXphYmxlJyxcblx0XHRwcmlvcml0eTogNDAsXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0cmVzaXphYmxlIDogdHJ1ZSwgLy8gc2F2ZSBjb2x1bW4gd2lkdGhzIHRvIHN0b3JhZ2Vcblx0XHRcdHJlc2l6YWJsZV9hZGRMYXN0Q29sdW1uIDogZmFsc2UsXG5cdFx0XHRyZXNpemFibGVfaW5jbHVkZUZvb3RlcjogdHJ1ZSxcblx0XHRcdHJlc2l6YWJsZV93aWR0aHMgOiBbXSxcblx0XHRcdHJlc2l6YWJsZV90aHJvdHRsZSA6IGZhbHNlLCAvLyBzZXQgdG8gdHJ1ZSAoNW1zKSBvciBhbnkgbnVtYmVyIDAtMTAgcmFuZ2Vcblx0XHRcdHJlc2l6YWJsZV90YXJnZXRMYXN0IDogZmFsc2Vcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhYmxlLCB0aGlzV2lkZ2V0LCBjLCB3bykge1xuXHRcdFx0dHMucmVzaXphYmxlLmluaXQoIGMsIHdvICk7XG5cdFx0fSxcblx0XHRmb3JtYXQ6IGZ1bmN0aW9uKCB0YWJsZSwgYywgd28gKSB7XG5cdFx0XHR0cy5yZXNpemFibGUuc2V0SGFuZGxlUG9zaXRpb24oIGMsIHdvICk7XG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCB0YWJsZSwgYywgd28sIHJlZnJlc2hpbmcgKSB7XG5cdFx0XHRpZiAod28uJHJlc2l6YWJsZV9jb250YWluZXIpIHtcblx0XHRcdFx0dmFyIG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3RzcmVzaXplJztcblx0XHRcdFx0Yy4kdGFibGUuYWRkKCAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfdGFibGUnICkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcygnaGFzUmVzaXphYmxlJylcblx0XHRcdFx0XHQuY2hpbGRyZW4oICd0aGVhZCcgKVxuXHRcdFx0XHRcdC51bmJpbmQoICdjb250ZXh0bWVudScgKyBuYW1lc3BhY2UgKTtcblxuXHRcdFx0XHR3by4kcmVzaXphYmxlX2NvbnRhaW5lci5yZW1vdmUoKTtcblx0XHRcdFx0dHMucmVzaXphYmxlLnRvZ2dsZVRleHRTZWxlY3Rpb24oIGMsIHdvLCBmYWxzZSApO1xuXHRcdFx0XHR0cy5yZXNpemFibGVSZXNldCggdGFibGUsIHJlZnJlc2hpbmcgKTtcblx0XHRcdFx0JCggZG9jdW1lbnQgKS51bmJpbmQoICdtb3VzZW1vdmUnICsgbmFtZXNwYWNlICsgJyBtb3VzZXVwJyArIG5hbWVzcGFjZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0dHMucmVzaXphYmxlUmVzZXQgPSBmdW5jdGlvbiggdGFibGUsIHJlZnJlc2hpbmcgKSB7XG5cdFx0JCggdGFibGUgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LCAkdCxcblx0XHRcdFx0YyA9IHRoaXMuY29uZmlnLFxuXHRcdFx0XHR3byA9IGMgJiYgYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnM7XG5cdFx0XHRpZiAoIHRhYmxlICYmIGMgJiYgYy4kaGVhZGVySW5kZXhlZC5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIHJlc3RvcmUgdGhlIGluaXRpYWwgdGFibGUgd2lkdGhcblx0XHRcdFx0aWYgKCB2YXJzLm92ZXJmbG93ICYmIHZhcnMudGFibGVXaWR0aCApIHtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoIGMuJHRhYmxlLCB2YXJzLnRhYmxlV2lkdGgsIHRydWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhcnMudXNlU3RvcmFnZSApIHtcblx0XHRcdFx0XHRcdHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItdGFibGUtcmVzaXplZC13aWR0aCcsIHZhcnMudGFibGVXaWR0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgYy5jb2x1bW5zOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdCR0ID0gYy4kaGVhZGVySW5kZXhlZFsgaW5kZXggXTtcblx0XHRcdFx0XHRpZiAoIHdvLnJlc2l6YWJsZV93aWR0aHMgJiYgd28ucmVzaXphYmxlX3dpZHRoc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aCggJHQsIHdvLnJlc2l6YWJsZV93aWR0aHNbIGluZGV4IF0sIHZhcnMub3ZlcmZsb3cgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhJHQuaGFzQ2xhc3MoICdyZXNpemFibGUtZmFsc2UnICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBkb24ndCBjbGVhciB0aGUgd2lkdGggb2YgYW55IGNvbHVtbiB0aGF0IGlzIG5vdCByZXNpemFibGVcblx0XHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aCggJHQsICcnLCB2YXJzLm92ZXJmbG93ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzZXQgc3RpY2t5SGVhZGVyIHdpZHRoc1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3N0aWNreUhlYWRlcnNVcGRhdGUnICk7XG5cdFx0XHRcdGlmICggdHMuc3RvcmFnZSAmJiAhcmVmcmVzaGluZyApIHtcblx0XHRcdFx0XHR0cy5zdG9yYWdlKCB0aGlzLCB0cy5jc3MucmVzaXphYmxlU3RvcmFnZSwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG59KSggalF1ZXJ5LCB3aW5kb3cgKTtcblxyXG4vKiEgV2lkZ2V0OiBzYXZlU29ydCAtIHVwZGF0ZWQgMjAxOC0wMy0xOSAodjIuMzAuMSkgKi8vKlxuKiBSZXF1aXJlcyB0YWJsZXNvcnRlciB2Mi4xNitcbiogYnkgUm9iIEdhcnJpc29uXG4qL1xuOyhmdW5jdGlvbiAoJCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciB0cyA9ICQudGFibGVzb3J0ZXIgfHwge307XG5cblx0ZnVuY3Rpb24gZ2V0U3RvcmVkU29ydExpc3QoYykge1xuXHRcdHZhciBzdG9yZWQgPSB0cy5zdG9yYWdlKCBjLnRhYmxlLCAndGFibGVzb3J0ZXItc2F2ZXNvcnQnICk7XG5cdFx0cmV0dXJuIChzdG9yZWQgJiYgc3RvcmVkLmhhc093blByb3BlcnR5KCdzb3J0TGlzdCcpICYmICQuaXNBcnJheShzdG9yZWQuc29ydExpc3QpKSA/IHN0b3JlZC5zb3J0TGlzdCA6IFtdO1xuXHR9XG5cblx0ZnVuY3Rpb24gc29ydExpc3RDaGFuZ2VkKGMsIHNvcnRMaXN0KSB7XG5cdFx0cmV0dXJuIChzb3J0TGlzdCB8fCBnZXRTdG9yZWRTb3J0TGlzdChjKSkuam9pbignLCcpICE9PSBjLnNvcnRMaXN0LmpvaW4oJywnKTtcblx0fVxuXG5cdC8vIHRoaXMgd2lkZ2V0IHNhdmVzIHRoZSBsYXN0IHNvcnQgb25seSBpZiB0aGVcblx0Ly8gc2F2ZVNvcnQgd2lkZ2V0IG9wdGlvbiBpcyB0cnVlIEFORCB0aGVcblx0Ly8gJC50YWJsZXNvcnRlci5zdG9yYWdlIGZ1bmN0aW9uIGlzIGluY2x1ZGVkXG5cdC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdHRzLmFkZFdpZGdldCh7XG5cdFx0aWQ6ICdzYXZlU29ydCcsXG5cdFx0cHJpb3JpdHk6IDIwLFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHNhdmVTb3J0IDogdHJ1ZVxuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24odGFibGUsIHRoaXNXaWRnZXQsIGMsIHdvKSB7XG5cdFx0XHQvLyBydW4gd2lkZ2V0IGZvcm1hdCBiZWZvcmUgYWxsIG90aGVyIHdpZGdldHMgYXJlIGFwcGxpZWQgdG8gdGhlIHRhYmxlXG5cdFx0XHR0aGlzV2lkZ2V0LmZvcm1hdCh0YWJsZSwgYywgd28sIHRydWUpO1xuXHRcdH0sXG5cdFx0Zm9ybWF0OiBmdW5jdGlvbih0YWJsZSwgYywgd28sIGluaXQpIHtcblx0XHRcdHZhciB0aW1lLFxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcblx0XHRcdFx0c2F2ZVNvcnQgPSB3by5zYXZlU29ydCAhPT0gZmFsc2UsIC8vIG1ha2Ugc2F2ZVNvcnQgYWN0aXZlL2luYWN0aXZlOyBkZWZhdWx0IHRvIHRydWVcblx0XHRcdFx0c29ydExpc3QgPSB7ICdzb3J0TGlzdCcgOiBjLnNvcnRMaXN0IH0sXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ3NhdmVTb3J0Jyk7XG5cdFx0XHRpZiAoZGVidWcpIHtcblx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJHRhYmxlLmhhc0NsYXNzKCdoYXNTYXZlU29ydCcpKSB7XG5cdFx0XHRcdGlmIChzYXZlU29ydCAmJiB0YWJsZS5oYXNJbml0aWFsaXplZCAmJiB0cy5zdG9yYWdlICYmIHNvcnRMaXN0Q2hhbmdlZChjKSkge1xuXHRcdFx0XHRcdHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItc2F2ZXNvcnQnLCBzb3J0TGlzdCApO1xuXHRcdFx0XHRcdGlmIChkZWJ1Zykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ3NhdmVTb3J0ID4+IFNhdmluZyBsYXN0IHNvcnQ6ICcgKyBjLnNvcnRMaXN0ICsgdHMuYmVuY2htYXJrKHRpbWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNldCB0YWJsZSBzb3J0IG9uIGluaXRpYWwgcnVuIG9mIHRoZSB3aWRnZXRcblx0XHRcdFx0JHRhYmxlLmFkZENsYXNzKCdoYXNTYXZlU29ydCcpO1xuXHRcdFx0XHRzb3J0TGlzdCA9ICcnO1xuXHRcdFx0XHQvLyBnZXQgZGF0YVxuXHRcdFx0XHRpZiAodHMuc3RvcmFnZSkge1xuXHRcdFx0XHRcdHNvcnRMaXN0ID0gZ2V0U3RvcmVkU29ydExpc3QoYyk7XG5cdFx0XHRcdFx0aWYgKGRlYnVnKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnc2F2ZVNvcnQgPj4gTGFzdCBzb3J0IGxvYWRlZDogXCInICsgc29ydExpc3QgKyAnXCInICsgdHMuYmVuY2htYXJrKHRpbWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JHRhYmxlLmJpbmQoJ3NhdmVTb3J0UmVzZXQnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR0cy5zdG9yYWdlKCB0YWJsZSwgJ3RhYmxlc29ydGVyLXNhdmVzb3J0JywgJycgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpbml0IGlzIHRydWUgd2hlbiB3aWRnZXQgaW5pdCBpcyBydW4sIHRoaXMgd2lsbCBydW4gdGhpcyB3aWRnZXQgYmVmb3JlIGFsbCBvdGhlciB3aWRnZXRzIGhhdmUgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Ly8gdGhpcyBtZXRob2QgYWxsb3dzIHVzaW5nIHRoaXMgd2lkZ2V0IGluIHRoZSBvcmlnaW5hbCB0YWJsZXNvcnRlciBwbHVnaW47IGJ1dCB0aGVuIGl0IHdpbGwgcnVuIGFsbCB3aWRnZXRzIHR3aWNlLlxuXHRcdFx0XHRpZiAoaW5pdCAmJiBzb3J0TGlzdCAmJiBzb3J0TGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Yy5zb3J0TGlzdCA9IHNvcnRMaXN0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhYmxlLmhhc0luaXRpYWxpemVkICYmIHNvcnRMaXN0ICYmIHNvcnRMaXN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyB1cGRhdGUgc29ydCBjaGFuZ2Vcblx0XHRcdFx0XHRpZiAoc29ydExpc3RDaGFuZ2VkKGMsIHNvcnRMaXN0KSkge1xuXHRcdFx0XHRcdFx0dHMuc29ydE9uKGMsIHNvcnRMaXN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24odGFibGUsIGMpIHtcblx0XHRcdGMuJHRhYmxlLnJlbW92ZUNsYXNzKCdoYXNTYXZlU29ydCcpO1xuXHRcdFx0Ly8gY2xlYXIgc3RvcmFnZVxuXHRcdFx0aWYgKHRzLnN0b3JhZ2UpIHsgdHMuc3RvcmFnZSggdGFibGUsICd0YWJsZXNvcnRlci1zYXZlc29ydCcsICcnICk7IH1cblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpO1xucmV0dXJuIGpRdWVyeS50YWJsZXNvcnRlcjt9KSk7XHJcbiIsIihmdW5jdGlvbihmYWN0b3J5KXtpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXtkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKXttb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO30gZWxzZSB7ZmFjdG9yeShqUXVlcnkpO319KGZ1bmN0aW9uKGpRdWVyeSl7XG5cbiFmdW5jdGlvbihoKXtcInVzZSBzdHJpY3RcIjt2YXIgZj1oLnRhYmxlc29ydGVyLGM9XCIudHNjb2xzZWxcIixTPWYuY29sdW1uU2VsZWN0b3I9e3F1ZXJ5QWxsOlwiQG1lZGlhIG9ubHkgYWxsIHsgW2NvbHVtbnNdIHsgZGlzcGxheTogbm9uZTsgfSB9IFwiLHF1ZXJ5QnJlYWs6XCJAbWVkaWEgYWxsIGFuZCAobWluLXdpZHRoOiBbc2l6ZV0pIHsgW2NvbHVtbnNdIHsgZGlzcGxheTogdGFibGUtY2VsbDsgfSB9IFwiLGluaXQ6ZnVuY3Rpb24oZSx0LG8pe3ZhciBsLGEsbj1mLmRlYnVnKHQsXCJjb2x1bW5TZWxlY3RvclwiKTsobD1oKG8uY29sdW1uU2VsZWN0b3JfbGF5b3V0KSkuZmluZChcImlucHV0XCIpLmFkZChsLmZpbHRlcihcImlucHV0XCIpKS5sZW5ndGg/KHQuJHRhYmxlLmFkZENsYXNzKHQubmFtZXNwYWNlLnNsaWNlKDEpK1wiY29sdW1uc2VsZWN0b3JcIiksKGE9dC5zZWxlY3Rvcj17JGNvbnRhaW5lcjpoKG8uY29sdW1uU2VsZWN0b3JfY29udGFpbmVyfHxcIjxkaXY+XCIpfSkuJHN0eWxlPWgoXCI8c3R5bGU+PC9zdHlsZT5cIikucHJvcChcImRpc2FibGVkXCIsITApLmFwcGVuZFRvKFwiaGVhZFwiKSxhLiRicmVha3BvaW50cz1oKFwiPHN0eWxlPjwvc3R5bGU+XCIpLnByb3AoXCJkaXNhYmxlZFwiLCEwKS5hcHBlbmRUbyhcImhlYWRcIiksYS5pc0luaXRpYWxpemluZz0hMCxTLnNldFVwQ29sc3Bhbih0LG8pLFMuc2V0dXBTZWxlY3Rvcih0LG8pLG8uY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeSYmUy5zZXR1cEJyZWFrcG9pbnRzKHQsbyksYS5pc0luaXRpYWxpemluZz0hMSxhLiRjb250YWluZXIubGVuZ3RoP1MudXBkYXRlQ29scyh0LG8pOm4mJmNvbnNvbGUud2FybihcIkNvbHVtblNlbGVjdG9yID4+IGNvbnRhaW5lciBub3QgZm91bmRcIiksdC4kdGFibGUub2ZmKFwicmVmcmVzaENvbHVtblNlbGVjdG9yXCIrYykub24oXCJyZWZyZXNoQ29sdW1uU2VsZWN0b3JcIitjLGZ1bmN0aW9uKGUsdCxvKXtTLnJlZnJlc2hDb2x1bW5zKHRoaXMuY29uZmlnLHQsbyl9KSxuJiZjb25zb2xlLmxvZyhcIkNvbHVtblNlbGVjdG9yID4+IFdpZGdldCBpbml0aWFsaXplZFwiKSk6biYmY29uc29sZS5lcnJvcihcIkNvbHVtblNlbGVjdG9yID4+IEVSUk9SOiBDb2x1bW4gU2VsZWN0b3IgYWJvcnRpbmcsIG5vIGlucHV0IGZvdW5kIGluIHRoZSBsYXlvdXQhICoqKlwiKX0scmVmcmVzaENvbHVtbnM6ZnVuY3Rpb24oZSx0LG8pe3ZhciBsLGEsbixjLHI9ZS5zZWxlY3RvcixzPWguaXNBcnJheShvfHx0KSxpPWUud2lkZ2V0T3B0aW9ucztpZihudWxsIT10JiZyLiRjb250YWluZXIubGVuZ3RoKXtpZihcInNlbGVjdG9yc1wiPT09dCYmKHIuJGNvbnRhaW5lci5lbXB0eSgpLFMuc2V0dXBTZWxlY3RvcihlLGkpLFMuc2V0dXBCcmVha3BvaW50cyhlLGkpLHZvaWQgMD09PW8mJm51bGwhPT1vJiYobz1yLmF1dG8pKSxzKWZvcihhPW98fHQsaC5lYWNoKGEsZnVuY3Rpb24oZSx0KXthW2VdPXBhcnNlSW50KHQsMTApfSksbD0wO2w8ZS5jb2x1bW5zO2wrKyljPTA8PWguaW5BcnJheShsLGEpLChuPXIuJGNvbnRhaW5lci5maW5kKFwiaW5wdXRbZGF0YS1jb2x1bW49XCIrbCtcIl1cIikpLmxlbmd0aCYmKG4ucHJvcChcImNoZWNrZWRcIixjKSxyLnN0YXRlc1tsXT1jKTtjPSEwPT09b3x8ITA9PT10fHxcImF1dG9cIj09PXQmJiExIT09byxuPXIuJGNvbnRhaW5lci5maW5kKCdpbnB1dFtkYXRhLWNvbHVtbj1cImF1dG9cIl0nKS5wcm9wKFwiY2hlY2tlZFwiLGMpLFMudXBkYXRlQXV0byhlLGksbil9ZWxzZSBTLnVwZGF0ZUJyZWFrcG9pbnRzKGUsaSksUy51cGRhdGVDb2xzKGUsaSk7Uy5zYXZlVmFsdWVzKGUsaSksUy5hZGp1c3RDb2xzcGFucyhlLGkpfSxzZXR1cFNlbGVjdG9yOmZ1bmN0aW9uKHQsbyl7dmFyIGUsbCxhLG4sYyxyLHMsaT10LnNlbGVjdG9yLHU9aS4kY29udGFpbmVyLGQ9by5jb2x1bW5TZWxlY3Rvcl9zYXZlQ29sdW1ucyYmZi5zdG9yYWdlLHA9ZD9mLnN0b3JhZ2UodC50YWJsZSxcInRhYmxlc29ydGVyLWNvbHVtblNlbGVjdG9yXCIpOltdLG09ZD9mLnN0b3JhZ2UodC50YWJsZSxcInRhYmxlc29ydGVyLWNvbHVtblNlbGVjdG9yLWF1dG9cIik6e307Zm9yKGkuYXV0bz1oLmlzRW1wdHlPYmplY3QobSl8fFwiYm9vbGVhblwiIT09aC50eXBlKG0uYXV0byk/by5jb2x1bW5TZWxlY3Rvcl9tZWRpYXF1ZXJ5U3RhdGU6bS5hdXRvLGkuc3RhdGVzPVtdLGkuJGNvbHVtbj1bXSxpLiR3cmFwcGVyPVtdLGkuJGNoZWNrYm94PVtdLGU9MDtlPHQuY29sdW1ucztlKyspbj0oYT10LiRoZWFkZXJJbmRleGVkW2VdKS5hdHRyKG8uY29sdW1uU2VsZWN0b3JfcHJpb3JpdHkpfHwxLHI9YS5hdHRyKFwiZGF0YS1jb2x1bW5cIiksYz1mLmdldENvbHVtbkRhdGEodC50YWJsZSx0LmhlYWRlcnMsciksbT1mLmdldERhdGEoYSxjLFwiY29sdW1uU2VsZWN0b3JcIiksaXNOYU4obikmJjA8bi5sZW5ndGh8fFwiZGlzYWJsZVwiPT09bXx8by5jb2x1bW5TZWxlY3Rvcl9jb2x1bW5zW3JdJiZcImRpc2FibGVcIj09PW8uY29sdW1uU2VsZWN0b3JfY29sdW1uc1tyXT9pLnN0YXRlc1tyXT1udWxsOihpLnN0YXRlc1tyXT1wJiZ2b2lkIDAhPT1wW3JdJiZudWxsIT09cFtyXT9wW3JdOnZvaWQgMCE9PW8uY29sdW1uU2VsZWN0b3JfY29sdW1uc1tyXSYmbnVsbCE9PW8uY29sdW1uU2VsZWN0b3JfY29sdW1uc1tyXT9vLmNvbHVtblNlbGVjdG9yX2NvbHVtbnNbcl06XCJ0cnVlXCI9PT1tfHxcImZhbHNlXCIhPT1tLGkuJGNvbHVtbltyXT1oKHRoaXMpLHUubGVuZ3RoJiYobD1hLmF0dHIoby5jb2x1bW5TZWxlY3Rvcl9uYW1lKXx8YS50ZXh0KCkudHJpbSgpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uY29sdW1uU2VsZWN0b3JfbGF5b3V0Q3VzdG9taXplciYmKHM9YS5maW5kKFwiLlwiK2YuY3NzLmhlYWRlckluKSxsPW8uY29sdW1uU2VsZWN0b3JfbGF5b3V0Q3VzdG9taXplcihzLmxlbmd0aD9zOmEsbCxwYXJzZUludChyLDEwKSkpLGkuJHdyYXBwZXJbcl09aChvLmNvbHVtblNlbGVjdG9yX2xheW91dC5yZXBsYWNlKC9cXHtuYW1lXFx9L2csbCkpLmFwcGVuZFRvKHUpLGkuJGNoZWNrYm94W3JdPWkuJHdyYXBwZXJbcl0uZmluZChcImlucHV0XCIpLmFkZChpLiR3cmFwcGVyW3JdLmZpbHRlcihcImlucHV0XCIpKS5hdHRyKFwiZGF0YS1jb2x1bW5cIixyKS50b2dnbGVDbGFzcyhvLmNvbHVtblNlbGVjdG9yX2Nzc0NoZWNrZWQsaS5zdGF0ZXNbcl0pLnByb3AoXCJjaGVja2VkXCIsaS5zdGF0ZXNbcl0pLm9uKFwiY2hhbmdlXCIsZnVuY3Rpb24oKXtpZighaS5pc0luaXRpYWxpemluZyl7dmFyIGU9aCh0aGlzKS5hdHRyKFwiZGF0YS1jb2x1bW5cIik7aWYoIVMuY2hlY2tDaGFuZ2UodCx0aGlzLmNoZWNrZWQpKXJldHVybiB0aGlzLmNoZWNrZWQ9IXRoaXMuY2hlY2tlZCwhMTt0LnNlbGVjdG9yLnN0YXRlc1tlXT10aGlzLmNoZWNrZWQsUy51cGRhdGVDb2xzKHQsbyl9fSkuY2hhbmdlKCkpKX0sY2hlY2tDaGFuZ2U6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG89ZS53aWRnZXRPcHRpb25zLGw9by5jb2x1bW5TZWxlY3Rvcl9tYXhWaXNpYmxlLGE9by5jb2x1bW5TZWxlY3Rvcl9taW5WaXNpYmxlLG49ZS5zZWxlY3Rvci5zdGF0ZXMsYz1uLmxlbmd0aCxyPTA7MDw9Yy0tOyluW2NdJiZyKys7cmV0dXJuISh0Jm51bGwhPT1sJiZsPD1yfHwhdCYmbnVsbCE9PWEmJnI8PWEpfSxzZXR1cEJyZWFrcG9pbnRzOmZ1bmN0aW9uKGUsdCl7dmFyIG89ZS5zZWxlY3Rvcjt0LmNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnkmJihvLmxhc3RJbmRleD0tMSxTLnVwZGF0ZUJyZWFrcG9pbnRzKGUsdCksZS4kdGFibGUub2ZmKFwidXBkYXRlQWxsXCIrYykub24oXCJ1cGRhdGVBbGxcIitjLGZ1bmN0aW9uKCl7Uy5zZXR1cFNlbGVjdG9yKGUsdCksUy5zZXR1cEJyZWFrcG9pbnRzKGUsdCksUy51cGRhdGVCcmVha3BvaW50cyhlLHQpLFMudXBkYXRlQ29scyhlLHQpfSkpLG8uJGNvbnRhaW5lci5sZW5ndGgmJih0LmNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnkmJihvLiRhdXRvPWgodC5jb2x1bW5TZWxlY3Rvcl9sYXlvdXQucmVwbGFjZSgvXFx7bmFtZVxcfS9nLHQuY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeU5hbWUpKS5wcmVwZW5kVG8oby4kY29udGFpbmVyKSxvLiRhdXRvLmZpbmQoXCJpbnB1dFwiKS5hZGQoby4kYXV0by5maWx0ZXIoXCJpbnB1dFwiKSkuYXR0cihcImRhdGEtY29sdW1uXCIsXCJhdXRvXCIpLnByb3AoXCJjaGVja2VkXCIsby5hdXRvKS50b2dnbGVDbGFzcyh0LmNvbHVtblNlbGVjdG9yX2Nzc0NoZWNrZWQsby5hdXRvKS5vbihcImNoYW5nZVwiLGZ1bmN0aW9uKCl7Uy51cGRhdGVBdXRvKGUsdCxoKHRoaXMpKX0pLmNoYW5nZSgpKSxlLiR0YWJsZS5vZmYoXCJ1cGRhdGVcIitjKS5vbihcInVwZGF0ZVwiK2MsZnVuY3Rpb24oKXtTLnVwZGF0ZUNvbHMoZSx0KX0pKX0sdXBkYXRlQXV0bzpmdW5jdGlvbihlLHQsbyl7dmFyIGw9ZS5zZWxlY3RvcjtsLmF1dG89by5wcm9wKFwiY2hlY2tlZFwiKXx8ITEsaC5lYWNoKGwuJGNoZWNrYm94LGZ1bmN0aW9uKGUsdCl7dCYmKHRbMF0uZGlzYWJsZWQ9bC5hdXRvLGwuJHdyYXBwZXJbZV0udG9nZ2xlQ2xhc3MoXCJkaXNhYmxlZFwiLGwuYXV0bykpfSksdC5jb2x1bW5TZWxlY3Rvcl9tZWRpYXF1ZXJ5JiZTLnVwZGF0ZUJyZWFrcG9pbnRzKGUsdCksUy51cGRhdGVDb2xzKGUsdCksZS5zZWxlY3Rvci4kcG9wdXAmJmUuc2VsZWN0b3IuJHBvcHVwLmZpbmQoXCIudGFibGVzb3J0ZXItY29sdW1uLXNlbGVjdG9yXCIpLmh0bWwobC4kY29udGFpbmVyLmh0bWwoKSkuZmluZChcImlucHV0XCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1oKHRoaXMpLmF0dHIoXCJkYXRhLWNvbHVtblwiKTtoKHRoaXMpLnByb3AoXCJjaGVja2VkXCIsXCJhdXRvXCI9PT1lP2wuYXV0bzpsLnN0YXRlc1tlXSl9KSxTLnNhdmVWYWx1ZXMoZSx0KSxTLmFkanVzdENvbHNwYW5zKGUsdCksbC5hdXRvJiZlLiR0YWJsZS50cmlnZ2VySGFuZGxlcih0LmNvbHVtblNlbGVjdG9yX3VwZGF0ZWQpfSxhZGRTZWxlY3RvcnM6ZnVuY3Rpb24oZSx0LG8pe3ZhciBsPVtdLGE9XCIgY29sOm50aC1jaGlsZChcIitvK1wiKVwiO3JldHVybiBsLnB1c2godCthK1wiLFwiK3QrXCJfZXh0cmFfdGFibGVcIithKSxhPVwiIHRyOm5vdCguXCIrZS5jb2x1bW5TZWxlY3Rvcl9jbGFzc0hhc1NwYW4rJykgdGhbZGF0YS1jb2x1bW49XCInKyhvLTEpKydcIl0nLGwucHVzaCh0K2ErXCIsXCIrdCtcIl9leHRyYV90YWJsZVwiK2EpLGE9XCIgdHI6bm90KC5cIitlLmNvbHVtblNlbGVjdG9yX2NsYXNzSGFzU3BhbitcIikgdGQ6bnRoLWNoaWxkKFwiK28rXCIpXCIsbC5wdXNoKHQrYStcIixcIit0K1wiX2V4dHJhX3RhYmxlXCIrYSksYT1cIiB0ciB0ZDpub3QoXCIrdCtlLmNvbHVtblNlbGVjdG9yX2NsYXNzSGFzU3BhbisnKVtkYXRhLWNvbHVtbj1cIicrKG8tMSkrJ1wiXScsbC5wdXNoKHQrYStcIixcIit0K1wiX2V4dHJhX3RhYmxlXCIrYSksbH0sdXBkYXRlQnJlYWtwb2ludHM6ZnVuY3Rpb24oZSx0KXt2YXIgbyxsLGEsbixjPVtdLHI9ZS5zZWxlY3RvcixzPWUubmFtZXNwYWNlK1wiY29sdW1uc2VsZWN0b3JcIixpPVtdLHU9XCJcIjtpZih0LmNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnkmJiFyLmF1dG8pcmV0dXJuIHIuJGJyZWFrcG9pbnRzLnByb3AoXCJkaXNhYmxlZFwiLCEwKSx2b2lkIHIuJHN0eWxlLnByb3AoXCJkaXNhYmxlZFwiLCExKTtpZih0LmNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnlIaWRkZW4pZm9yKGE9MDthPGUuY29sdW1uczthKyspbD1mLmdldENvbHVtbkRhdGEoZS50YWJsZSxlLmhlYWRlcnMsYSksY1thKzFdPVwiZmFsc2VcIj09PWYuZ2V0RGF0YShlLiRoZWFkZXJJbmRleGVkW2FdLGwsXCJjb2x1bW5TZWxlY3RvclwiKSxjW2ErMV0mJihpPWkuY29uY2F0KFMuYWRkU2VsZWN0b3JzKHQscyxhKzEpKSk7Zm9yKG89MDtvPHQuY29sdW1uU2VsZWN0b3JfbWF4UHJpb3JpdGllcztvKyspbj1bXSxlLiRoZWFkZXJzLmZpbHRlcihcIltcIit0LmNvbHVtblNlbGVjdG9yX3ByaW9yaXR5K1wiPVwiKyhvKzEpK1wiXVwiKS5lYWNoKGZ1bmN0aW9uKCl7YT1wYXJzZUludChoKHRoaXMpLmF0dHIoXCJkYXRhLWNvbHVtblwiKSwxMCkrMSxjW2FdfHwobj1uLmNvbmNhdChTLmFkZFNlbGVjdG9ycyh0LHMsYSkpKX0pLG4ubGVuZ3RoJiYoaT1pLmNvbmNhdChuKSx1Kz1TLnF1ZXJ5QnJlYWsucmVwbGFjZSgvXFxbc2l6ZVxcXS9nLHQuY29sdW1uU2VsZWN0b3JfYnJlYWtwb2ludHNbb10pLnJlcGxhY2UoL1xcW2NvbHVtbnNcXF0vZyxuLmpvaW4oXCIsXCIpKSk7ci4kc3R5bGUmJnIuJHN0eWxlLnByb3AoXCJkaXNhYmxlZFwiLCEwKSxpLmxlbmd0aCYmci4kYnJlYWtwb2ludHMucHJvcChcImRpc2FibGVkXCIsITEpLnRleHQoUy5xdWVyeUFsbC5yZXBsYWNlKC9cXFtjb2x1bW5zXFxdL2csaS5qb2luKFwiLFwiKSkrdSl9LHVwZGF0ZUNvbHM6ZnVuY3Rpb24oZSx0KXtpZighKHQuY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeSYmZS5zZWxlY3Rvci5hdXRvfHxlLnNlbGVjdG9yLmlzSW5pdGlhbGl6aW5nKSl7dmFyIG8sbD1lLnNlbGVjdG9yLGE9W10sbj1lLm5hbWVzcGFjZStcImNvbHVtbnNlbGVjdG9yXCI7bC4kY29udGFpbmVyLmZpbmQoXCJpbnB1dFtkYXRhLWNvbHVtbl1cIikuZmlsdGVyKCdbZGF0YS1jb2x1bW4hPVwiYXV0b1wiXScpLmVhY2goZnVuY3Rpb24oKXt0aGlzLmNoZWNrZWR8fChvPXBhcnNlSW50KGgodGhpcykuYXR0cihcImRhdGEtY29sdW1uXCIpLDEwKSsxLGE9YS5jb25jYXQoUy5hZGRTZWxlY3RvcnModCxuLG8pKSksaCh0aGlzKS50b2dnbGVDbGFzcyh0LmNvbHVtblNlbGVjdG9yX2Nzc0NoZWNrZWQsdGhpcy5jaGVja2VkKX0pLHQuY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeSYmbC4kYnJlYWtwb2ludHMucHJvcChcImRpc2FibGVkXCIsITApLGwuJHN0eWxlJiZsLiRzdHlsZS5wcm9wKFwiZGlzYWJsZWRcIiwhMSkudGV4dChhLmxlbmd0aD9hLmpvaW4oXCIsXCIpK1wiIHsgZGlzcGxheTogbm9uZTsgfVwiOlwiXCIpLFMuc2F2ZVZhbHVlcyhlLHQpLFMuYWRqdXN0Q29sc3BhbnMoZSx0KSxlLiR0YWJsZS50cmlnZ2VySGFuZGxlcih0LmNvbHVtblNlbGVjdG9yX3VwZGF0ZWQpfX0sc2V0VXBDb2xzcGFuOmZ1bmN0aW9uKGUsdCl7dmFyIG8sbCxhLG49aCh3aW5kb3cpLGM9ITEscj1lLiR0YWJsZS5hZGQoaChlLm5hbWVzcGFjZStcIl9leHRyYV90YWJsZVwiKSkuY2hpbGRyZW4oKS5jaGlsZHJlbihcInRyXCIpLmNoaWxkcmVuKFwidGgsIHRkXCIpLHM9ci5sZW5ndGg7Zm9yKG89MDtvPHM7bysrKTE8KGw9cltvXS5jb2xTcGFuKSYmKGM9ITAsci5lcShvKS5hZGRDbGFzcyhlLm5hbWVzcGFjZS5zbGljZSgxKStcImNvbHVtbnNlbGVjdG9yXCIrdC5jb2x1bW5TZWxlY3Rvcl9jbGFzc0hhc1NwYW4pLmF0dHIoXCJkYXRhLWNvbC1zcGFuXCIsbCksZi5jb21wdXRlQ29sdW1uSW5kZXgoci5lcShvKS5wYXJlbnQoKS5hZGRDbGFzcyh0LmNvbHVtblNlbGVjdG9yX2NsYXNzSGFzU3BhbikpKTtjJiZ0LmNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnkmJihhPWUubmFtZXNwYWNlK1wiY29sdW1uc2VsZWN0b3JcIixuLm9mZihhKS5vbihcInJlc2l6ZVwiK2EsZi53aW5kb3dfcmVzaXplKS5vbihcInJlc2l6ZUVuZFwiK2EsZnVuY3Rpb24oKXtuLm9mZihcInJlc2l6ZVwiK2EsZi53aW5kb3dfcmVzaXplKSxTLmFkanVzdENvbHNwYW5zKGUsdCksbi5vbihcInJlc2l6ZVwiK2EsZi53aW5kb3dfcmVzaXplKX0pKX0sZmluZEhlYWRlcnM6ZnVuY3Rpb24oZSl7dmFyIHQsbyxsPVwiLlwiK2YuY3NzLnNjcm9sbGVySGVhZGVyK1wiIHRoZWFkID4gdHIgPiBcIixhPWgobCtcInRoLFwiK2wrXCJ0ZFwiKSxuPVtdO2Zvcih0PTA7dDxlLmNvbHVtbnM7dCsrKW89YS5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicrdCsnXCJdJyksblt0XT1vLmxlbmd0aD9vLm5vdChcIi5zb3J0ZXItZmFsc2VcIikubGVuZ3RoP28ubm90KFwiLnNvcnRlci1mYWxzZVwiKS5maWx0ZXIoXCI6bGFzdFwiKTpvLmZpbHRlcihcIjpsYXN0XCIpOmgoKTtyZXR1cm4gbn0sYWRqdXN0Q29sc3BhbnM6ZnVuY3Rpb24oZSx0KXt2YXIgbyxsLGEsbixjLHIscz1lLnNlbGVjdG9yLGk9dC5maWx0ZXJfZmlsdGVyZWRSb3d8fFwiZmlsdGVyZWRcIix1PXQuY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeSYmcy5hdXRvLGQ9ZS4kdGFibGUuY2hpbGRyZW4oXCJ0aGVhZCwgdGZvb3RcIikuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmFkZChoKGUubmFtZXNwYWNlK1wiX2V4dHJhX3RhYmxlXCIpLmNoaWxkcmVuKFwidGhlYWQsIHRmb290XCIpLmNoaWxkcmVuKCkuY2hpbGRyZW4oKSkuYWRkKGUuJHRhYmxlLmZpbmQoXCIuZ3JvdXAtaGVhZGVyXCIpLmNoaWxkcmVuKCkpLHA9ZC5sZW5ndGgsbT1mLmhhc1dpZGdldChlLnRhYmxlLFwic2Nyb2xsZXJcIik/Uy5maW5kSGVhZGVycyhlKTplLiRoZWFkZXJJbmRleGVkO2ZvcihvPTA7bzxwO28rKylpZihyPWQuZXEobyksYz0oYT1wYXJzZUludChyLmF0dHIoXCJkYXRhLWNvbHVtblwiKSwxMCl8fHJbMF0uY2VsbEluZGV4KSsobj1wYXJzZUludChyLmF0dHIoXCJkYXRhLWNvbC1zcGFuXCIpLDEwKXx8MSksMTxuKXtmb3IobD1hO2w8YztsKyspKCF1JiYhMT09PXMuc3RhdGVzW2xdfHx1JiZtW2xdJiYhbVtsXS5pcyhcIjp2aXNpYmxlXCIpKSYmbi0tO24/ci5yZW1vdmVDbGFzcyhpKVswXS5jb2xTcGFuPW46ci5hZGRDbGFzcyhpKX1lbHNlIHZvaWQgMCE9PXMuc3RhdGVzW2FdJiZudWxsIT09cy5zdGF0ZXNbYV0mJnIudG9nZ2xlQ2xhc3MoaSwhdSYmIXMuc3RhdGVzW2FdKX0sc2F2ZVZhbHVlczpmdW5jdGlvbihlLHQpe2lmKHQuY29sdW1uU2VsZWN0b3Jfc2F2ZUNvbHVtbnMmJmYuc3RvcmFnZSl7dmFyIG89ZS5zZWxlY3RvcjtmLnN0b3JhZ2UoZS4kdGFibGVbMF0sXCJ0YWJsZXNvcnRlci1jb2x1bW5TZWxlY3Rvci1hdXRvXCIse2F1dG86by5hdXRvfSksZi5zdG9yYWdlKGUuJHRhYmxlWzBdLFwidGFibGVzb3J0ZXItY29sdW1uU2VsZWN0b3JcIixvLnN0YXRlcyl9fSxhdHRhY2hUbzpmdW5jdGlvbihlLHQpe3ZhciBvLGwsYSxuPShlPWgoZSlbMF0pLmNvbmZpZyxjPWgodCk7Yy5sZW5ndGgmJm4mJihjLmZpbmQoXCIudGFibGVzb3J0ZXItY29sdW1uLXNlbGVjdG9yXCIpLmxlbmd0aHx8Yy5hcHBlbmQoJzxzcGFuIGNsYXNzPVwidGFibGVzb3J0ZXItY29sdW1uLXNlbGVjdG9yXCI+PC9zcGFuPicpLG89bi5zZWxlY3RvcixsPW4ud2lkZ2V0T3B0aW9ucyxjLmZpbmQoXCIudGFibGVzb3J0ZXItY29sdW1uLXNlbGVjdG9yXCIpLmh0bWwoby4kY29udGFpbmVyLmh0bWwoKSkuZmluZChcImlucHV0XCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1oKHRoaXMpLmF0dHIoXCJkYXRhLWNvbHVtblwiKSx0PVwiYXV0b1wiPT09ZT9vLmF1dG86by5zdGF0ZXNbZV07aCh0aGlzKS50b2dnbGVDbGFzcyhsLmNvbHVtblNlbGVjdG9yX2Nzc0NoZWNrZWQsdCkucHJvcChcImNoZWNrZWRcIix0KX0pLG8uJHBvcHVwPWMub24oXCJjaGFuZ2VcIixcImlucHV0XCIsZnVuY3Rpb24oKXtpZighby5pc0luaXRpYWxpemluZyl7aWYoIVMuY2hlY2tDaGFuZ2Uobix0aGlzLmNoZWNrZWQpKXJldHVybiB0aGlzLmNoZWNrZWQ9IXRoaXMuY2hlY2tlZCwhMTthPWgodGhpcykudG9nZ2xlQ2xhc3MobC5jb2x1bW5TZWxlY3Rvcl9jc3NDaGVja2VkLHRoaXMuY2hlY2tlZCkuYXR0cihcImRhdGEtY29sdW1uXCIpLG8uJGNvbnRhaW5lci5maW5kKCdpbnB1dFtkYXRhLWNvbHVtbj1cIicrYSsnXCJdJykucHJvcChcImNoZWNrZWRcIix0aGlzLmNoZWNrZWQpLnRyaWdnZXIoXCJjaGFuZ2VcIil9fSkpfX07Zi53aW5kb3dfcmVzaXplPWZ1bmN0aW9uKCl7Zi50aW1lcl9yZXNpemUmJmNsZWFyVGltZW91dChmLnRpbWVyX3Jlc2l6ZSksZi50aW1lcl9yZXNpemU9c2V0VGltZW91dChmdW5jdGlvbigpe2god2luZG93KS50cmlnZ2VyKFwicmVzaXplRW5kXCIpfSwyNTApfSxmLmFkZFdpZGdldCh7aWQ6XCJjb2x1bW5TZWxlY3RvclwiLHByaW9yaXR5OjEwLG9wdGlvbnM6e2NvbHVtblNlbGVjdG9yX2NvbnRhaW5lcjpudWxsLGNvbHVtblNlbGVjdG9yX2NvbHVtbnM6e30sY29sdW1uU2VsZWN0b3Jfc2F2ZUNvbHVtbnM6ITAsY29sdW1uU2VsZWN0b3JfbGF5b3V0Oic8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiPntuYW1lfTwvbGFiZWw+Jyxjb2x1bW5TZWxlY3Rvcl9sYXlvdXRDdXN0b21pemVyOm51bGwsY29sdW1uU2VsZWN0b3JfbmFtZTpcImRhdGEtc2VsZWN0b3ItbmFtZVwiLGNvbHVtblNlbGVjdG9yX21lZGlhcXVlcnk6ITAsY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeU5hbWU6XCJBdXRvOiBcIixjb2x1bW5TZWxlY3Rvcl9tZWRpYXF1ZXJ5U3RhdGU6ITAsY29sdW1uU2VsZWN0b3JfbWVkaWFxdWVyeUhpZGRlbjohMSxjb2x1bW5TZWxlY3Rvcl9tYXhWaXNpYmxlOm51bGwsY29sdW1uU2VsZWN0b3JfbWluVmlzaWJsZTpudWxsLGNvbHVtblNlbGVjdG9yX2JyZWFrcG9pbnRzOltcIjIwZW1cIixcIjMwZW1cIixcIjQwZW1cIixcIjUwZW1cIixcIjYwZW1cIixcIjcwZW1cIl0sY29sdW1uU2VsZWN0b3JfbWF4UHJpb3JpdGllczo2LGNvbHVtblNlbGVjdG9yX3ByaW9yaXR5OlwiZGF0YS1wcmlvcml0eVwiLGNvbHVtblNlbGVjdG9yX2Nzc0NoZWNrZWQ6XCJjaGVja2VkXCIsY29sdW1uU2VsZWN0b3JfY2xhc3NIYXNTcGFuOlwiaGFzU3BhblwiLGNvbHVtblNlbGVjdG9yX3VwZGF0ZWQ6XCJjb2x1bW5VcGRhdGVcIn0saW5pdDpmdW5jdGlvbihlLHQsbyxsKXtTLmluaXQoZSxvLGwpfSxyZW1vdmU6ZnVuY3Rpb24oZSx0LG8sbCl7dmFyIGE9dC5zZWxlY3RvcjshbCYmYSYmKGEmJmEuJGNvbnRhaW5lci5lbXB0eSgpLGEuJHBvcHVwJiZhLiRwb3B1cC5lbXB0eSgpLGEuJHN0eWxlLnJlbW92ZSgpLGEuJGJyZWFrcG9pbnRzLnJlbW92ZSgpLGgodC5uYW1lc3BhY2UrXCJjb2x1bW5zZWxlY3RvclwiK28uY29sdW1uU2VsZWN0b3JfY2xhc3NIYXNTcGFuKS5yZW1vdmVDbGFzcyhvLmZpbHRlcl9maWx0ZXJlZFJvd3x8XCJmaWx0ZXJlZFwiKSx0LiR0YWJsZS5maW5kKFwiW2RhdGEtY29sLXNwYW5dXCIpLmVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbz1oKHQpO28uYXR0cihcImNvbHNwYW5cIixvLmF0dHIoXCJkYXRhLWNvbC1zcGFuXCIpKX0pLHQuJHRhYmxlLm9mZihcInVwZGF0ZUFsbFwiK2MrXCIgdXBkYXRlXCIrYykpfX0pfShqUXVlcnkpO3JldHVybiBqUXVlcnk7fSkpO1xuIiwiKGZ1bmN0aW9uKGZhY3Rvcnkpe2lmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpe2RlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTt9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpe21vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7fSBlbHNlIHtmYWN0b3J5KGpRdWVyeSk7fX0oZnVuY3Rpb24oalF1ZXJ5KXtcblxuLyohIFdpZGdldDogUGFnZXIgLSB1cGRhdGVkIDIwMjAtMDMtMDMgKHYyLjMxLjMpICovXG4hZnVuY3Rpb24oUyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEMsJD1TLnRhYmxlc29ydGVyOyQuYWRkV2lkZ2V0KHtpZDpcInBhZ2VyXCIscHJpb3JpdHk6NTUsb3B0aW9uczp7cGFnZXJfb3V0cHV0Olwie3N0YXJ0Um93fSB0byB7ZW5kUm93fSBvZiB7dG90YWxSb3dzfSByb3dzXCIscGFnZXJfdXBkYXRlQXJyb3dzOiEwLHBhZ2VyX3N0YXJ0UGFnZTowLHBhZ2VyX3BhZ2VSZXNldDowLHBhZ2VyX3NpemU6MTAscGFnZXJfbWF4T3B0aW9uU2l6ZToyMCxwYWdlcl9zYXZlUGFnZXM6ITAscGFnZXJfc3RvcmFnZUtleTpcInRhYmxlc29ydGVyLXBhZ2VyXCIscGFnZXJfZml4ZWRIZWlnaHQ6ITEscGFnZXJfY291bnRDaGlsZFJvd3M6ITEscGFnZXJfcmVtb3ZlUm93czohMSxwYWdlcl9hamF4VXJsOm51bGwscGFnZXJfY3VzdG9tQWpheFVybDpmdW5jdGlvbihlLGEpe3JldHVybiBhfSxwYWdlcl9hamF4RXJyb3I6bnVsbCxwYWdlcl9hamF4T2JqZWN0OntkYXRhVHlwZTpcImpzb25cIn0scGFnZXJfcHJvY2Vzc0FqYXhPbkluaXQ6ITAscGFnZXJfYWpheFByb2Nlc3Npbmc6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHBhZ2VyX2Nzczp7Y29udGFpbmVyOlwidGFibGVzb3J0ZXItcGFnZXJcIixlcnJvclJvdzpcInRhYmxlc29ydGVyLWVycm9yUm93XCIsZGlzYWJsZWQ6XCJkaXNhYmxlZFwifSxwYWdlcl9zZWxlY3RvcnM6e2NvbnRhaW5lcjpcIi5wYWdlclwiLGZpcnN0OlwiLmZpcnN0XCIscHJldjpcIi5wcmV2XCIsbmV4dDpcIi5uZXh0XCIsbGFzdDpcIi5sYXN0XCIsZ290b1BhZ2U6XCIuZ290b1BhZ2VcIixwYWdlRGlzcGxheTpcIi5wYWdlZGlzcGxheVwiLHBhZ2VTaXplOlwiLnBhZ2VzaXplXCJ9fSxpbml0OmZ1bmN0aW9uKGUpe0MuaW5pdChlKX0sZm9ybWF0OmZ1bmN0aW9uKGUsYSl7aWYoIWEucGFnZXJ8fCFhLnBhZ2VyLmluaXRpYWxpemVkKXJldHVybiBDLmluaXRDb21wbGV0ZShhKTtDLm1vdmVUb1BhZ2UoYSxhLnBhZ2VyLCExKX0scmVtb3ZlOmZ1bmN0aW9uKGUsYSx0LHIpe0MuZGVzdHJveVBhZ2VyKGEscil9fSksQz0kLnBhZ2VyPXtpbml0OmZ1bmN0aW9uKGUpe2lmKCEoZS5oYXNJbml0aWFsaXplZCYmZS5jb25maWcucGFnZXImJmUuY29uZmlnLnBhZ2VyLmluaXRpYWxpemVkKSl7dmFyIGEsdD1lLmNvbmZpZyxyPXQud2lkZ2V0T3B0aW9ucyxpPXIucGFnZXJfc2VsZWN0b3JzLHM9dC5wYWdlcj1TLmV4dGVuZCh7dG90YWxQYWdlczowLGZpbHRlcmVkUm93czowLGZpbHRlcmVkUGFnZXM6MCxjdXJyZW50RmlsdGVyczpbXSxwYWdlOnIucGFnZXJfc3RhcnRQYWdlLHN0YXJ0Um93OjAsZW5kUm93OjAsYWpheENvdW50ZXI6MCwkc2l6ZTpudWxsLGxhc3Q6e30sc2V0U2l6ZTpyLnBhZ2VyX3NpemUsc2V0UGFnZTpyLnBhZ2VyX3N0YXJ0UGFnZX0sdC5wYWdlcik7cy5yZW1vdmVSb3dzPXIucGFnZXJfcmVtb3ZlUm93cyxzLmlzSW5pdGlhbGl6aW5nfHwocy5pc0luaXRpYWxpemluZz0hMCwkLmRlYnVnKHQsXCJwYWdlclwiKSYmY29uc29sZS5sb2coXCJQYWdlciA+PiBJbml0aWFsaXppbmdcIikscy5zaXplPVMuZGF0YShlLFwicGFnZXJMYXN0U2l6ZVwiKXx8ci5wYWdlcl9zaXplLHMuJGNvbnRhaW5lcj1TKGkuY29udGFpbmVyKS5hZGRDbGFzcyhyLnBhZ2VyX2Nzcy5jb250YWluZXIpLnNob3coKSxzLnRvdGFsUm93cz10LiR0Ym9kaWVzLmVxKDApLmNoaWxkcmVuKFwidHJcIikubm90KHIucGFnZXJfY291bnRDaGlsZFJvd3M/XCJcIjpcIi5cIit0LmNzc0NoaWxkUm93KS5sZW5ndGgscy5vbGRBamF4U3VjY2Vzcz1zLm9sZEFqYXhTdWNjZXNzfHxyLnBhZ2VyX2FqYXhPYmplY3Quc3VjY2Vzcyx0LmFwcGVuZGVyPUMuYXBwZW5kZXIscy5pbml0aWFsaXppbmc9ITAsci5wYWdlcl9zYXZlUGFnZXMmJiQuc3RvcmFnZSYmKGE9JC5zdG9yYWdlKGUsci5wYWdlcl9zdG9yYWdlS2V5KXx8e30scy5wYWdlPShpc05hTihhLnBhZ2UpP3MucGFnZTphLnBhZ2UpfHxzLnNldFBhZ2V8fDAscy5zaXplPVwiYWxsXCI9PT1hLnNpemU/YS5zaXplOihpc05hTihhLnNpemUpP3Muc2l6ZTphLnNpemUpfHxzLnNldFNpemV8fDEwLEMuc2V0UGFnZVNpemUodCxzLnNpemUpKSxzLnJlZ2V4Um93cz1uZXcgUmVnRXhwKFwiKFwiKyhyLmZpbHRlcl9maWx0ZXJlZFJvd3x8XCJmaWx0ZXJlZFwiKStcInxcIit0LnNlbGVjdG9yUmVtb3ZlLnNsaWNlKDEpK1wifFwiK3QuY3NzQ2hpbGRSb3crXCIpXCIpLHMucmVnZXhGaWx0ZXJlZD1uZXcgUmVnRXhwKHIuZmlsdGVyX2ZpbHRlcmVkUm93fHxcImZpbHRlcmVkXCIpLHMuaW5pdGlhbGl6ZWQ9ITEsdC4kdGFibGUudHJpZ2dlckhhbmRsZXIoXCJwYWdlckJlZm9yZUluaXRpYWxpemVkXCIsdCksQy5lbmFibGVQYWdlcih0LCExKSxzLmFqYXhPYmplY3Q9ci5wYWdlcl9hamF4T2JqZWN0LHMuYWpheE9iamVjdC51cmw9ci5wYWdlcl9hamF4VXJsLFwic3RyaW5nXCI9PXR5cGVvZiByLnBhZ2VyX2FqYXhVcmw/KHMuYWpheD0hMCxyLmZpbHRlcl9zZXJ2ZXJzaWRlRmlsdGVyaW5nPSEwLHQuc2VydmVyU2lkZVNvcnRpbmc9ITAsQy5tb3ZlVG9QYWdlKHQscykpOihzLmFqYXg9ITEsJC5hcHBlbmRDYWNoZSh0LCEwKSkpfX0saW5pdENvbXBsZXRlOmZ1bmN0aW9uKGUpe3ZhciBhPWUucGFnZXI7Qy5iaW5kRXZlbnRzKGUpLGEuYWpheHx8Qy5oaWRlUm93c1NldHVwKGUpLGEuaW5pdGlhbGl6ZWQ9ITAsYS5pbml0aWFsaXppbmc9ITEsYS5pc0luaXRpYWxpemluZz0hMSxDLnNldFBhZ2VTaXplKGUsYS5zaXplKSwkLmRlYnVnKGUsXCJwYWdlclwiKSYmY29uc29sZS5sb2coXCJQYWdlciA+PiBUcmlnZ2VyaW5nIHBhZ2VySW5pdGlhbGl6ZWRcIiksZS4kdGFibGUudHJpZ2dlckhhbmRsZXIoXCJwYWdlckluaXRpYWxpemVkXCIsZSksZS53aWRnZXRPcHRpb25zLmZpbHRlcl9pbml0aWFsaXplZCYmJC5oYXNXaWRnZXQoZS50YWJsZSxcImZpbHRlclwiKXx8Qy51cGRhdGVQYWdlRGlzcGxheShlLCFhLmFqYXgpfSxiaW5kRXZlbnRzOmZ1bmN0aW9uKGkpe3ZhciBzLG8sZSxnPWkucGFnZXIsbj1pLndpZGdldE9wdGlvbnMsYT1pLm5hbWVzcGFjZStcInBhZ2VyXCIsdD1uLnBhZ2VyX3NlbGVjdG9ycyxyPSQuZGVidWcoaSxcInBhZ2VyXCIpO2kuJHRhYmxlLm9mZihhKS5vbihcImZpbHRlckluaXQgZmlsdGVyU3RhcnQgXCIuc3BsaXQoXCIgXCIpLmpvaW4oYStcIiBcIiksZnVuY3Rpb24oZSxhKXt2YXIgdDtpZihnLmN1cnJlbnRGaWx0ZXJzPVMuaXNBcnJheShhKT9hOmkuJHRhYmxlLmRhdGEoXCJsYXN0U2VhcmNoXCIpLGcuYWpheCYmXCJmaWx0ZXJJbml0XCI9PT1lLnR5cGUpcmV0dXJuIEMubW92ZVRvUGFnZShpLGcsITEpO3Q9JC5maWx0ZXIuZXF1YWxGaWx0ZXJzPyQuZmlsdGVyLmVxdWFsRmlsdGVycyhpLGkubGFzdFNlYXJjaCxnLmN1cnJlbnRGaWx0ZXJzKTooaS5sYXN0U2VhcmNofHxbXSkuam9pbihcIlwiKSE9PShnLmN1cnJlbnRGaWx0ZXJzfHxbXSkuam9pbihcIlwiKSxcImZpbHRlclN0YXJ0XCIhPT1lLnR5cGV8fCExPT09bi5wYWdlcl9wYWdlUmVzZXR8fHR8fChnLnBhZ2U9bi5wYWdlcl9wYWdlUmVzZXQpfSkub24oXCJmaWx0ZXJFbmQgc29ydEVuZCBcIi5zcGxpdChcIiBcIikuam9pbihhK1wiIFwiKSxmdW5jdGlvbigpe2cuY3VycmVudEZpbHRlcnM9aS4kdGFibGUuZGF0YShcImxhc3RTZWFyY2hcIiksKGcuaW5pdGlhbGl6ZWR8fGcuaW5pdGlhbGl6aW5nKSYmKGkuZGVsYXlJbml0JiZpLnJvd3NDb3B5JiYwPT09aS5yb3dzQ29weS5sZW5ndGgmJkMudXBkYXRlQ2FjaGUoaSksQy51cGRhdGVQYWdlRGlzcGxheShpLCExKSwkLmFwcGx5V2lkZ2V0KGkudGFibGUpKX0pLm9uKFwiZGlzYWJsZVBhZ2VyXCIrYSxmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLEMuc2hvd0FsbFJvd3MoaSl9KS5vbihcImVuYWJsZVBhZ2VyXCIrYSxmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpLEMuZW5hYmxlUGFnZXIoaSwhMCl9KS5vbihcImRlc3Ryb3lQYWdlclwiK2EsZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKSwkLnJlbW92ZVdpZGdldChpLnRhYmxlLFwicGFnZXJcIiwhMSl9KS5vbihcInVwZGF0ZUNvbXBsZXRlXCIrYSxmdW5jdGlvbihlLGEsdCl7aWYoZS5zdG9wUHJvcGFnYXRpb24oKSxhJiYhdCYmIWcuYWpheCl7dmFyIHI9aS4kdGJvZGllcy5lcSgwKS5jaGlsZHJlbihcInRyXCIpLm5vdChpLnNlbGVjdG9yUmVtb3ZlKTtnLnRvdGFsUm93cz1yLmxlbmd0aC0obi5wYWdlcl9jb3VudENoaWxkUm93cz8wOnIuZmlsdGVyKFwiLlwiK2kuY3NzQ2hpbGRSb3cpLmxlbmd0aCksZy50b3RhbFBhZ2VzPVwiYWxsXCI9PT1nLnNpemU/MTpNYXRoLmNlaWwoZy50b3RhbFJvd3MvZy5zaXplKSxyLmxlbmd0aCYmaS5yb3dzQ29weSYmMD09PWkucm93c0NvcHkubGVuZ3RoJiZDLnVwZGF0ZUNhY2hlKGkpLGcucGFnZT49Zy50b3RhbFBhZ2VzJiZDLm1vdmVUb0xhc3RQYWdlKGksZyksQy5oaWRlUm93cyhpKSxDLmNoYW5nZUhlaWdodChpKSxDLnVwZGF0ZVBhZ2VEaXNwbGF5KGksITEpLCQuYXBwbHlXaWRnZXQoYSksQy51cGRhdGVQYWdlRGlzcGxheShpKX19KS5vbihcInBhZ2VTaXplIHJlZnJlc2hDb21wbGV0ZSBcIi5zcGxpdChcIiBcIikuam9pbihhK1wiIFwiKSxmdW5jdGlvbihlLGEpe2Uuc3RvcFByb3BhZ2F0aW9uKCksQy5zZXRQYWdlU2l6ZShpLEMucGFyc2VQYWdlU2l6ZShpLGEsXCJnZXRcIikpLEMubW92ZVRvUGFnZShpLGcsITApLEMuaGlkZVJvd3MoaSksQy51cGRhdGVQYWdlRGlzcGxheShpLCExKX0pLm9uKFwicGFnZVNldCBwYWdlclVwZGF0ZSBcIi5zcGxpdChcIiBcIikuam9pbihhK1wiIFwiKSxmdW5jdGlvbihlLGEpe2Uuc3RvcFByb3BhZ2F0aW9uKCksXCJwYWdlclVwZGF0ZVwiPT09ZS50eXBlJiYoYT12b2lkIDA9PT1hP2cucGFnZSsxOmEsZy5sYXN0LnBhZ2U9ITApLGcucGFnZT0ocGFyc2VJbnQoYSwxMCl8fDEpLTEsQy5tb3ZlVG9QYWdlKGksZywhMCksQy51cGRhdGVQYWdlRGlzcGxheShpLCExKX0pLm9uKFwicGFnZUFuZFNpemVcIithLGZ1bmN0aW9uKGUsYSx0KXtlLnN0b3BQcm9wYWdhdGlvbigpLGcucGFnZT0ocGFyc2VJbnQoYSwxMCl8fDEpLTEsQy5zZXRQYWdlU2l6ZShpLEMucGFyc2VQYWdlU2l6ZShpLHQsXCJnZXRcIikpLEMubW92ZVRvUGFnZShpLGcsITApLEMuaGlkZVJvd3MoaSksQy51cGRhdGVQYWdlRGlzcGxheShpLCExKX0pLHM9W3QuZmlyc3QsdC5wcmV2LHQubmV4dCx0Lmxhc3RdLG89W1wibW92ZVRvRmlyc3RQYWdlXCIsXCJtb3ZlVG9QcmV2UGFnZVwiLFwibW92ZVRvTmV4dFBhZ2VcIixcIm1vdmVUb0xhc3RQYWdlXCJdLHImJiFnLiRjb250YWluZXIubGVuZ3RoJiZjb25zb2xlLndhcm4oJ1BhZ2VyID4+IFwiY29udGFpbmVyXCIgbm90IGZvdW5kJyksZy4kY29udGFpbmVyLmZpbmQocy5qb2luKFwiLFwiKSkuYXR0cihcInRhYmluZGV4XCIsMCkub2ZmKFwiY2xpY2tcIithKS5vbihcImNsaWNrXCIrYSxmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpO3ZhciBhLHQ9Uyh0aGlzKSxyPXMubGVuZ3RoO2lmKCF0Lmhhc0NsYXNzKG4ucGFnZXJfY3NzLmRpc2FibGVkKSlmb3IoYT0wO2E8cjthKyspaWYodC5pcyhzW2FdKSl7Q1tvW2FdXShpLGcpO2JyZWFrfX0pLChlPWcuJGNvbnRhaW5lci5maW5kKG4ucGFnZXJfc2VsZWN0b3JzLmdvdG9QYWdlKSkubGVuZ3RoP2Uub2ZmKFwiY2hhbmdlXCIrYSkub24oXCJjaGFuZ2VcIithLGZ1bmN0aW9uKCl7Zy5wYWdlPVModGhpcykudmFsKCktMSxDLm1vdmVUb1BhZ2UoaSxnLCEwKSxDLnVwZGF0ZVBhZ2VEaXNwbGF5KGksITEpfSk6ciYmY29uc29sZS53YXJuKCdQYWdlciA+PiBcImdvdG9cIiBzZWxlY3RvciBub3QgZm91bmQnKSwoZT1nLiRjb250YWluZXIuZmluZChuLnBhZ2VyX3NlbGVjdG9ycy5wYWdlU2l6ZSkpLmxlbmd0aD8oZS5maW5kKFwib3B0aW9uXCIpLnJlbW92ZUF0dHIoXCJzZWxlY3RlZFwiKSxlLm9mZihcImNoYW5nZVwiK2EpLm9uKFwiY2hhbmdlXCIrYSxmdW5jdGlvbigpe2lmKCFTKHRoaXMpLmhhc0NsYXNzKG4ucGFnZXJfY3NzLmRpc2FibGVkKSl7dmFyIGU9Uyh0aGlzKS52YWwoKTtnLiRjb250YWluZXIuZmluZChuLnBhZ2VyX3NlbGVjdG9ycy5wYWdlU2l6ZSkudmFsKGUpLEMuc2V0UGFnZVNpemUoaSxlKSxDLm1vdmVUb1BhZ2UoaSxnLCEwKSxDLmNoYW5nZUhlaWdodChpKX1yZXR1cm4hMX0pKTpyJiZjb25zb2xlLndhcm4oJ1BhZ2VyID4+IFwic2l6ZVwiIHNlbGVjdG9yIG5vdCBmb3VuZCcpfSxwYWdlckFycm93czpmdW5jdGlvbihlLGEpe3ZhciB0PWUucGFnZXIscj0hIWEsaT1yfHwwPT09dC5wYWdlLHM9Qy5nZXRUb3RhbFBhZ2VzKGUsdCksbz1yfHx0LnBhZ2U9PT1zLTF8fDA9PT1zLGc9ZS53aWRnZXRPcHRpb25zLG49Zy5wYWdlcl9zZWxlY3RvcnM7Zy5wYWdlcl91cGRhdGVBcnJvd3MmJih0LiRjb250YWluZXIuZmluZChuLmZpcnN0K1wiLFwiK24ucHJldikudG9nZ2xlQ2xhc3MoZy5wYWdlcl9jc3MuZGlzYWJsZWQsaSkucHJvcChcImFyaWEtZGlzYWJsZWRcIixpKSx0LiRjb250YWluZXIuZmluZChuLm5leHQrXCIsXCIrbi5sYXN0KS50b2dnbGVDbGFzcyhnLnBhZ2VyX2Nzcy5kaXNhYmxlZCxvKS5wcm9wKFwiYXJpYS1kaXNhYmxlZFwiLG8pKX0sY2FsY0ZpbHRlcnM6ZnVuY3Rpb24oZSl7dmFyIGEsdCxyLGk9ZS53aWRnZXRPcHRpb25zLHM9ZS5wYWdlcixvPWUuJHRhYmxlLmhhc0NsYXNzKFwiaGFzRmlsdGVyc1wiKTtpZihvJiYhcy5hamF4KWlmKFMuaXNFbXB0eU9iamVjdChlLmNhY2hlKSlzLmZpbHRlcmVkUm93cz1zLnRvdGFsUm93cz1lLiR0Ym9kaWVzLmVxKDApLmNoaWxkcmVuKFwidHJcIikubm90KGkucGFnZXJfY291bnRDaGlsZFJvd3M/XCJcIjpcIi5cIitlLmNzc0NoaWxkUm93KS5sZW5ndGg7ZWxzZSBmb3Iocy5maWx0ZXJlZFJvd3M9MCxyPShhPWUuY2FjaGVbMF0ubm9ybWFsaXplZCkubGVuZ3RoLHQ9MDt0PHI7dCsrKXMuZmlsdGVyZWRSb3dzKz1zLnJlZ2V4Um93cy50ZXN0KGFbdF1bZS5jb2x1bW5zXS4kcm93WzBdLmNsYXNzTmFtZSk/MDoxO2Vsc2Ugb3x8KHMuZmlsdGVyZWRSb3dzPXMudG90YWxSb3dzKX0sdXBkYXRlUGFnZURpc3BsYXk6ZnVuY3Rpb24odCxlKXtpZighdC5wYWdlcnx8IXQucGFnZXIuaW5pdGlhbGl6aW5nKXt2YXIgYSxyLGkscyxvLGcsbixsPXQudGFibGUscD10LndpZGdldE9wdGlvbnMsZD10LnBhZ2VyLGM9dC5uYW1lc3BhY2UrXCJwYWdlclwiLGY9Qy5wYXJzZVBhZ2VTaXplKHQsZC5zaXplLFwiZ2V0XCIpO2lmKFwiYWxsXCI9PT1mJiYoZj1kLnRvdGFsUm93cykscC5wYWdlcl9jb3VudENoaWxkUm93cyYmKHJbci5sZW5ndGhdPXQuY3NzQ2hpbGRSb3cpLGQuJGNvbnRhaW5lci5maW5kKHAucGFnZXJfc2VsZWN0b3JzLnBhZ2VTaXplK1wiLFwiK3AucGFnZXJfc2VsZWN0b3JzLmdvdG9QYWdlKS5yZW1vdmVDbGFzcyhwLnBhZ2VyX2Nzcy5kaXNhYmxlZCkucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpLnByb3AoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSxkLnRvdGFsUGFnZXM9TWF0aC5jZWlsKGQudG90YWxSb3dzL2YpLHQudG90YWxSb3dzPWQudG90YWxSb3dzLEMucGFyc2VQYWdlTnVtYmVyKHQsZCksQy5jYWxjRmlsdGVycyh0KSx0LmZpbHRlcmVkUm93cz1kLmZpbHRlcmVkUm93cyxkLmZpbHRlcmVkUGFnZXM9TWF0aC5jZWlsKGQuZmlsdGVyZWRSb3dzL2YpfHwwLDA8PUMuZ2V0VG90YWxQYWdlcyh0LGQpKXtpZihyPWYqZC5wYWdlPmQuZmlsdGVyZWRSb3dzJiZlLGQucGFnZT1yP3AucGFnZXJfcGFnZVJlc2V0fHwwOmQucGFnZSxkLnN0YXJ0Um93PXI/ZipkLnBhZ2UrMTowPT09ZC5maWx0ZXJlZFJvd3M/MDpmKmQucGFnZSsxLGQuZW5kUm93PU1hdGgubWluKGQuZmlsdGVyZWRSb3dzLGQudG90YWxSb3dzLGYqKGQucGFnZSsxKSksaT1kLiRjb250YWluZXIuZmluZChwLnBhZ2VyX3NlbGVjdG9ycy5wYWdlRGlzcGxheSksYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBwLnBhZ2VyX291dHB1dD9wLnBhZ2VyX291dHB1dChsLGQpOihuPWkuYXR0cihcImRhdGEtcGFnZXItb3V0cHV0XCIrKGQuZmlsdGVyZWRSb3dzPGQudG90YWxSb3dzP1wiLWZpbHRlcmVkXCI6XCJcIikpfHxwLnBhZ2VyX291dHB1dCwoZC5hamF4RGF0YSYmZC5hamF4RGF0YS5vdXRwdXQmJmQuYWpheERhdGEub3V0cHV0fHxuKS5yZXBsYWNlKC9cXHtwYWdlKFtcXC0rXVxcZCspP1xcfS9naSxmdW5jdGlvbihlLGEpe3JldHVybiBkLnRvdGFsUGFnZXM/ZC5wYWdlKyhhP3BhcnNlSW50KGEsMTApOjEpOjB9KS5yZXBsYWNlKC9cXHtcXHcrKFxccyo6XFxzKlxcdyspP1xcfS9naSxmdW5jdGlvbihlKXt2YXIgYSx0LHI9ZS5yZXBsYWNlKC9be31cXHNdL2csXCJcIiksaT1yLnNwbGl0KFwiOlwiKSxzPWQuYWpheERhdGEsbz0vKHJvd3M/fHBhZ2VzPykkL2kudGVzdChyKT8wOlwiXCI7cmV0dXJuLyhzdGFydFJvd3xwYWdlKS8udGVzdChpWzBdKSYmXCJpbnB1dFwiPT09aVsxXT8oYT0oXCJcIisoXCJwYWdlXCI9PT1pWzBdP2QudG90YWxQYWdlczpkLnRvdGFsUm93cykpLmxlbmd0aCx0PVwicGFnZVwiPT09aVswXT9kLnBhZ2UrMTpkLnN0YXJ0Um93LCc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInRzLScraVswXSsnXCIgc3R5bGU9XCJtYXgtd2lkdGg6JythKydlbVwiIHZhbHVlPVwiJyt0KydcIi8+Jyk6MTxpLmxlbmd0aCYmcyYmc1tpWzBdXT9zW2lbMF1dW2lbMV1dOmRbcl18fChzP3Nbcl06byl8fG99KSksZC4kY29udGFpbmVyLmZpbmQocC5wYWdlcl9zZWxlY3RvcnMuZ290b1BhZ2UpLmxlbmd0aCl7Zm9yKHI9XCJcIixnPShzPUMuYnVpbGRQYWdlU2VsZWN0KHQsZCkpLmxlbmd0aCxvPTA7bzxnO28rKylyKz0nPG9wdGlvbiB2YWx1ZT1cIicrc1tvXSsnXCI+JytzW29dK1wiPC9vcHRpb24+XCI7ZC4kY29udGFpbmVyLmZpbmQocC5wYWdlcl9zZWxlY3RvcnMuZ290b1BhZ2UpLmh0bWwocikudmFsKGQucGFnZSsxKX1pLmxlbmd0aCYmKGlbXCJJTlBVVFwiPT09aVswXS5ub2RlTmFtZT9cInZhbFwiOlwiaHRtbFwiXShhKSxpLmZpbmQoXCIudHMtc3RhcnRSb3csIC50cy1wYWdlXCIpLm9mZihcImNoYW5nZVwiK2MpLm9uKFwiY2hhbmdlXCIrYyxmdW5jdGlvbigpe3ZhciBlPVModGhpcykudmFsKCksYT1TKHRoaXMpLmhhc0NsYXNzKFwidHMtc3RhcnRSb3dcIik/TWF0aC5mbG9vcihlL2YpKzE6ZTt0LiR0YWJsZS50cmlnZ2VySGFuZGxlcihcInBhZ2VTZXRcIitjLFthXSl9KSl9Qy5wYWdlckFycm93cyh0KSxDLmZpeEhlaWdodCh0KSxkLmluaXRpYWxpemVkJiYhMSE9PWUmJigkLmRlYnVnKHQsXCJwYWdlclwiKSYmY29uc29sZS5sb2coXCJQYWdlciA+PiBUcmlnZ2VyaW5nIHBhZ2VyQ29tcGxldGVcIiksdC4kdGFibGUudHJpZ2dlckhhbmRsZXIoXCJwYWdlckNvbXBsZXRlXCIsdCkscC5wYWdlcl9zYXZlUGFnZXMmJiQuc3RvcmFnZSYmJC5zdG9yYWdlKGwscC5wYWdlcl9zdG9yYWdlS2V5LHtwYWdlOmQucGFnZSxzaXplOmY9PT1kLnRvdGFsUm93cz9cImFsbFwiOmZ9KSl9fSxidWlsZFBhZ2VTZWxlY3Q6ZnVuY3Rpb24oZSxhKXt2YXIgdCxyLGkscyxvLGcsbj1lLndpZGdldE9wdGlvbnMsbD1DLmdldFRvdGFsUGFnZXMoZSxhKXx8MSxwPTUqTWF0aC5jZWlsKGwvbi5wYWdlcl9tYXhPcHRpb25TaXplLzUpLGQ9bD5uLnBhZ2VyX21heE9wdGlvblNpemUsYz1hLnBhZ2UrMSxmPXAsdT1sLXAsaD1bMV07Zm9yKHQ9ZD9wOjE7dDw9bDspaFtoLmxlbmd0aF09dCx0Kz1kP3A6MTtpZihoW2gubGVuZ3RoXT1sLGQpe2ZvcihpPVtdLChmPWMtKHI9TWF0aC5tYXgoTWF0aC5mbG9vcihuLnBhZ2VyX21heE9wdGlvblNpemUvcCktMSw1KSkpPDEmJihmPTEpLGw8KHU9YytyKSYmKHU9bCksdD1mO3Q8PXU7dCsrKWlbaS5sZW5ndGhdPXQ7cC8yPChvPShoPVMuZ3JlcChoLGZ1bmN0aW9uKGUsYSl7cmV0dXJuIFMuaW5BcnJheShlLGgpPT09YX0pKS5sZW5ndGgpLShnPWkubGVuZ3RoKSYmbytnPm4ucGFnZXJfbWF4T3B0aW9uU2l6ZSYmKHM9TWF0aC5mbG9vcihvLzIpLU1hdGguZmxvb3IoZy8yKSxBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGgsW3MsZ10pKSxoPWguY29uY2F0KGkpfXJldHVybiBoPVMuZ3JlcChoLGZ1bmN0aW9uKGUsYSl7cmV0dXJuIFMuaW5BcnJheShlLGgpPT09YX0pLnNvcnQoZnVuY3Rpb24oZSxhKXtyZXR1cm4gZS1hfSl9LGZpeEhlaWdodDpmdW5jdGlvbihlKXt2YXIgYSx0LHIsaT1lLnRhYmxlLHM9ZS5wYWdlcixvPWUud2lkZ2V0T3B0aW9ucyxnPWUuJHRib2RpZXMuZXEoMCk7Zy5maW5kKFwidHIucGFnZXJTYXZlZEhlaWdodFNwYWNlclwiKS5yZW1vdmUoKSxvLnBhZ2VyX2ZpeGVkSGVpZ2h0JiYhcy5pc0Rpc2FibGVkJiYodD1TLmRhdGEoaSxcInBhZ2VyU2F2ZWRIZWlnaHRcIikpJiYocj0wLDE8UyhpKS5jc3MoXCJib3JkZXItc3BhY2luZ1wiKS5zcGxpdChcIiBcIikubGVuZ3RoJiYocj1TKGkpLmNzcyhcImJvcmRlci1zcGFjaW5nXCIpLnNwbGl0KFwiIFwiKVsxXS5yZXBsYWNlKC9bXi1cXGRcXC5dL2csXCJcIikpLDU8KGE9dC1nLmhlaWdodCgpK3Iqcy5zaXplLXIpJiZTLmRhdGEoaSxcInBhZ2VyTGFzdFNpemVcIik9PT1zLnNpemUmJmcuY2hpbGRyZW4oXCJ0cjp2aXNpYmxlXCIpLmxlbmd0aDwoXCJhbGxcIj09PXMuc2l6ZT9zLnRvdGFsUm93czpzLnNpemUpJiZnLmFwcGVuZCgnPHRyIGNsYXNzPVwicGFnZXJTYXZlZEhlaWdodFNwYWNlciAnK2Uuc2VsZWN0b3JSZW1vdmUuc2xpY2UoMSkrJ1wiIHN0eWxlPVwiaGVpZ2h0OicrYSsncHg7XCI+PC90cj4nKSl9LGNoYW5nZUhlaWdodDpmdW5jdGlvbihlKXt2YXIgYSx0PWUudGFibGUscj1lLnBhZ2VyLGk9XCJhbGxcIj09PXIuc2l6ZT9yLnRvdGFsUm93czpyLnNpemUscz1lLiR0Ym9kaWVzLmVxKDApO3MuZmluZChcInRyLnBhZ2VyU2F2ZWRIZWlnaHRTcGFjZXJcIikucmVtb3ZlKCkscy5jaGlsZHJlbihcInRyOnZpc2libGVcIikubGVuZ3RofHxzLmFwcGVuZCgnPHRyIGNsYXNzPVwicGFnZXJTYXZlZEhlaWdodFNwYWNlciAnK2Uuc2VsZWN0b3JSZW1vdmUuc2xpY2UoMSkrJ1wiPjx0ZD4mbmJzcDwvdGQ+PC90cj4nKSxhPXMuY2hpbGRyZW4oXCJ0clwiKS5lcSgwKS5oZWlnaHQoKSppLFMuZGF0YSh0LFwicGFnZXJTYXZlZEhlaWdodFwiLGEpLEMuZml4SGVpZ2h0KGUpLFMuZGF0YSh0LFwicGFnZXJMYXN0U2l6ZVwiLHIuc2l6ZSl9LGhpZGVSb3dzOmZ1bmN0aW9uKGUpe2lmKCFlLndpZGdldE9wdGlvbnMucGFnZXJfYWpheFVybCl7dmFyIGEsdCxyLGkscyxvPWUucGFnZXIsZz1lLndpZGdldE9wdGlvbnMsbj1lLiR0Ym9kaWVzLmxlbmd0aCxsPVwiYWxsXCI9PT1vLnNpemU/by50b3RhbFJvd3M6by5zaXplLHA9by5wYWdlKmwsZD1wK2wsYz0tMSxmPTA7Zm9yKG8uY2FjaGVJbmRleD1bXSxhPTA7YTxuO2ErKyl7Zm9yKGk9KHI9ZS4kdGJvZGllcy5lcShhKS5jaGlsZHJlbihcInRyXCIpKS5sZW5ndGgsYz0tMSx0PWY9cz0wO3Q8aTt0Kyspby5yZWdleEZpbHRlcmVkLnRlc3Qoclt0XS5jbGFzc05hbWUpfHwoZj09PXAmJnJbdF0uY2xhc3NOYW1lLm1hdGNoKGUuY3NzQ2hpbGRSb3cpP3JbdF0uc3R5bGUuZGlzcGxheT1cIm5vbmVcIjooclt0XS5zdHlsZS5kaXNwbGF5PXA8PWYmJmY8ZD9cIlwiOlwibm9uZVwiLGMhPT1mJiZwPD1mJiZmPGQmJihvLmNhY2hlSW5kZXhbby5jYWNoZUluZGV4Lmxlbmd0aF09dCxjPWYpLChmKz1yW3RdLmNsYXNzTmFtZS5tYXRjaChlLmNzc0NoaWxkUm93K1wifFwiK2Uuc2VsZWN0b3JSZW1vdmUuc2xpY2UoMSkpJiYhZy5wYWdlcl9jb3VudENoaWxkUm93cz8wOjEpPT09ZCYmXCJub25lXCIhPT1yW3RdLnN0eWxlLmRpc3BsYXkmJnJbdF0uY2xhc3NOYW1lLm1hdGNoKCQuY3NzLmNzc0hhc0NoaWxkKSYmKHM9dCkpKTtpZigwPHMmJnJbc10uY2xhc3NOYW1lLm1hdGNoKCQuY3NzLmNzc0hhc0NoaWxkKSlmb3IoOysrczxpJiZyW3NdLmNsYXNzTmFtZS5tYXRjaChlLmNzc0NoaWxkUm93KTspcltzXS5zdHlsZS5kaXNwbGF5PVwiXCJ9fX0saGlkZVJvd3NTZXR1cDpmdW5jdGlvbihlKXt2YXIgYT1lLnBhZ2VyLHQ9ZS5uYW1lc3BhY2UrXCJwYWdlclwiLHI9YS4kY29udGFpbmVyLmZpbmQoZS53aWRnZXRPcHRpb25zLnBhZ2VyX3NlbGVjdG9ycy5wYWdlU2l6ZSkudmFsKCk7YS5zaXplPUMucGFyc2VQYWdlU2l6ZShlLHIsXCJnZXRcIiksQy5zZXRQYWdlU2l6ZShlLGEuc2l6ZSksQy5wYWdlckFycm93cyhlKSxlLndpZGdldE9wdGlvbnMucGFnZXJfcmVtb3ZlUm93c3x8KEMuaGlkZVJvd3MoZSksZS4kdGFibGUub24oXCJzb3J0RW5kIGZpbHRlckVuZCBcIi5zcGxpdChcIiBcIikuam9pbih0K1wiIFwiKSxmdW5jdGlvbigpe0MuaGlkZVJvd3MoZSl9KSl9LHJlbmRlckFqYXg6ZnVuY3Rpb24oZSxhLHQscixpKXt2YXIgcz1hLnRhYmxlLG89YS5wYWdlcixnPWEud2lkZ2V0T3B0aW9ucyxuPSQuZGVidWcoYSxcInBhZ2VyXCIpO2lmKFMuaXNGdW5jdGlvbihnLnBhZ2VyX2FqYXhQcm9jZXNzaW5nKSl7YS4kdGJvZGllcy5lcSgwKS5lbXB0eSgpO3ZhciBsLHAsZCxjLGYsdSxoLHcsUCxiLHosUix2LG0seCxqPWEuJHRhYmxlLF89XCJcIix5PWcucGFnZXJfYWpheFByb2Nlc3NpbmcoZSxzLHQpfHxbMCxbXV07aWYoJC5zaG93RXJyb3IocyksaSluJiZjb25zb2xlLmVycm9yKFwiUGFnZXIgPj4gQWpheCBFcnJvclwiLHQscixpKSwkLnNob3dFcnJvcihzLHQscixpKSxhLiR0Ym9kaWVzLmVxKDApLmNoaWxkcmVuKFwidHJcIikuZGV0YWNoKCksby50b3RhbFJvd3M9MDtlbHNle2lmKFMuaXNBcnJheSh5KT8odj15WyhkPWlzTmFOKHlbMF0pJiYhaXNOYU4oeVsxXSkpPzE6MF0sby50b3RhbFJvd3M9aXNOYU4odik/by50b3RhbFJvd3N8fDA6dixhLnRvdGFsUm93cz1hLmZpbHRlcmVkUm93cz1vLmZpbHRlcmVkUm93cz1vLnRvdGFsUm93cyx6PTA9PT1vLnRvdGFsUm93cz9bXTp5W2Q/MDoxXXx8W10sYj15WzJdKTooby5hamF4RGF0YT15LGEudG90YWxSb3dzPW8udG90YWxSb3dzPXkudG90YWwsYS5maWx0ZXJlZFJvd3M9by5maWx0ZXJlZFJvd3M9dm9pZCAwIT09eS5maWx0ZXJlZFJvd3M/eS5maWx0ZXJlZFJvd3M6eS50b3RhbCxiPXkuaGVhZGVycyx6PXkucm93c3x8W10pLFI9eiYmei5sZW5ndGgseiBpbnN0YW5jZW9mIFMpZy5wYWdlcl9wcm9jZXNzQWpheE9uSW5pdCYmKGEuJHRib2RpZXMuZXEoMCkuZW1wdHkoKSxhLiR0Ym9kaWVzLmVxKDApLmFwcGVuZCh6KSk7ZWxzZSBpZihSKXtmb3IobD0wO2w8UjtsKyspe2ZvcihfKz1cIjx0cj5cIixwPTA7cDx6W2xdLmxlbmd0aDtwKyspXys9L15cXHMqPHRkLy50ZXN0KHpbbF1bcF0pP1MudHJpbSh6W2xdW3BdKTpcIjx0ZD5cIit6W2xdW3BdK1wiPC90ZD5cIjtfKz1cIjwvdHI+XCJ9Zy5wYWdlcl9wcm9jZXNzQWpheE9uSW5pdCYmYS4kdGJvZGllcy5lcSgwKS5odG1sKF8pfWlmKGcucGFnZXJfcHJvY2Vzc0FqYXhPbkluaXQ9ITAsYil7Zm9yKHU9KGM9ai5oYXNDbGFzcyhcImhhc1N0aWNreUhlYWRlcnNcIikpP2cuJHN0aWNreS5jaGlsZHJlbihcInRoZWFkOmZpcnN0XCIpLmNoaWxkcmVuKFwidHI6bm90KC5cIithLmNzc0lnbm9yZVJvdytcIilcIikuY2hpbGRyZW4oKTpcIlwiLGY9ai5maW5kKFwidGZvb3QgdHI6Zmlyc3RcIikuY2hpbGRyZW4oKSxtPShoPWEuJGhlYWRlcnMuZmlsdGVyKFwidGhcIikpLmxlbmd0aCxwPTA7cDxtO3ArKykodz1oLmVxKHApKS5maW5kKFwiLlwiKyQuY3NzLmljb24pLmxlbmd0aD8oUD13LmZpbmQoXCIuXCIrJC5jc3MuaWNvbikuY2xvbmUoITApLHcuZmluZChcIi5cIiskLmNzcy5oZWFkZXJJbikuaHRtbChiW3BdKS5hcHBlbmQoUCksYyYmdS5sZW5ndGgmJihQPXUuZXEocCkuZmluZChcIi5cIiskLmNzcy5pY29uKS5jbG9uZSghMCksdS5lcShwKS5maW5kKFwiLlwiKyQuY3NzLmhlYWRlckluKS5odG1sKGJbcF0pLmFwcGVuZChQKSkpOih3LmZpbmQoXCIuXCIrJC5jc3MuaGVhZGVySW4pLmh0bWwoYltwXSksYyYmdS5sZW5ndGgmJihvLiRjb250YWluZXI9by4kY29udGFpbmVyLmFkZChnLiRzdGlja3kpLHUuZXEocCkuZmluZChcIi5cIiskLmNzcy5oZWFkZXJJbikuaHRtbChiW3BdKSkpLGYuZXEocCkuaHRtbChiW3BdKTtjJiZDLmJpbmRFdmVudHMoYSl9fWEuc2hvd1Byb2Nlc3NpbmcmJiQuaXNQcm9jZXNzaW5nKHMpLHg9Qy5wYXJzZVBhZ2VTaXplKGEsby5zaXplLFwiZ2V0XCIpLG8udG90YWxQYWdlcz1cImFsbFwiPT09eD8xOk1hdGguY2VpbChvLnRvdGFsUm93cy94KSxvLmxhc3QudG90YWxSb3dzPW8udG90YWxSb3dzLG8ubGFzdC5jdXJyZW50RmlsdGVycz1vLmN1cnJlbnRGaWx0ZXJzLG8ubGFzdC5zb3J0TGlzdD0oYS5zb3J0TGlzdHx8W10pLmpvaW4oXCIsXCIpLG8uaW5pdGlhbGl6aW5nPSExLEMudXBkYXRlUGFnZURpc3BsYXkoYSwhMSksJC51cGRhdGVDYWNoZShhLGZ1bmN0aW9uKCl7by5pbml0aWFsaXplZCYmc2V0VGltZW91dChmdW5jdGlvbigpe24mJmNvbnNvbGUubG9nKFwiUGFnZXIgPj4gVHJpZ2dlcmluZyBwYWdlckNoYW5nZVwiKSxqLnRyaWdnZXJIYW5kbGVyKFwicGFnZXJDaGFuZ2VcIixvKSwkLmFwcGx5V2lkZ2V0KHMpLEMudXBkYXRlUGFnZURpc3BsYXkoYSl9LDApfSl9by5pbml0aWFsaXplZHx8JC5hcHBseVdpZGdldChzKX0sZ2V0QWpheDpmdW5jdGlvbihpKXt2YXIgcixlPUMuZ2V0QWpheFVybChpKSxzPVMoZG9jdW1lbnQpLG89aS5uYW1lc3BhY2UrXCJwYWdlclwiLGc9aS5wYWdlcjtcIlwiIT09ZSYmKGkuc2hvd1Byb2Nlc3NpbmcmJiQuaXNQcm9jZXNzaW5nKGkudGFibGUsITApLHMub24oXCJhamF4RXJyb3JcIitvLGZ1bmN0aW9uKGUsYSx0LHIpe0MucmVuZGVyQWpheChudWxsLGksYSx0LHIpLHMub2ZmKFwiYWpheEVycm9yXCIrbyl9KSxyPSsrZy5hamF4Q291bnRlcixnLmxhc3QuYWpheFVybD1lLGcuYWpheE9iamVjdC51cmw9ZSxnLmFqYXhPYmplY3Quc3VjY2Vzcz1mdW5jdGlvbihlLGEsdCl7cjxnLmFqYXhDb3VudGVyfHwoQy5yZW5kZXJBamF4KGUsaSx0KSxzLm9mZihcImFqYXhFcnJvclwiK28pLFwiZnVuY3Rpb25cIj09dHlwZW9mIGcub2xkQWpheFN1Y2Nlc3MmJmcub2xkQWpheFN1Y2Nlc3MoZSkpfSwkLmRlYnVnKGksXCJwYWdlclwiKSYmY29uc29sZS5sb2coXCJQYWdlciA+PiBBamF4IGluaXRpYWxpemVkXCIsZy5hamF4T2JqZWN0KSxTLmFqYXgoZy5hamF4T2JqZWN0KSl9LGdldEFqYXhVcmw6ZnVuY3Rpb24oZSl7dmFyIGEsdCxyPWUucGFnZXIsaT1lLndpZGdldE9wdGlvbnMscz1pLnBhZ2VyX2FqYXhVcmw/aS5wYWdlcl9hamF4VXJsLnJlcGxhY2UoL1xce3BhZ2UoW1xcLStdXFxkKyk/XFx9LyxmdW5jdGlvbihlLGEpe3JldHVybiByLnBhZ2UrKGE/cGFyc2VJbnQoYSwxMCk6MCl9KS5yZXBsYWNlKC9cXHtzaXplXFx9L2csci5zaXplKTpcIlwiLG89ZS5zb3J0TGlzdCxnPXIuY3VycmVudEZpbHRlcnN8fGUuJHRhYmxlLmRhdGEoXCJsYXN0U2VhcmNoXCIpfHxbXSxuPXMubWF0Y2goL1xce1xccypzb3J0KD86TGlzdCk/XFxzKjpcXHMqKFxcdyopXFxzKlxcfS8pLGw9cy5tYXRjaCgvXFx7XFxzKmZpbHRlcig/Okxpc3QpP1xccyo6XFxzKihcXHcqKVxccypcXH0vKSxwPVtdO2lmKG4pe2ZvcihuPW5bMV0sdD1vLmxlbmd0aCxhPTA7YTx0O2ErKylwW3AubGVuZ3RoXT1uK1wiW1wiK29bYV1bMF0rXCJdPVwiK29bYV1bMV07cz1zLnJlcGxhY2UoL1xce1xccypzb3J0KD86TGlzdCk/XFxzKjpcXHMqKFxcdyopXFxzKlxcfS9nLHAubGVuZ3RoP3Auam9pbihcIiZcIik6bikscD1bXX1pZihsKXtmb3IobD1sWzFdLHQ9Zy5sZW5ndGgsYT0wO2E8dDthKyspZ1thXSYmKHBbcC5sZW5ndGhdPWwrXCJbXCIrYStcIl09XCIrZW5jb2RlVVJJQ29tcG9uZW50KGdbYV0pKTtzPXMucmVwbGFjZSgvXFx7XFxzKmZpbHRlcig/Okxpc3QpP1xccyo6XFxzKihcXHcqKVxccypcXH0vZyxwLmxlbmd0aD9wLmpvaW4oXCImXCIpOmwpLHIuY3VycmVudEZpbHRlcnM9Z31yZXR1cm4gUy5pc0Z1bmN0aW9uKGkucGFnZXJfY3VzdG9tQWpheFVybCkmJihzPWkucGFnZXJfY3VzdG9tQWpheFVybChlLnRhYmxlLHMpKSwkLmRlYnVnKGUsXCJwYWdlclwiKSYmY29uc29sZS5sb2coXCJQYWdlciA+PiBBamF4IHVybCA9IFwiK3MpLHN9LHJlbmRlclRhYmxlOmZ1bmN0aW9uKGUsYSl7dmFyIHQscixpLHMsbz1lLnRhYmxlLGc9ZS5wYWdlcixuPWUud2lkZ2V0T3B0aW9ucyxsPSQuZGVidWcoZSxcInBhZ2VyXCIpLHA9ZS4kdGFibGUuaGFzQ2xhc3MoXCJoYXNGaWx0ZXJzXCIpLGQ9YSYmYS5sZW5ndGh8fDAsYz1cImFsbFwiPT09Zy5zaXplP2cudG90YWxSb3dzOmcuc2l6ZSxmPWcucGFnZSpjO2lmKGQ8MSlsJiZjb25zb2xlLndhcm4oXCJQYWdlciA+PiBObyByb3dzIGZvciBwYWdlciB0byByZW5kZXJcIik7ZWxzZXtpZihnLnBhZ2U+PWcudG90YWxQYWdlcylyZXR1cm4gQy5tb3ZlVG9MYXN0UGFnZShlLGcpO2lmKGcuY2FjaGVJbmRleD1bXSxnLmlzRGlzYWJsZWQ9ITEsZy5pbml0aWFsaXplZCYmKGwmJmNvbnNvbGUubG9nKFwiUGFnZXIgPj4gVHJpZ2dlcmluZyBwYWdlckNoYW5nZVwiKSxlLiR0YWJsZS50cmlnZ2VySGFuZGxlcihcInBhZ2VyQ2hhbmdlXCIsZSkpLG4ucGFnZXJfcmVtb3ZlUm93cyl7Zm9yKCQuY2xlYXJUYWJsZUJvZHkobyksdD0kLnByb2Nlc3NUYm9keShvLGUuJHRib2RpZXMuZXEoMCksITApLGk9cj1wPzA6ZixzPTA7czxjJiZyPGEubGVuZ3RoOylwJiZnLnJlZ2V4RmlsdGVyZWQudGVzdChhW3JdWzBdLmNsYXNzTmFtZSl8fGY8KytpJiZzPD1jJiYocysrLGcuY2FjaGVJbmRleFtnLmNhY2hlSW5kZXgubGVuZ3RoXT1yLHQuYXBwZW5kKGFbcl0pKSxyKys7JC5wcm9jZXNzVGJvZHkobyx0LCExKX1lbHNlIEMuaGlkZVJvd3MoZSk7Qy51cGRhdGVQYWdlRGlzcGxheShlKSxuLnBhZ2VyX3N0YXJ0UGFnZT1nLnBhZ2Usbi5wYWdlcl9zaXplPWcuc2l6ZSxvLmlzVXBkYXRpbmcmJihsJiZjb25zb2xlLmxvZyhcIlBhZ2VyID4+IFRyaWdnZXJpbmcgdXBkYXRlQ29tcGxldGVcIiksZS4kdGFibGUudHJpZ2dlckhhbmRsZXIoXCJ1cGRhdGVDb21wbGV0ZVwiLFtvLCEwXSkpfX0sc2hvd0FsbFJvd3M6ZnVuY3Rpb24oZSl7dmFyIGEsdCxyLGk9ZS50YWJsZSxzPWUucGFnZXIsbz1lLndpZGdldE9wdGlvbnM7Zm9yKHMuYWpheD9DLnBhZ2VyQXJyb3dzKGUsITApOihTLmRhdGEoaSxcInBhZ2VyTGFzdFBhZ2VcIixzLnBhZ2UpLFMuZGF0YShpLFwicGFnZXJMYXN0U2l6ZVwiLHMuc2l6ZSkscy5wYWdlPTAscy5zaXplPXMudG90YWxSb3dzLHMudG90YWxQYWdlcz0xLGUuJHRhYmxlLmFkZENsYXNzKFwicGFnZXJEaXNhYmxlZFwiKS5yZW1vdmVBdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKS5maW5kKFwidHIucGFnZXJTYXZlZEhlaWdodFNwYWNlclwiKS5yZW1vdmUoKSxDLnJlbmRlclRhYmxlKGUsZS5yb3dzQ29weSkscy5pc0Rpc2FibGVkPSEwLCQuYXBwbHlXaWRnZXQoaSksJC5kZWJ1ZyhlLFwicGFnZXJcIikmJmNvbnNvbGUubG9nKFwiUGFnZXIgPj4gRGlzYWJsZWRcIikpLHI9KHQ9cy4kY29udGFpbmVyLmZpbmQoby5wYWdlcl9zZWxlY3RvcnMucGFnZVNpemUrXCIsXCIrby5wYWdlcl9zZWxlY3RvcnMuZ290b1BhZ2UrXCIsLnRzLXN0YXJ0Um93LCAudHMtcGFnZVwiKSkubGVuZ3RoLGE9MDthPHI7YSsrKXQuZXEoYSkucHJvcChcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIikuYWRkQ2xhc3Moby5wYWdlcl9jc3MuZGlzYWJsZWQpWzBdLmRpc2FibGVkPSEwfSx1cGRhdGVDYWNoZTpmdW5jdGlvbihyKXt2YXIgaT1yLnBhZ2VyOyQudXBkYXRlQ2FjaGUocixmdW5jdGlvbigpe2lmKCFTLmlzRW1wdHlPYmplY3Qoci5jYWNoZSkpe3ZhciBlLGE9W10sdD1yLmNhY2hlWzBdLm5vcm1hbGl6ZWQ7Zm9yKGkudG90YWxSb3dzPXQubGVuZ3RoLGU9MDtlPGkudG90YWxSb3dzO2UrKylhW2EubGVuZ3RoXT10W2VdW3IuY29sdW1uc10uJHJvdztyLnJvd3NDb3B5PWEsQy5tb3ZlVG9QYWdlKHIsaSwhMCksaS5sYXN0LmN1cnJlbnRGaWx0ZXJzPVtcIiBcIl19fSl9LG1vdmVUb1BhZ2U6ZnVuY3Rpb24oZSxhLHQpe2lmKCFhLmlzRGlzYWJsZWQpe2lmKCExIT09dCYmYS5pbml0aWFsaXplZCYmUy5pc0VtcHR5T2JqZWN0KGUuY2FjaGUpKXJldHVybiBDLnVwZGF0ZUNhY2hlKGUpO3ZhciByLGk9ZS50YWJsZSxzPWUud2lkZ2V0T3B0aW9ucyxvPWEubGFzdCxnPSQuZGVidWcoZSxcInBhZ2VyXCIpO2EuYWpheCYmIXMuZmlsdGVyX2luaXRpYWxpemVkJiYkLmhhc1dpZGdldChpLFwiZmlsdGVyXCIpfHwoQy5wYXJzZVBhZ2VOdW1iZXIoZSxhKSxDLmNhbGNGaWx0ZXJzKGUpLG8uY3VycmVudEZpbHRlcnM9XCJcIj09PShvLmN1cnJlbnRGaWx0ZXJzfHxbXSkuam9pbihcIlwiKT9bXTpvLmN1cnJlbnRGaWx0ZXJzLGEuY3VycmVudEZpbHRlcnM9XCJcIj09PShhLmN1cnJlbnRGaWx0ZXJzfHxbXSkuam9pbihcIlwiKT9bXTphLmN1cnJlbnRGaWx0ZXJzLG8ucGFnZT09PWEucGFnZSYmby5zaXplPT09YS5zaXplJiZvLnRvdGFsUm93cz09PWEudG90YWxSb3dzJiYoby5jdXJyZW50RmlsdGVyc3x8W10pLmpvaW4oXCIsXCIpPT09KGEuY3VycmVudEZpbHRlcnN8fFtdKS5qb2luKFwiLFwiKSYmKG8uYWpheFVybHx8XCJcIik9PT0oYS5hamF4T2JqZWN0LnVybHx8XCJcIikmJihvLm9wdEFqYXhVcmx8fFwiXCIpPT09KHMucGFnZXJfYWpheFVybHx8XCJcIikmJm8uc29ydExpc3Q9PT0oZS5zb3J0TGlzdHx8W10pLmpvaW4oXCIsXCIpfHwoZyYmY29uc29sZS5sb2coXCJQYWdlciA+PiBDaGFuZ2luZyB0byBwYWdlIFwiK2EucGFnZSksYS5sYXN0PXtwYWdlOmEucGFnZSxzaXplOmEuc2l6ZSxzb3J0TGlzdDooZS5zb3J0TGlzdHx8W10pLmpvaW4oXCIsXCIpLHRvdGFsUm93czphLnRvdGFsUm93cyxjdXJyZW50RmlsdGVyczphLmN1cnJlbnRGaWx0ZXJzfHxbXSxhamF4VXJsOmEuYWpheE9iamVjdC51cmx8fFwiXCIsb3B0QWpheFVybDpzLnBhZ2VyX2FqYXhVcmx9LGEuYWpheD9zLnBhZ2VyX3Byb2Nlc3NBamF4T25Jbml0fHxTLmlzRW1wdHlPYmplY3Qocy5wYWdlcl9pbml0aWFsUm93cyk/Qy5nZXRBamF4KGUpOihzLnBhZ2VyX3Byb2Nlc3NBamF4T25Jbml0PSEwLHI9cy5wYWdlcl9pbml0aWFsUm93cyxhLnRvdGFsUm93cz12b2lkIDAhPT1yLnRvdGFsP3IudG90YWw6ZyYmY29uc29sZS5lcnJvcihcIlBhZ2VyID4+IE5vIGluaXRpYWwgdG90YWwgcGFnZSBzZXQhXCIpfHwwLGEuZmlsdGVyZWRSb3dzPXZvaWQgMCE9PXIuZmlsdGVyZWQ/ci5maWx0ZXJlZDpnJiZjb25zb2xlLmVycm9yKFwiUGFnZXIgPj4gTm8gaW5pdGlhbCBmaWx0ZXJlZCBwYWdlIHNldCFcIil8fDAsQy51cGRhdGVQYWdlRGlzcGxheShlLCExKSk6YS5hamF4fHxDLnJlbmRlclRhYmxlKGUsZS5yb3dzQ29weSksUy5kYXRhKGksXCJwYWdlckxhc3RQYWdlXCIsYS5wYWdlKSxhLmluaXRpYWxpemVkJiYhMSE9PXQmJihnJiZjb25zb2xlLmxvZyhcIlBhZ2VyID4+IFRyaWdnZXJpbmcgcGFnZU1vdmVkXCIpLGUuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKFwicGFnZU1vdmVkXCIsZSksJC5hcHBseVdpZGdldChpKSwhYS5hamF4JiZpLmlzVXBkYXRpbmcmJihnJiZjb25zb2xlLmxvZyhcIlBhZ2VyID4+IFRyaWdnZXJpbmcgdXBkYXRlQ29tcGxldGVcIiksZS4kdGFibGUudHJpZ2dlckhhbmRsZXIoXCJ1cGRhdGVDb21wbGV0ZVwiLFtpLCEwXSkpKSkpfX0sZ2V0VG90YWxQYWdlczpmdW5jdGlvbihlLGEpe3JldHVybiAkLmhhc1dpZGdldChlLnRhYmxlLFwiZmlsdGVyXCIpP01hdGgubWluKGEudG90YWxQYWdlcyxhLmZpbHRlcmVkUGFnZXMpOmEudG90YWxQYWdlc30scGFyc2VQYWdlTnVtYmVyOmZ1bmN0aW9uKGUsYSl7dmFyIHQ9Qy5nZXRUb3RhbFBhZ2VzKGUsYSktMTtyZXR1cm4gYS5wYWdlPXBhcnNlSW50KGEucGFnZSwxMCksKGEucGFnZTwwfHxpc05hTihhLnBhZ2UpKSYmKGEucGFnZT0wKSxhLnBhZ2U+dCYmMDw9dCYmKGEucGFnZT10KSxhLnBhZ2V9LHBhcnNlUGFnZVNpemU6ZnVuY3Rpb24oZSxhLHQpe3ZhciByPWUucGFnZXIsaT1lLndpZGdldE9wdGlvbnMscz1wYXJzZUludChhLDEwKXx8ci5zaXplfHxpLnBhZ2VyX3NpemV8fDEwO3JldHVybiByLmluaXRpYWxpemVkJiYoL2FsbC9pLnRlc3QocytcIiBcIithKXx8cz09PXIudG90YWxSb3dzKT9yLiRjb250YWluZXIuZmluZChpLnBhZ2VyX3NlbGVjdG9ycy5wYWdlU2l6ZSsnIG9wdGlvblt2YWx1ZT1cImFsbFwiXScpLmxlbmd0aD9cImFsbFwiOnIudG90YWxSb3dzOlwiZ2V0XCI9PT10P3M6ci5zaXplfSxzZXRQYWdlU2l6ZTpmdW5jdGlvbihlLGEpe3ZhciB0PWUucGFnZXIscj1lLnRhYmxlO3Quc2l6ZT1DLnBhcnNlUGFnZVNpemUoZSxhLFwiZ2V0XCIpLHQuJGNvbnRhaW5lci5maW5kKGUud2lkZ2V0T3B0aW9ucy5wYWdlcl9zZWxlY3RvcnMucGFnZVNpemUpLnZhbCh0LnNpemUpLFMuZGF0YShyLFwicGFnZXJMYXN0UGFnZVwiLEMucGFyc2VQYWdlTnVtYmVyKGUsdCkpLFMuZGF0YShyLFwicGFnZXJMYXN0U2l6ZVwiLHQuc2l6ZSksdC50b3RhbFBhZ2VzPVwiYWxsXCI9PT10LnNpemU/MTpNYXRoLmNlaWwodC50b3RhbFJvd3MvdC5zaXplKSx0LmZpbHRlcmVkUGFnZXM9XCJhbGxcIj09PXQuc2l6ZT8xOk1hdGguY2VpbCh0LmZpbHRlcmVkUm93cy90LnNpemUpfSxtb3ZlVG9GaXJzdFBhZ2U6ZnVuY3Rpb24oZSxhKXthLnBhZ2U9MCxDLm1vdmVUb1BhZ2UoZSxhLCEwKX0sbW92ZVRvTGFzdFBhZ2U6ZnVuY3Rpb24oZSxhKXthLnBhZ2U9Qy5nZXRUb3RhbFBhZ2VzKGUsYSktMSxDLm1vdmVUb1BhZ2UoZSxhLCEwKX0sbW92ZVRvTmV4dFBhZ2U6ZnVuY3Rpb24oZSxhKXthLnBhZ2UrKzt2YXIgdD1DLmdldFRvdGFsUGFnZXMoZSxhKS0xO2EucGFnZT49dCYmKGEucGFnZT10KSxDLm1vdmVUb1BhZ2UoZSxhLCEwKX0sbW92ZVRvUHJldlBhZ2U6ZnVuY3Rpb24oZSxhKXthLnBhZ2UtLSxhLnBhZ2U8PTAmJihhLnBhZ2U9MCksQy5tb3ZlVG9QYWdlKGUsYSwhMCl9LGRlc3Ryb3lQYWdlcjpmdW5jdGlvbihlLGEpe3ZhciB0PWUudGFibGUscj1lLnBhZ2VyLGk9ZS53aWRnZXRPcHRpb25zLnBhZ2VyX3NlbGVjdG9yc3x8e30scz1baS5maXJzdCxpLnByZXYsaS5uZXh0LGkubGFzdCxpLmdvdG9QYWdlLGkucGFnZVNpemVdLmpvaW4oXCIsXCIpLG89ZS5uYW1lc3BhY2UrXCJwYWdlclwiO2lmKHIpe2lmKHIuaW5pdGlhbGl6ZWQ9ITEsZS4kdGFibGUub2ZmKG8pLHIuJGNvbnRhaW5lci5oaWRlKCkuZmluZChzKS5vZmYobyksYSlyZXR1cm47ZS5hcHBlbmRlcj1udWxsLEMuc2hvd0FsbFJvd3MoZSksJC5zdG9yYWdlJiYkLnN0b3JhZ2UodCxlLndpZGdldE9wdGlvbnMucGFnZXJfc3RvcmFnZUtleSxcIlwiKSxyLiRjb250YWluZXI9bnVsbCxlLnBhZ2VyPW51bGwsZS5yb3dzQ29weT1udWxsfX0sZW5hYmxlUGFnZXI6ZnVuY3Rpb24oZSxhKXt2YXIgdCxyLGk9ZS50YWJsZSxzPWUucGFnZXIsbz1lLndpZGdldE9wdGlvbnMsZz1zLiRjb250YWluZXIuZmluZChvLnBhZ2VyX3NlbGVjdG9ycy5wYWdlU2l6ZSk7cy5pc0Rpc2FibGVkPSExLHMucGFnZT1TLmRhdGEoaSxcInBhZ2VyTGFzdFBhZ2VcIil8fHMucGFnZXx8MCxyPWcuZmluZChcIm9wdGlvbltzZWxlY3RlZF1cIikudmFsKCkscy5zaXplPVMuZGF0YShpLFwicGFnZXJMYXN0U2l6ZVwiKXx8Qy5wYXJzZVBhZ2VTaXplKGUscixcImdldFwiKSxDLnNldFBhZ2VTaXplKGUscy5zaXplKSxzLnRvdGFsUGFnZXM9XCJhbGxcIj09PXMuc2l6ZT8xOk1hdGguY2VpbChDLmdldFRvdGFsUGFnZXMoZSxzKS9zLnNpemUpLGUuJHRhYmxlLnJlbW92ZUNsYXNzKFwicGFnZXJEaXNhYmxlZFwiKSxpLmlkJiYhZS4kdGFibGUuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIikmJigodD0oZz1zLiRjb250YWluZXIuZmluZChvLnBhZ2VyX3NlbGVjdG9ycy5wYWdlRGlzcGxheSkpLmF0dHIoXCJpZFwiKSl8fCh0PWkuaWQrXCJfcGFnZXJfaW5mb1wiLGcuYXR0cihcImlkXCIsdCkpLGUuJHRhYmxlLmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsdCkpLEMuY2hhbmdlSGVpZ2h0KGUpLGEmJigkLnVwZGF0ZShlKSxDLnNldFBhZ2VTaXplKGUscy5zaXplKSxDLm1vdmVUb1BhZ2UoZSxzLCEwKSxDLmhpZGVSb3dzU2V0dXAoZSksJC5kZWJ1ZyhlLFwicGFnZXJcIikmJmNvbnNvbGUubG9nKFwiUGFnZXIgPj4gRW5hYmxlZFwiKSl9LGFwcGVuZGVyOmZ1bmN0aW9uKGUsYSl7dmFyIHQ9ZS5jb25maWcscj10LndpZGdldE9wdGlvbnMsaT10LnBhZ2VyO2kuYWpheD9DLm1vdmVUb1BhZ2UodCxpLCEwKToodC5yb3dzQ29weT1hLGkudG90YWxSb3dzPXIucGFnZXJfY291bnRDaGlsZFJvd3M/dC4kdGJvZGllcy5lcSgwKS5jaGlsZHJlbihcInRyXCIpLmxlbmd0aDphLmxlbmd0aCxpLnNpemU9Uy5kYXRhKGUsXCJwYWdlckxhc3RTaXplXCIpfHxpLnNpemV8fHIucGFnZXJfc2l6ZXx8aS5zZXRTaXplfHwxMCxpLnRvdGFsUGFnZXM9XCJhbGxcIj09PWkuc2l6ZT8xOk1hdGguY2VpbChpLnRvdGFsUm93cy9pLnNpemUpLEMubW92ZVRvUGFnZSh0LGkpLEMudXBkYXRlUGFnZURpc3BsYXkodCwhMSkpfX0sJC5zaG93RXJyb3I9ZnVuY3Rpb24oZSxhLHQscil7ZnVuY3Rpb24gaSgpe28uJHRhYmxlLmZpbmQoXCJ0aGVhZFwiKS5maW5kKG8uc2VsZWN0b3JSZW1vdmUpLnJlbW92ZSgpfXZhciBzPVMoZSksbz1zWzBdLmNvbmZpZyxnPW8mJm8ud2lkZ2V0T3B0aW9ucyxuPW8ucGFnZXImJm8ucGFnZXIuY3NzRXJyb3JSb3d8fGcmJmcucGFnZXJfY3NzJiZnLnBhZ2VyX2Nzcy5lcnJvclJvd3x8XCJ0YWJsZXNvcnRlci1lcnJvclJvd1wiLGw9dHlwZW9mIGEscD0hMCxkPVwiXCI7aWYocy5sZW5ndGgpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8ucGFnZXIuYWpheEVycm9yKXtpZighMT09PShwPW8ucGFnZXIuYWpheEVycm9yKG8sYSx0LHIpKSlyZXR1cm4gaSgpO2Q9cH1lbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGcucGFnZXJfYWpheEVycm9yKXtpZighMT09PShwPWcucGFnZXJfYWpheEVycm9yKG8sYSx0LHIpKSlyZXR1cm4gaSgpO2Q9cH1pZihcIlwiPT09ZClpZihcIm9iamVjdFwiPT1sKWQ9MD09PWEuc3RhdHVzP1wiTm90IGNvbm5lY3RlZCwgdmVyaWZ5IE5ldHdvcmtcIjo0MDQ9PT1hLnN0YXR1cz9cIlJlcXVlc3RlZCBwYWdlIG5vdCBmb3VuZCBbNDA0XVwiOjUwMD09PWEuc3RhdHVzP1wiSW50ZXJuYWwgU2VydmVyIEVycm9yIFs1MDBdXCI6XCJwYXJzZXJlcnJvclwiPT09cj9cIlJlcXVlc3RlZCBKU09OIHBhcnNlIGZhaWxlZFwiOlwidGltZW91dFwiPT09cj9cIlRpbWUgb3V0IGVycm9yXCI6XCJhYm9ydFwiPT09cj9cIkFqYXggUmVxdWVzdCBhYm9ydGVkXCI6XCJVbmNhdWdodCBlcnJvcjogXCIrYS5zdGF0dXNUZXh0K1wiIFtcIithLnN0YXR1cytcIl1cIjtlbHNle2lmKFwic3RyaW5nXCIhPWwpcmV0dXJuIGkoKTtkPWF9UygvdHJcXD4vLnRlc3QoZCk/ZDonPHRyPjx0ZCBjb2xzcGFuPVwiJytvLmNvbHVtbnMrJ1wiPicrZCtcIjwvdGQ+PC90cj5cIikuY2xpY2soZnVuY3Rpb24oKXtTKHRoaXMpLnJlbW92ZSgpfSkuYXBwZW5kVG8oby4kdGFibGUuZmluZChcInRoZWFkOmZpcnN0XCIpKS5hZGRDbGFzcyhuK1wiIFwiK28uc2VsZWN0b3JSZW1vdmUuc2xpY2UoMSkpLmF0dHIoe3JvbGU6XCJhbGVydFwiLFwiYXJpYS1saXZlXCI6XCJhc3NlcnRpdmVcIn0pfWVsc2UgY29uc29sZS5lcnJvcihcInRhYmxlc29ydGVyIHNob3dFcnJvcjogbm8gdGFibGUgcGFyYW1ldGVyIHBhc3NlZFwiKX19KGpRdWVyeSk7cmV0dXJuIGpRdWVyeTt9KSk7XG4iLCIoZnVuY3Rpb24oZmFjdG9yeSl7aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCl7ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO30gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jyl7bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTt9IGVsc2Uge2ZhY3RvcnkoalF1ZXJ5KTt9fShmdW5jdGlvbihqUXVlcnkpe1xuXG4hZnVuY3Rpb24odSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGg9dS50YWJsZXNvcnRlcix3PXtpbml0OmZ1bmN0aW9uKGUsdCxsKXt2YXIgbyxyPWwucmVmbG93X2RhdGFBdHRyaWIsYT1sLnJlZmxvd19oZWFkZXJBdHRyaWIscz1bXTt0LiR0YWJsZS5hZGRDbGFzcyhsLnJlZmxvd19jbGFzc05hbWUpLm9mZihcInJlZnJlc2gudHNyZWZsb3cgdXBkYXRlQ29tcGxldGUudHNyZWZsb3cyXCIpLm9uKFwicmVmcmVzaC50c3JlZmxvdyB1cGRhdGVDb21wbGV0ZS50c3JlZmxvdzJcIixmdW5jdGlvbigpe3cuaW5pdChlLHQsbCl9KSx0LiRoZWFkZXJzLmVhY2goZnVuY3Rpb24oKXtvPXUodGhpcykscy5wdXNoKHUudHJpbShvLmF0dHIoYSl8fG8udGV4dCgpKSl9KSx0LiR0Ym9kaWVzLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpe3UodGhpcykuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGUpe3UodGhpcykuYXR0cihyLHNbZV0pfSl9KX0saW5pdDI6ZnVuY3Rpb24oZSx0LGwpe3ZhciBvLHIsYSxzLGksbixmPXQuY29sdW1ucyxjPWwucmVmbG93Ml9oZWFkZXJBdHRyaWIsZD1bXTtmb3IodC4kdGFibGUuYWRkQ2xhc3MobC5yZWZsb3cyX2NsYXNzTmFtZSkub2ZmKFwicmVmcmVzaC50c3JlZmxvdzIgdXBkYXRlQ29tcGxldGUudHNyZWZsb3cyXCIpLm9uKFwicmVmcmVzaC50c3JlZmxvdzIgdXBkYXRlQ29tcGxldGUudHNyZWZsb3cyXCIsZnVuY3Rpb24oKXt3LmluaXQyKGUsdCxsKX0pLGE9MDthPGY7YSsrKTE8KHM9dC4kaGVhZGVycy5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicrYSsnXCJdJykpLmxlbmd0aD8oaT1bXSxzLmVhY2goZnVuY3Rpb24oKXsobz11KHRoaXMpKS5oYXNDbGFzcyhsLnJlZmxvdzJfY2xhc3NJZ25vcmUpfHxpLnB1c2goby5hdHRyKGMpfHxvLnRleHQoKSl9KSk6aT1bcy5hdHRyKGMpfHxzLnRleHQoKV0sZC5wdXNoKGkpO2k9JzxiIGNsYXNzPVwiJyt0LnNlbGVjdG9yUmVtb3ZlLnNsaWNlKDEpK1wiIFwiK2wucmVmbG93Ml9sYWJlbENsYXNzLHQuJHRib2RpZXMuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKCl7KHI9aC5wcm9jZXNzVGJvZHkoZSx1KHRoaXMpLCEwKSkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGUpe2ZvcihvPXUodGhpcyksbj1kW2VdLmxlbmd0aCxhPW4tMTswPD1hOylvLnByZXBlbmQoaSsoMD09PWEmJjE8bj9cIiBcIitsLnJlZmxvdzJfbGFiZWxUb3A6XCJcIikrJ1wiPicrZFtlXVthXStcIjwvYj5cIiksYS0tfSksaC5wcm9jZXNzVGJvZHkoZSxyLCExKX0pfSxyZW1vdmU6ZnVuY3Rpb24oZSx0LGwpe3QuJHRhYmxlLnJlbW92ZUNsYXNzKGwucmVmbG93X2NsYXNzTmFtZSl9LHJlbW92ZTI6ZnVuY3Rpb24oZSx0LGwpe3QuJHRhYmxlLnJlbW92ZUNsYXNzKGwucmVmbG93Ml9jbGFzc05hbWUpfX07aC5hZGRXaWRnZXQoe2lkOlwicmVmbG93XCIsb3B0aW9uczp7cmVmbG93X2NsYXNzTmFtZTpcInVpLXRhYmxlLXJlZmxvd1wiLHJlZmxvd19oZWFkZXJBdHRyaWI6XCJkYXRhLW5hbWVcIixyZWZsb3dfZGF0YUF0dHJpYjpcImRhdGEtdGl0bGVcIn0saW5pdDpmdW5jdGlvbihlLHQsbCxvKXt3LmluaXQoZSxsLG8pfSxyZW1vdmU6ZnVuY3Rpb24oZSx0LGwpe3cucmVtb3ZlKGUsdCxsKX19KSxoLmFkZFdpZGdldCh7aWQ6XCJyZWZsb3cyXCIsb3B0aW9uczp7cmVmbG93Ml9jbGFzc05hbWU6XCJ1aS10YWJsZS1yZWZsb3dcIixyZWZsb3cyX2NsYXNzSWdub3JlOlwidWktdGFibGUtcmVmbG93LWlnbm9yZVwiLHJlZmxvdzJfaGVhZGVyQXR0cmliOlwiZGF0YS1uYW1lXCIscmVmbG93Ml9sYWJlbENsYXNzOlwidWktdGFibGUtY2VsbC1sYWJlbFwiLHJlZmxvdzJfbGFiZWxUb3A6XCJ1aS10YWJsZS1jZWxsLWxhYmVsLXRvcFwifSxpbml0OmZ1bmN0aW9uKGUsdCxsLG8pe3cuaW5pdDIoZSxsLG8pfSxyZW1vdmU6ZnVuY3Rpb24oZSx0LGwpe3cucmVtb3ZlMihlLHQsbCl9fSl9KGpRdWVyeSk7cmV0dXJuIGpRdWVyeTt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=